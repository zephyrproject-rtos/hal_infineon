<?xml version="1.0" encoding="utf-8"?>
<device schemaVersion="1.3" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
  <vendor>Infineon Technologies</vendor>
  <vendorID>Infineon</vendorID>
  <name>fx3g2</name>
  <series>FX3G2</series>
  <version>1.0</version>
  <description>FX3G2</description>
  <licenseText>(c) (2016-2024), Cypress Semiconductor Corporation (an Infineon company)\n
    or an affiliate of Cypress Semiconductor Corporation.\n
\n
    SPDX-License-Identifier: Apache-2.0\n
\n
    Licensed under the Apache License, Version 2.0 (the "License");\n
    you may not use this file except in compliance with the License.\n
    You may obtain a copy of the License at\n
\n
      http://www.apache.org/licenses/LICENSE-2.0\n
\n
    Unless required by applicable law or agreed to in writing, software\n
    distributed under the License is distributed on an "AS IS" BASIS,\n
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n
    See the License for the specific language governing permissions and\n
    limitations under the License.</licenseText>
  <cpu>
    <name>CM4</name>
    <revision>r0p1</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <vtorPresent>true</vtorPresent>
    <nvicPrioBits>3</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
  </cpu>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <resetValue>0x00000000</resetValue>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals>
    <peripheral>
      <name>PERI</name>
      <description>Peripheral interconnect</description>
      <baseAddress>0x40000000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>TIMEOUT_CTL</name>
          <description>Timeout control</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFF</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>TIMEOUT</name>
              <description>This field specifies a number of clock cycles (clk_slow). If an AHB-Lite bus transfer takes more than the specified number of cycles (timeout detection), the bus transfer is terminated with an AHB-Lite bus error and a fault is generated (and possibly recorded in the fault report structure(s)).
'0x0000'-'0xfffe': Number of clock cycles.
'0xffff': This value is the default/reset value and specifies that no timeout detection is performed: a bus transfer will never be terminated and a fault will never be generated.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CMD</name>
          <description>Trigger command</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xE0001FFF</resetMask>
          <fields>
            <field>
              <name>TR_SEL</name>
              <description>Specifies the activated trigger when ACTIVATE is '1'. If the specified trigger is not present, the trigger activation has no effect.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GROUP_SEL</name>
              <description>Specifies the trigger group:
'0'-'15': trigger multiplexer groups.
'16'-'31': trigger 1-to-1 groups.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_EDGE</name>
              <description>Specifies if the activated  trigger is treated as a level sensitive or edge sensitive  trigger.
'0': level sensitive. The trigger reflects TR_CMD.ACTIVATE.
'1': edge sensitive trigger. The trigger is activated for two clk_peri cycles.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUT_SEL</name>
              <description>Specifies whether trigger activation is for a specific input or output trigger of the trigger multiplexer. Activation of a specific input trigger, will result in activation of all output triggers that have the specific input trigger selected through their TR_OUT_CTL.TR_SEL  field. Activation of a specific output trigger, will result in activation of the specified TR_SEL output trigger only.
'0': TR_SEL selection and trigger activation is for an input trigger to the trigger multiplexer.
'1': TR_SEL selection and trigger activation is for an output trigger from the trigger multiplexer.

Note: this field is not used for trigger 1-to-1 groups.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACTIVATE</name>
              <description>SW sets this field to '1' to activate (set to '1') a trigger as identified by TR_SEL, TR_EDGE and OUT_SEL. HW sets this field to '0' for edge sensitive triggers AFTER the selected trigger is activated for two clk_peri cycles.

Note: when ACTIVATE is '1', SW should not modify the other register fields.
SW MUST NOT set ACTIVATE bit to '1' while updating the other register bits simultaneously. At first the SW MUST update the other register bits as needed, and then set ACTIVATE to '1' with a new register write.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIV_CMD</name>
          <description>Divider command</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FF03FF</resetValue>
          <resetMask>0xC3FF03FF</resetMask>
          <fields>
            <field>
              <name>DIV_SEL</name>
              <description>(TYPE_SEL, DIV_SEL) specifies the divider on which the command (DISABLE/ENABLE) is performed.
 
If DIV_SEL is '255' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock signal(s) are generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPE_SEL</name>
              <description>Specifies the divider type of the divider on which the command is performed:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PA_DIV_SEL</name>
              <description>(PA_TYPE_SEL, PA_DIV_SEL) specifies the divider to which phase alignment is performed for the clock enable command. Any enabled divider can be used as reference. This allows all dividers to be aligned with each other, even when they are enabled at different times.
 
If PA_DIV_SEL is '255' and PA_TYPE_SEL is '3', 'clk_peri' is used as reference.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PA_TYPE_SEL</name>
              <description>Specifies the divider type of the divider to which phase alignment is performed for the clock enable command:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE</name>
              <description>Clock divider disable command (mutually exclusive with ENABLE). SW sets this field to '1' and HW sets this field to '0'.
 
The DIV_SEL and TYPE_SEL fields specify which divider is to be disabled.
 
The HW sets the DISABLE field to '0' immediately and the HW sets the DIV_XXX_CTL.EN field of the divider to '0' immediately.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Clock divider enable command (mutually exclusive with DISABLE). Typically, SW sets this field to '1' to enable a divider and HW sets this field to '0' to indicate that divider enabling has completed. When a divider is enabled, its integer and fractional (if present) counters are initialized to '0'. If a divider is to be re-enabled using different integer and fractional divider values, the SW should follow these steps:
0: Disable the divider using the DIV_CMD.DISABLE field.
1: Configure the divider's DIV_XXX_CTL register.
2: Enable the divider using the DIV_CMD_ENABLE field.
 
The DIV_SEL and TYPE_SEL fields specify which divider is to be enabled. The enabled divider may be phase aligned to either 'clk_peri' (typical usage) or to ANY enabled divider.
 
The PA_DIV_SEL and PA_TYPE_SEL fields specify the reference divider.
 
The HW sets the ENABLE field to '0' when the enabling is performed and the HW set the DIV_XXX_CTL.EN field of the divider to '1' when the enabling is performed. Note that enabling with phase alignment to a low frequency divider takes time. E.g. To align to a divider that generates a clock of 'clk_peri'/n (with n being the integer divider value INT_DIV+1), up to n cycles may be required to perform alignment. Phase alignment to 'clk_peri' takes affect immediately. SW can set this field to '0' during phase alignment to abort the enabling process.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>256</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLOCK_CTL[%s]</name>
          <description>Clock control</description>
          <addressOffset>0xC00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FF</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>DIV_SEL</name>
              <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
 
If DIV_SEL is '255' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
 
When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '255' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPE_SEL</name>
              <description>Specifies divider type:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>256</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_8_CTL[%s]</name>
          <description>Divider control (for 8.0 divider)</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT8_DIV</name>
              <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
 
For the generation of a divided clock, the integer division range is restricted to [2, 256].
 
For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>256</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_16_CTL[%s]</name>
          <description>Divider control (for 16.0 divider)</description>
          <addressOffset>0x1400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT16_DIV</name>
              <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
 
For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
 
For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>256</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_16_5_CTL[%s]</name>
          <description>Divider control (for 16.5 divider)</description>
          <addressOffset>0x1800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFF9</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAC5_DIV</name>
              <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[7:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT16_DIV</name>
              <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
 
For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
 
For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>255</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_24_5_CTL[%s]</name>
          <description>Divider control (for 24.5 divider)</description>
          <addressOffset>0x1C00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFF9</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAC5_DIV</name>
              <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[7:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT24_DIV</name>
              <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
 
For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
 
For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[31:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x10000</resetValue>
          <resetMask>0xFF0507FF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where the parity is injected.
- On a 32-bit write access to this SRAM address and when ECC_INJ_EN bit is '1', the parity (PARITY) is injected.</description>
              <bitRange>[10:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC checking:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable error injection for PERI protection structure SRAM.
When '1', the parity (PARITY) is used when a write is done to the WORD_ADDR word address of the SRAM.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>7</dim>
          <dimIncrement>32</dimIncrement>
          <name>GR[%s]</name>
          <description>Peripheral group structure</description>
          <addressOffset>0x00004000</addressOffset>
          <register>
            <name>CLOCK_CTL</name>
            <description>Clock control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF00</resetMask>
            <fields>
              <field>
                <name>INT8_DIV</name>
                <description>Specifies a group clock divider (from the peripheral clock 'clk_peri' to the group clock 'clk_group[3/4/5/...15]'). Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. 
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_CTL</name>
            <description>Slave control</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ENABLED_0</name>
                <description>Peripheral group, slave 0 enable. If the slave is disabled, its clock is gated off (constant '0') and its resets are activated.

Note: For peripheral group 0 (the peripheral interconnect MMIO registers), this field is a constant '1' (SW: R): the slave can NOT be disabled.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_1</name>
                <description>Peripheral group, slave 1 enable. If the slave is disabled, its clock is gated off (constant '0') and its resets are activated.

Note: For peripheral group 0 (the peripheral interconnect, master interface MMIO registers), this field is a constant '1' (SW: R): the slave can NOT be disabled.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_2</name>
                <description>N/A</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_3</name>
                <description>N/A</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_4</name>
                <description>N/A</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_5</name>
                <description>N/A</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_7</name>
                <description>N/A</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_8</name>
                <description>N/A</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_9</name>
                <description>N/A</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_10</name>
                <description>N/A</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_11</name>
                <description>N/A</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_12</name>
                <description>N/A</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_13</name>
                <description>N/A</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_14</name>
                <description>N/A</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_15</name>
                <description>N/A</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_0</name>
                <description>Peripheral group, slave 0 permanent disable. Setting this bit to 1 has the same effect as setting ENABLED_0 to 0.  However, once set to 1, this bit cannot be changed back to 0 anymore.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_1</name>
                <description>N/A</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_2</name>
                <description>N/A</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_3</name>
                <description>N/A</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_4</name>
                <description>N/A</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_5</name>
                <description>N/A</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_6</name>
                <description>N/A</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_7</name>
                <description>N/A</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_8</name>
                <description>N/A</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_9</name>
                <description>N/A</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_10</name>
                <description>N/A</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_11</name>
                <description>N/A</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_12</name>
                <description>N/A</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_13</name>
                <description>N/A</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_14</name>
                <description>N/A</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_15</name>
                <description>N/A</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>13</dim>
          <dimIncrement>1024</dimIncrement>
          <name>TR_GR[%s]</name>
          <description>Trigger group</description>
          <addressOffset>0x00008000</addressOffset>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>TR_CTL[%s]</name>
            <description>Trigger control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x13FF</resetMask>
            <fields>
              <field>
                <name>TR_SEL</name>
                <description>Specifies input trigger. This field is typically set during the setup of a chip use case scenario. Changing this field while activated triggers are present on the input triggers may result in unpredictable behavior. Note that input trigger 0 (default value) is typically connected to a constant signal level of '0', and as a result will not cause HW activation of the output trigger.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_INV</name>
                <description>Specifies if the output trigger is inverted.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_EDGE</name>
                <description>Specifies if the (inverted) output trigger is treated as a level sensitive or edge sensitive  trigger.
'0': level sensitive.
'1': edge sensitive trigger. The (inverted) output trigger duration needs to be at least 2 cycles on the consumer clock. the(inverted) output trigger is synchronized to the consumer clock and a two cycle pulse is generated on the consumer clock.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DBG_FREEZE_EN</name>
                <description>Specifies if the output trigger is blocked in debug mode. When set high tr_dbg_freeze will block the output trigger generation.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>6</dim>
          <dimIncrement>1024</dimIncrement>
          <name>TR_1TO1_GR[%s]</name>
          <description>Trigger 1-to-1 group</description>
          <addressOffset>0x0000C000</addressOffset>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>TR_CTL[%s]</name>
            <description>Trigger control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1301</resetMask>
            <fields>
              <field>
                <name>TR_SEL</name>
                <description>Specifies input trigger:
'0'': constant signal level '0'.
'1': input trigger.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_INV</name>
                <description>Specifies if the output trigger is inverted.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_EDGE</name>
                <description>Specifies if the (inverted) output trigger is treated as a level sensitive or edge sensitive  trigger.
'0': level sensitive.
'1': edge sensitive trigger. The (inverted) output trigger duration needs to be at least 2 cycles on the consumer clock. the(inverted) output trigger is synchronized to the consumer clock and a two cycle pulse is generated on the consumer clock.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DBG_FREEZE_EN</name>
                <description>Specifies if the output trigger is blocked in debug mode. When set high tr_dbg_freeze will block the output trigger generation.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>PERI_MS</name>
      <description>Peripheral interconnect, master interface</description>
      <baseAddress>0x40010000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>8</dim>
          <dimIncrement>64</dimIncrement>
          <name>PPU_PR[%s]</name>
          <description>Programmable protection structure pair</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>SL_ADDR</name>
            <description>Slave region, base address</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR30</name>
                <description>This field specifies the base address of the slave region. The region size is defined by SL_SIZE.REGION_SIZE. A region of n Bytes must be n Byte aligned. Therefore, some of the lesser significant address bits of ADDR30 must be '0's. E.g., a 64 KB address region (REGION_SIZE is '15') must be 64 KByte aligned, and ADDR30[13:0] must be '0's.</description>
                <bitRange>[31:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_SIZE</name>
            <description>Slave region, size</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>REGION_SIZE</name>
                <description>This field specifies the size of the slave region:
'0': Undefined.
'1': 4 B region (this is the smallest region size).
'2': 8 B region
'3': 16 B region
'4': 32 B region
'5': 64 B region
'6': 128 B region
'7': 256 B region
'8': 512 B region
'9': 1 KB region
'10': 2 KB region
'11': 4 KB region
'12': 8 KB region
'13': 16 KB region
'14': 32 KB region
'15': 64 KB region
'16': 128 KB region
'17': 256 KB region
'18': 512 KB region
'19': 1 MB region
'20': 2 MB region
'21': 4 MB region
'22': 8 MB region
'23': 16 MB region
'24': 32 MB region
'25': 64 MB region
'26': 128 MB region
'27': 256 MB region
'28': 512 MB region
'29': 1 GB region
'30': 2 GB region
'31': 4 GB region</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Slave region enable:
'0': Disabled. A disabled region will never result in a match on the transfer address.
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT0</name>
            <description>Slave attributes 0</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC0_UR</name>
                <description>Protection context 0, user read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_UW</name>
                <description>Protection context 0, user write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PR</name>
                <description>Protection context 0, privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PW</name>
                <description>Protection context 0, privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_NS</name>
                <description>Protection context 0, non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UR</name>
                <description>Protection context 1, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_UW</name>
                <description>Protection context 1, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PR</name>
                <description>Protection context 1, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PW</name>
                <description>Protection context 1, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_NS</name>
                <description>Protection context 1, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UR</name>
                <description>Protection context 2, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UW</name>
                <description>Protection context 2, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PR</name>
                <description>Protection context 2, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PW</name>
                <description>Protection context 2, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_NS</name>
                <description>Protection context 2, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UR</name>
                <description>Protection context 3, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UW</name>
                <description>Protection context 3, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PR</name>
                <description>Protection context 3, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PW</name>
                <description>Protection context 3, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_NS</name>
                <description>Protection context 3, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT1</name>
            <description>Slave attributes 1</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC4_UR</name>
                <description>Protection context 4, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_UW</name>
                <description>Protection context 4, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PR</name>
                <description>Protection context 4, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PW</name>
                <description>Protection context 4, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_NS</name>
                <description>Protection context 4, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UR</name>
                <description>Protection context 5, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UW</name>
                <description>Protection context 5, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PR</name>
                <description>Protection context 5, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PW</name>
                <description>Protection context 5, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_NS</name>
                <description>Protection context 5, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UR</name>
                <description>Protection context 6, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UW</name>
                <description>Protection context 6, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PR</name>
                <description>Protection context 6, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PW</name>
                <description>Protection context 6, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_NS</name>
                <description>Protection context 6, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UR</name>
                <description>Protection context 7, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UW</name>
                <description>Protection context 7, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PR</name>
                <description>Protection context 7, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PW</name>
                <description>Protection context 7, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_NS</name>
                <description>Protection context 7, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT2</name>
            <description>Slave attributes 2</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC8_UR</name>
                <description>Protection context 8, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_UW</name>
                <description>Protection context 8, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PR</name>
                <description>Protection context 8, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PW</name>
                <description>Protection context 8, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_NS</name>
                <description>Protection context 8, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UR</name>
                <description>Protection context 9, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UW</name>
                <description>Protection context 9, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PR</name>
                <description>Protection context 9, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PW</name>
                <description>Protection context 9, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_NS</name>
                <description>Protection context 9, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UR</name>
                <description>Protection context 10, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UW</name>
                <description>Protection context 10, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PR</name>
                <description>Protection context 10, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PW</name>
                <description>Protection context 10, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_NS</name>
                <description>Protection context 10, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UR</name>
                <description>Protection context 11, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UW</name>
                <description>Protection context 11, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PR</name>
                <description>Protection context 11, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PW</name>
                <description>Protection context 11, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_NS</name>
                <description>Protection context 11, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT3</name>
            <description>Slave attributes 3</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC12_UR</name>
                <description>Protection context 12, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_UW</name>
                <description>Protection context 12, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PR</name>
                <description>Protection context 12, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PW</name>
                <description>Protection context 12, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_NS</name>
                <description>Protection context 12, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UR</name>
                <description>Protection context 13, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UW</name>
                <description>Protection context 13, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PR</name>
                <description>Protection context 13, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PW</name>
                <description>Protection context 13, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_NS</name>
                <description>Protection context 13, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UR</name>
                <description>Protection context 14, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UW</name>
                <description>Protection context 14, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PR</name>
                <description>Protection context 14, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PW</name>
                <description>Protection context 14, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_NS</name>
                <description>Protection context 14, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UR</name>
                <description>Protection context 15, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UW</name>
                <description>Protection context 15, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PR</name>
                <description>Protection context 15, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PW</name>
                <description>Protection context 15, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_NS</name>
                <description>Protection context 15, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ADDR</name>
            <description>Master region, base address</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFC0</resetMask>
            <fields>
              <field>
                <name>ADDR26</name>
                <description>This field specifies the base address of the master region. The base address of the region is the address of the SL_ADDR register.</description>
                <bitRange>[31:6]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_SIZE</name>
            <description>Master region, size</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x85000000</resetValue>
            <resetMask>0x9F000000</resetMask>
            <fields>
              <field>
                <name>REGION_SIZE</name>
                <description>This field specifies the size of the master region:
'5': 64 B region

The master region includes the SL_ADDR, SL_SIZE, SL_ATT0, ..., SL_ATT3, MS_ADDR, MS_SIZE, MS_ATT0, ..., MS_ATT3 registers. Therefore, the access privileges for all these registers is determined by MS_ATT0, ..., MS_ATT3.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Master region enable:
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT0</name>
            <description>Master attributes 0</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC0_UR</name>
                <description>Protection context 0, user read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_UW</name>
                <description>Protection context 0, user write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PR</name>
                <description>Protection context 0, privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PW</name>
                <description>Protection context 0, privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_NS</name>
                <description>Protection context 0, non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UR</name>
                <description>Protection context 1, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UW</name>
                <description>Protection context 1, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PR</name>
                <description>Protection context 1, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_PW</name>
                <description>Protection context 1, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_NS</name>
                <description>Protection context 1, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UR</name>
                <description>Protection context 2, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC2_UW</name>
                <description>Protection context 2, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PR</name>
                <description>Protection context 2, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC2_PW</name>
                <description>Protection context 2, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_NS</name>
                <description>Protection context 2, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UR</name>
                <description>Protection context 3, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC3_UW</name>
                <description>Protection context 3, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PR</name>
                <description>Protection context 3, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC3_PW</name>
                <description>Protection context 3, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_NS</name>
                <description>Protection context 3, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT1</name>
            <description>Master attributes 1</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC4_UR</name>
                <description>Protection context 4, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC4_UW</name>
                <description>Protection context 4, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PR</name>
                <description>Protection context 4, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC4_PW</name>
                <description>Protection context 4, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_NS</name>
                <description>Protection context 4, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UR</name>
                <description>Protection context 5, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC5_UW</name>
                <description>Protection context 5, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PR</name>
                <description>Protection context 5, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC5_PW</name>
                <description>Protection context 5, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_NS</name>
                <description>Protection context 5, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UR</name>
                <description>Protection context 6, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC6_UW</name>
                <description>Protection context 6, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PR</name>
                <description>Protection context 6, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC6_PW</name>
                <description>Protection context 6, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_NS</name>
                <description>Protection context 6, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UR</name>
                <description>Protection context 7, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC7_UW</name>
                <description>Protection context 7, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PR</name>
                <description>Protection context 7, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC7_PW</name>
                <description>Protection context 7, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_NS</name>
                <description>Protection context 7, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT2</name>
            <description>Master attributes 2</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC8_UR</name>
                <description>Protection context 8, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC8_UW</name>
                <description>Protection context 8, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PR</name>
                <description>Protection context 8, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC8_PW</name>
                <description>Protection context 8, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_NS</name>
                <description>Protection context 8, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UR</name>
                <description>Protection context 9, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC9_UW</name>
                <description>Protection context 9, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PR</name>
                <description>Protection context 9, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC9_PW</name>
                <description>Protection context 9, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_NS</name>
                <description>Protection context 9, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UR</name>
                <description>Protection context 10, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC10_UW</name>
                <description>Protection context 10, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PR</name>
                <description>Protection context 10, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC10_PW</name>
                <description>Protection context 10, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_NS</name>
                <description>Protection context 10, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UR</name>
                <description>Protection context 11, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC11_UW</name>
                <description>Protection context 11, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PR</name>
                <description>Protection context 11, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC11_PW</name>
                <description>Protection context 11, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_NS</name>
                <description>Protection context 11, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT3</name>
            <description>Master attributes 3</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC12_UR</name>
                <description>Protection context 12, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC12_UW</name>
                <description>Protection context 12, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PR</name>
                <description>Protection context 12, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC12_PW</name>
                <description>Protection context 12, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_NS</name>
                <description>Protection context 12, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UR</name>
                <description>Protection context 13, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC13_UW</name>
                <description>Protection context 13, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PR</name>
                <description>Protection context 13, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC13_PW</name>
                <description>Protection context 13, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_NS</name>
                <description>Protection context 13, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UR</name>
                <description>Protection context 14, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC14_UW</name>
                <description>Protection context 14, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PR</name>
                <description>Protection context 14, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC14_PW</name>
                <description>Protection context 14, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_NS</name>
                <description>Protection context 14, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UR</name>
                <description>Protection context 15, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC15_UW</name>
                <description>Protection context 15, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PR</name>
                <description>Protection context 15, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC15_PW</name>
                <description>Protection context 15, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_NS</name>
                <description>Protection context 15, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>220</dim>
          <dimIncrement>64</dimIncrement>
          <name>PPU_FX[%s]</name>
          <description>Fixed protection structure pair</description>
          <addressOffset>0x00000800</addressOffset>
          <register>
            <name>SL_ADDR</name>
            <description>Slave region, base address</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFC</resetMask>
            <fields>
              <field>
                <name>ADDR30</name>
                <description>This field specifies the base address of the slave region. The region size is defined by SL_SIZE.REGION_SIZE. A region of n Bytes must be n Byte aligned. Therefore, some of the lesser significant address bits of ADDR30 must be '0's. E.g., a 64 KB address region (REGION_SIZE is '15') must be 64 KByte aligned, and ADDR30[13:0] must be '0's.</description>
                <bitRange>[31:2]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_SIZE</name>
            <description>Slave region, size</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x80000000</resetValue>
            <resetMask>0x9F000000</resetMask>
            <fields>
              <field>
                <name>REGION_SIZE</name>
                <description>This field specifies the size of the slave region:
'0': Undefined.
'1': 4 B region (this is the smallest region size).
'2': 8 B region
'3': 16 B region
'4': 32 B region
'5': 64 B region
'6': 128 B region
'7': 256 B region
'8': 512 B region
'9': 1 KB region
'10': 2 KB region
'11': 4 KB region
'12': 8 KB region
'13': 16 KB region
'14': 32 KB region
'15': 64 KB region
'16': 128 KB region
'17': 256 KB region
'18': 512 KB region
'19': 1 MB region
'20': 2 MB region
'21': 4 MB region
'22': 8 MB region
'23': 16 MB region
'24': 32 MB region
'25': 64 MB region
'26': 128 MB region
'27': 256 MB region
'28': 512 MB region
'29': 1 GB region
'30': 2 GB region
'31': 4 GB region</description>
                <bitRange>[28:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Slave region enable:
'0': Disabled. A disabled region will never result in a match on the transfer address.
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT0</name>
            <description>Slave attributes 0</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC0_UR</name>
                <description>Protection context 0, user read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_UW</name>
                <description>Protection context 0, user write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PR</name>
                <description>Protection context 0, privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PW</name>
                <description>Protection context 0, privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_NS</name>
                <description>Protection context 0, non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UR</name>
                <description>Protection context 1, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_UW</name>
                <description>Protection context 1, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PR</name>
                <description>Protection context 1, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PW</name>
                <description>Protection context 1, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_NS</name>
                <description>Protection context 1, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UR</name>
                <description>Protection context 2, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UW</name>
                <description>Protection context 2, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PR</name>
                <description>Protection context 2, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PW</name>
                <description>Protection context 2, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_NS</name>
                <description>Protection context 2, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UR</name>
                <description>Protection context 3, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UW</name>
                <description>Protection context 3, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PR</name>
                <description>Protection context 3, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PW</name>
                <description>Protection context 3, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_NS</name>
                <description>Protection context 3, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT1</name>
            <description>Slave attributes 1</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC4_UR</name>
                <description>Protection context 4, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_UW</name>
                <description>Protection context 4, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PR</name>
                <description>Protection context 4, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PW</name>
                <description>Protection context 4, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_NS</name>
                <description>Protection context 4, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UR</name>
                <description>Protection context 5, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UW</name>
                <description>Protection context 5, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PR</name>
                <description>Protection context 5, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PW</name>
                <description>Protection context 5, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_NS</name>
                <description>Protection context 5, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UR</name>
                <description>Protection context 6, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UW</name>
                <description>Protection context 6, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PR</name>
                <description>Protection context 6, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PW</name>
                <description>Protection context 6, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_NS</name>
                <description>Protection context 6, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UR</name>
                <description>Protection context 7, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UW</name>
                <description>Protection context 7, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PR</name>
                <description>Protection context 7, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PW</name>
                <description>Protection context 7, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_NS</name>
                <description>Protection context 7, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT2</name>
            <description>Slave attributes 2</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC8_UR</name>
                <description>Protection context 8, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_UW</name>
                <description>Protection context 8, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PR</name>
                <description>Protection context 8, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PW</name>
                <description>Protection context 8, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_NS</name>
                <description>Protection context 8, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UR</name>
                <description>Protection context 9, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UW</name>
                <description>Protection context 9, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PR</name>
                <description>Protection context 9, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PW</name>
                <description>Protection context 9, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_NS</name>
                <description>Protection context 9, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UR</name>
                <description>Protection context 10, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UW</name>
                <description>Protection context 10, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PR</name>
                <description>Protection context 10, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PW</name>
                <description>Protection context 10, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_NS</name>
                <description>Protection context 10, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UR</name>
                <description>Protection context 11, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UW</name>
                <description>Protection context 11, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PR</name>
                <description>Protection context 11, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PW</name>
                <description>Protection context 11, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_NS</name>
                <description>Protection context 11, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT3</name>
            <description>Slave attributes 3</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC12_UR</name>
                <description>Protection context 12, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_UW</name>
                <description>Protection context 12, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PR</name>
                <description>Protection context 12, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PW</name>
                <description>Protection context 12, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_NS</name>
                <description>Protection context 12, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UR</name>
                <description>Protection context 13, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UW</name>
                <description>Protection context 13, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PR</name>
                <description>Protection context 13, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PW</name>
                <description>Protection context 13, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_NS</name>
                <description>Protection context 13, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UR</name>
                <description>Protection context 14, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UW</name>
                <description>Protection context 14, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PR</name>
                <description>Protection context 14, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PW</name>
                <description>Protection context 14, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_NS</name>
                <description>Protection context 14, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UR</name>
                <description>Protection context 15, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UW</name>
                <description>Protection context 15, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PR</name>
                <description>Protection context 15, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PW</name>
                <description>Protection context 15, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_NS</name>
                <description>Protection context 15, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ADDR</name>
            <description>Master region, base address</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFC0</resetMask>
            <fields>
              <field>
                <name>ADDR26</name>
                <description>This field specifies the base address of the master region. The base address of the region is the address of the SL_ADDR register.</description>
                <bitRange>[31:6]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_SIZE</name>
            <description>Master region, size</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x85000000</resetValue>
            <resetMask>0x9F000000</resetMask>
            <fields>
              <field>
                <name>REGION_SIZE</name>
                <description>This field specifies the size of the master region:
'5': 64 B region

The master region includes the SL_ADDR, SL_SIZE, SL_ATT0, ..., SL_ATT3, MS_ADDR, MS_SIZE, MS_ATT0, ..., MS_ATT3 registers. Therefore, the access privileges for all these registers is determined by MS_ATT0, ..., MS_ATT3.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Master region enable:
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT0</name>
            <description>Master attributes 0</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC0_UR</name>
                <description>Protection context 0, user read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_UW</name>
                <description>Protection context 0, user write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PR</name>
                <description>Protection context 0, privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PW</name>
                <description>Protection context 0, privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_NS</name>
                <description>Protection context 0, non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UR</name>
                <description>Protection context 1, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UW</name>
                <description>Protection context 1, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PR</name>
                <description>Protection context 1, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_PW</name>
                <description>Protection context 1, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_NS</name>
                <description>Protection context 1, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UR</name>
                <description>Protection context 2, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC2_UW</name>
                <description>Protection context 2, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PR</name>
                <description>Protection context 2, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC2_PW</name>
                <description>Protection context 2, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_NS</name>
                <description>Protection context 2, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UR</name>
                <description>Protection context 3, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC3_UW</name>
                <description>Protection context 3, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PR</name>
                <description>Protection context 3, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC3_PW</name>
                <description>Protection context 3, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_NS</name>
                <description>Protection context 3, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT1</name>
            <description>Master attributes 1</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC4_UR</name>
                <description>Protection context 4, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC4_UW</name>
                <description>Protection context 4, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PR</name>
                <description>Protection context 4, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC4_PW</name>
                <description>Protection context 4, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_NS</name>
                <description>Protection context 4, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UR</name>
                <description>Protection context 5, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC5_UW</name>
                <description>Protection context 5, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PR</name>
                <description>Protection context 5, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC5_PW</name>
                <description>Protection context 5, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_NS</name>
                <description>Protection context 5, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UR</name>
                <description>Protection context 6, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC6_UW</name>
                <description>Protection context 6, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PR</name>
                <description>Protection context 6, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC6_PW</name>
                <description>Protection context 6, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_NS</name>
                <description>Protection context 6, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UR</name>
                <description>Protection context 7, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC7_UW</name>
                <description>Protection context 7, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PR</name>
                <description>Protection context 7, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC7_PW</name>
                <description>Protection context 7, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_NS</name>
                <description>Protection context 7, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT2</name>
            <description>Master attributes 2</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC8_UR</name>
                <description>Protection context 8, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC8_UW</name>
                <description>Protection context 8, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PR</name>
                <description>Protection context 8, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC8_PW</name>
                <description>Protection context 8, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_NS</name>
                <description>Protection context 8, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UR</name>
                <description>Protection context 9, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC9_UW</name>
                <description>Protection context 9, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PR</name>
                <description>Protection context 9, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC9_PW</name>
                <description>Protection context 9, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_NS</name>
                <description>Protection context 9, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UR</name>
                <description>Protection context 10, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC10_UW</name>
                <description>Protection context 10, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PR</name>
                <description>Protection context 10, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC10_PW</name>
                <description>Protection context 10, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_NS</name>
                <description>Protection context 10, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UR</name>
                <description>Protection context 11, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC11_UW</name>
                <description>Protection context 11, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PR</name>
                <description>Protection context 11, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC11_PW</name>
                <description>Protection context 11, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_NS</name>
                <description>Protection context 11, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT3</name>
            <description>Master attributes 3</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC12_UR</name>
                <description>Protection context 12, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC12_UW</name>
                <description>Protection context 12, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PR</name>
                <description>Protection context 12, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC12_PW</name>
                <description>Protection context 12, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_NS</name>
                <description>Protection context 12, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UR</name>
                <description>Protection context 13, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC13_UW</name>
                <description>Protection context 13, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PR</name>
                <description>Protection context 13, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC13_PW</name>
                <description>Protection context 13, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_NS</name>
                <description>Protection context 13, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UR</name>
                <description>Protection context 14, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC14_UW</name>
                <description>Protection context 14, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PR</name>
                <description>Protection context 14, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC14_PW</name>
                <description>Protection context 14, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_NS</name>
                <description>Protection context 14, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UR</name>
                <description>Protection context 15, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC15_UW</name>
                <description>Protection context 15, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PR</name>
                <description>Protection context 15, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC15_PW</name>
                <description>Protection context 15, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_NS</name>
                <description>Protection context 15, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>CRYPTO</name>
      <description>Cryptography component</description>
      <baseAddress>0x40100000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x10002</resetValue>
          <resetMask>0x800300F3</resetMask>
          <fields>
            <field>
              <name>P</name>
              <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the transaction that writes this register; i.e. the access control is inherited from the write transaction and not specified by the transaction write data.

All IP master transactions use the P field for the user/privileged access control ('hprot[1]').</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NS</name>
              <description>Secure/on-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the transaction that writes this register; i.e. the access control is inherited from the write transaction and not specified by the transaction write data.

All IP master transactions use the NS field for the secure/non-secure access control ('hprot[4]').</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PC</name>
              <description>Protection context.

This field is set with the protection context of the transaction that writes this register; i.e. the context is inherited from the write transaction and not specified by the transaction write data.

All IP master transactions use the PC field for the protection context. There is one exception: the LOAD_DEV_KEY instruction IP master transactions are always performed with protection context '0'.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC checking:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable parity injection for SRAM.
When '1', the parity (ECC_CTL.PARITY) is used when a full 32-bit write is done to the ECC_CTL.WORD_ADDR word address of the SRAM.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. All non-retention registers (command and status registers, instruct FIFO, internal component state machines) are reset to their default value when the IP is disabled. All retention registers retain their value when the IP is disabled.
'1': Enabled. When the  IP is enabled, the IP register buffer is set to '0'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM_PWR_CTL</name>
          <description>SRAM power control</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Set power mode for memory buffer SRAM.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>undefined</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM_PWR_DELAY_CTL</name>
          <description>SRAM power delay control</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x96</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>UP</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFE001FFF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where the parity is injected.
- On a 32-bit write access to this SRAM address and when CTL.ECC_INJ_EN bit is '1', the parity (PARITY) is injected.</description>
              <bitRange>[12:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR.</description>
              <bitRange>[31:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ERROR_STATUS0</name>
          <description>Error status 0</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA32</name>
              <description>Specifies error description information.
- For INSTR_OPC_ERROR/ INSTR_CC_ERROR/ INSTR_DEV_KEY_ERROR:
  - Violating instruction (from instruction FIFO).
- For BUS_ERROR:
  - Violating transfer, address.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ERROR_STATUS1</name>
          <description>Error status 1</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>DATA24</name>
              <description>Specifies error description information.
- For BUS_ERROR:
  - Violating transfer, read attribute (DATA[0]).
  - Violating transfer, size attribute (DATA[5:4]). '0': 8-bit transfer, '1': 16 bits transfer, '2': 32-bit transfer.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDX</name>
              <description>Error source:
'0': INSTR_OPC_ERROR (instruction FIFO decoder error).
'1': INSTR_CC_ERROR (instruction FIFO decoder, VU CC error).
'2': BUS_ERROR (bus master interface AHB-Lite bus error).
'3': TR_AP_DETECT_ERROR.
'4': TR_RC_DETECT_ERROR.
'5': INSTR_DEV_KEY_ERROR.
'6'-'7': Undefined.</description>
              <bitRange>[26:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VALID</name>
              <description>Specifies if ERROR_STATUS0 and ERROR_STATUS1 specify valid error information. No new error information is captured as long as VALID is '1'; i.e. the error information of the first detected error is NOT overwritten.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F001F</resetMask>
          <fields>
            <field>
              <name>INSTR_FF_LEVEL</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the instruction FIFO event is activated.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_FF_OVERFLOW</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the instruction FIFO overflows (an attempt is made to write to a full FIFO).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_INITIALIZED</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the true random number generator is initialized.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_DATA_AVAILABLE</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the true random number generator has generated a data value of the specified bit size.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PR_DATA_AVAILABLE</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the pseudo random number generator has generated a data value.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_OPC_ERROR</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the instruction decoder encounters an instruction with a non-defined operation code (opcode). 

When the interrupt cause is activated, HW sets INSTR_FF_CTL.CLEAR to '1'.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_CC_ERROR</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the instruction decoder encounters an instruction with a non-defined condition code. This error is only generated for VU instructions. 

When the interrupt cause is activated, HW sets INSTR_FF_CTL.CLEAR to '1'.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_ERROR</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when a AHB-Lite bus error is observed on the AHB-Lite master interface. 

When the interrupt cause is activated, HW sets INSTR_FF_CTL.CLEAR to '1'.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_AP_DETECT_ERROR</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the true random number generator monitor adaptive proportion test detects a repetition of a specific bit value.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_RC_DETECT_ERROR</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the true random number generator monitor adaptive proportion test detects a disproportionate occurrence of a specific bit value.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_DEV_KEY_ERROR</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the LOAD_DEV_KEY instruction tries to load a device key whose DEV_KEY_ADDR_CTL.VALID or DEV_KEY_CTL.ALLOWED is set to '0'.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set register</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F001F</resetMask>
          <fields>
            <field>
              <name>INSTR_FF_LEVEL</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_FF_OVERFLOW</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_INITIALIZED</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_DATA_AVAILABLE</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PR_DATA_AVAILABLE</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_OPC_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_CC_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_AP_DETECT_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_RC_DETECT_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_DEV_KEY_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F001F</resetMask>
          <fields>
            <field>
              <name>INSTR_FF_LEVEL</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_FF_OVERFLOW</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_INITIALIZED</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_DATA_AVAILABLE</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PR_DATA_AVAILABLE</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_OPC_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_CC_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_AP_DETECT_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_RC_DETECT_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_DEV_KEY_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked register</description>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F001F</resetMask>
          <fields>
            <field>
              <name>INSTR_FF_LEVEL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INSTR_FF_OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TR_INITIALIZED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TR_DATA_AVAILABLE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PR_DATA_AVAILABLE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INSTR_OPC_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INSTR_CC_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TR_AP_DETECT_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TR_RC_DETECT_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INSTR_DEV_KEY_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PR_LFSR_CTL0</name>
          <description>Pseudo random LFSR control 0</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xD8959BC9</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LFSR32</name>
              <description>State of a 32-bit Linear Feedback Shift Registers (LFSR) that is used to generate a pseudo random bit sequence. This register needs to be initialized by SW. The initialization value should be different from '0'.

The three PR_LFSR_CTL registers represents the state of a 32-bit, 31-bit and 29-bit LFSR. Individually, these LFSRs generate a pseudo random bit sequence that repeats itself after (2^32)-1, (2^31)-1 and (2^29)-1 bits. The numbers (2^32)-1, (2^31)-1 and (2^29)-1 are relatively prime (their greatest common denominator is '1'). The three bit sequence are combined (XOR'd) into a single bitstream to create a pseudo random bit sequence that repeats itself after ((2^32)-1) * ((2^31)-1) * ((2*29)-1) bits.

The following polynomials are used:
- 32-bit irreducible polynomial: x^32+x^30+x^26+x^25+1.
- 31-bit irreducible polynomial: x^31+x^28+1.
- 29-bit irreducible polynomial: x^29+x^27+1.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PR_LFSR_CTL1</name>
          <description>Pseudo random LFSR control 1</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2BB911F8</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>LFSR31</name>
              <description>State of a 31-bit Linear Feedback Shift Registers (LFSR) that is used to generate a pseudo random bit sequence. See PR_LFSR_CTL0.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PR_LFSR_CTL2</name>
          <description>Pseudo random LFSR control 2</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x60C31B7</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>LFSR29</name>
              <description>State of a 29-bit Linear Feedback Shift Registers (LFSR) that is used to generate a pseudo random bit sequence. See PR_LFSR_CTL0.</description>
              <bitRange>[28:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PR_MAX_CTL</name>
          <description>Pseudo random maximum control</description>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA32</name>
              <description>Maximum value of to be generated random number</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PR_CMD</name>
          <description>Pseudo random command</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>START</name>
              <description>Pseudo random command. On a generated number, HW sets this field to '0' and sets INTR.PR_DATA_AVAILABLE to '1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PR_RESULT</name>
          <description>Pseudo random result</description>
          <addressOffset>0x218</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA32</name>
              <description>Result of a pseudo random number generation operation. The resulting value DATA is in the range [0, PR_MAX_CTL.DATA32]. The PR_DATA_AVAILABLE interrupt cause is activated when the number is generated.

Note that SW can write this field. This functionality can be used prevent information leakage.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CTL0</name>
          <description>True random control 0</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30000</resetValue>
          <resetMask>0x31FFFFFF</resetMask>
          <fields>
            <field>
              <name>SAMPLE_CLOCK_DIV</name>
              <description>Specifies the clock divider that is used to sample oscillator data. This clock divider is wrt. 'clk_sys'.
'0': sample clock is 'clk_sys'.
'1': sample clock is 'clk_sys'/2.
...
'255': sample clock is 'clk_sys'/256.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RED_CLOCK_DIV</name>
              <description>Specifies the clock divider that is used to produce reduced bits. 
'0': 1 reduced bit is produced for each sample.
'1': 1 reduced bit is produced for each 2 samples.
...
'255': 1 reduced bit is produced for each 256 samples.

The reduced bits are considered random bits and shifted into TR_RESULT0.DATA32.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT_DELAY</name>
              <description>Specifies an initialization delay: number of removed/dropped samples before reduced bits are generated. This field should be programmed in the range [1, 255]. After starting the oscillators, at least the first 2 samples should be removed/dropped to clear the state of internal synchronizers. In addition, it is advised to drop at least the second 2 samples from the oscillators (to circumvent the semi-predictable oscillator startup behavior). This result in the default field value of '3'. Field encoding is as follows:
'0': 1 sample is dropped.
'1': 2 samples are dropped.
...
'255': 256 samples are dropped.

The TR_INITIALIZED interrupt cause is set to '1', when the initialization delay is passed.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VON_NEUMANN_CORR</name>
              <description>Specifies if the 'von Neumann corrector' is disabled or enabled:
'0': disabled.
'1': enabled.
The 'von Neumann corrector' post-processes the reduced bits to remove a '0' or '1' bias. The corrector operates on reduced bit pairs ('oldest bit, newest bit'):
'00': no bit is produced.
'01': '0' bit is produced (oldest bit).
'10': '1' bit is produced (oldest bit).
'11': no bit is produced.
Note that the corrector produces bits at a random pace and at a frequency that is 1/4 of the reduced bit frequency (reduced bits are processed in pairs, and half of the pairs do NOT produce a bit).</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP_ON_AP_DETECT</name>
              <description>Specifies if TRNG functionality is stopped on an adaptive proportion test detection (when HW sets INTR.TR_AP_DETECT to '1'):
'0': Functionality is NOT stopped.
'1': Functionality is stopped (TR_CTL1 fields are set to '0' by HW).</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP_ON_RC_DETECT</name>
              <description>Specifies if TRNG functionality is stopped on a repetition count test detection (when HW sets INTR.TR_RC_DETECT to '1'):
'0': Functionality is NOT stopped.
'1': Functionality is stopped (TR_CTL1 fields are set to '0' by HW).</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CTL1</name>
          <description>True random control 1</description>
          <addressOffset>0x284</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>RO11_EN</name>
              <description>FW sets this field to '1' to enable the ring oscillator with 11 inverters.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RO15_EN</name>
              <description>FW sets this field to '1' to enable the ring oscillator with 15 inverters.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GARO15_EN</name>
              <description>FW sets this field to '1' to enable the fixed Galois ring oscillator with 15 inverters.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GARO31_EN</name>
              <description>FW sets this field to '1' to enable the programmable Galois ring oscillator with up to 31 inverters. The TR_GARO_CTL register specifies the programmable polynomial.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIRO15_EN</name>
              <description>FW sets this field to '1' to enable the fixed Fibonacci ring oscillator with 15 inverters.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIRO31_EN</name>
              <description>FW sets this field to '1' to enable the programmable Fibonacci ring oscillator with up to 31 inverters. The TR_FIRO_CTL register specifies the programmable polynomial.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CTL2</name>
          <description>True random control 2</description>
          <addressOffset>0x288</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>SIZE</name>
              <description>Bit size of generated random number in TR_RESULT. Legal range is in [0, 32].</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_STATUS</name>
          <description>True random status</description>
          <addressOffset>0x28C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>INITIALIZED</name>
              <description>Reflects the state of the true random number generator:
'0': Not initialized (TR_CTL0.INIT_DELAY has NOT passed).
'1': Initialized (TR_CTL0.INIT_DELAY has passed).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CMD</name>
          <description>True random command</description>
          <addressOffset>0x290</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>START</name>
              <description>True random command. On completion of the command, HW sets this field to '0' and sets INTR.TR_DATA_AVAILABLE to '1 when:
- A random number is generated in TR_RESULT.
- All ring oscillators are off (per TR_CTL1).
- A repetition count (RC) or adaptive proportion (AP) error is detected during the random number generation (INTR.TR_RC/AP_DETECT_ERROR). 

Note: On completion of the command, SW should check TR_CTL1 and INTR.TR_RC/AP_DETECT_ERROR to ensure that no unexpected error occurred during random number generation.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_RESULT</name>
          <description>True random result</description>
          <addressOffset>0x298</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA32</name>
              <description>Generated true random number. HW generates the number in the least significant bit positions (TR_CTL2.SIZE) of this field. The TR_DATA_AVAILABLE interrupt cause is activated when the number is generated.

Note that SW can write this field. This functionality can be used prevent information leakage.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_GARO_CTL</name>
          <description>True random GARO control</description>
          <addressOffset>0x2A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>POLYNOMIAL31</name>
              <description>Polynomial for programmable Galois ring oscillator. The polynomial is represented WITHOUT the high order bit (this bit is always assumed '1'). The polynomial should be aligned such that the more significant bits (bit 30 and down) contain the polynomial and the less significant bits (bit 0 and up) contain padding '0's.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_FIRO_CTL</name>
          <description>True random FIRO control</description>
          <addressOffset>0x2A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>POLYNOMIAL31</name>
              <description>Polynomial for programmable Fibonacci ring oscillator. The polynomial is represented WITHOUT the high order bit (this bit is always assumed '1'). The polynomial should be aligned such that the more significant bits (bit 30 and down) contain the polynomial and the less significant bits (bit 0 and up) contain padding '0's.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_MON_CTL</name>
          <description>True random monitor control</description>
          <addressOffset>0x2C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>BITSTREAM_SEL</name>
              <description>Selection of the bitstream:
'0': DAS bitstream.
'1': RED bitstream.
'2': TR bitstream.
'3': Undefined.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_MON_CMD</name>
          <description>True random monitor command</description>
          <addressOffset>0x2C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>START_AP</name>
              <description>Adaptive proportion (AP) test enable:
'0': Stopped.
'1': Started.

On a AP detection, HW sets this field to '0' and sets INTR.TR_AP_DETECT to '1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>START_RC</name>
              <description>Repetition count (RC) test enable:
'0': Disabled.
'1': Enabled.

On a RC detection, HW sets this field to '0' and sets INTR.TR_RC_DETECT to '1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_MON_RC_CTL</name>
          <description>True random monitor RC control</description>
          <addressOffset>0x2D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CUTOFF_COUNT8</name>
              <description>Cutoff count (legal range is [1, 255]):
'0': Illegal.
'1': 1 repetition.
...
'255': 255 repetitions.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_MON_RC_STATUS0</name>
          <description>True random monitor RC status 0</description>
          <addressOffset>0x2D8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>BIT</name>
              <description>Current active bit value:
'0': '0'.
'1': '1'.

This field is only valid when TR_MON_RC_STATUS1.REP_COUNT is NOT equal to '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_MON_RC_STATUS1</name>
          <description>True random monitor RC status 1</description>
          <addressOffset>0x2DC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>REP_COUNT</name>
              <description>Number of repetitions of the current active bit counter:
'0': 0 repetitions.
...
'255': 255 repetitions.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_MON_AP_CTL</name>
          <description>True random monitor AP control</description>
          <addressOffset>0x2E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CUTOFF_COUNT16</name>
              <description>Cutoff count (legal range is [1, 65535]).
'0': Illegal.
'1': 1 occurrence.
...
'65535': 65535 occurrences.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WINDOW_SIZE</name>
              <description>Window size (minus 1) :
'0': 1 bit.
...
'65535': 65536 bits.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_MON_AP_STATUS0</name>
          <description>True random monitor AP status 0</description>
          <addressOffset>0x2E8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>BIT</name>
              <description>Current active bit value:
'0': '0'.
'1': '1'.

This field is only valid when TR_MON_AP_STATUS1.OCC_COUNT is NOT equal to '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_MON_AP_STATUS1</name>
          <description>True random monitor AP status 1</description>
          <addressOffset>0x2EC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OCC_COUNT</name>
              <description>Number of occurrences of the current active bit counter:
'0': 0 occurrences
...
'65535': 65535 occurrences</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WINDOW_INDEX</name>
              <description>Counter to keep track of the current index in the window (counts from '0' to TR_MON_AP_CTL.WINDOW_SIZE to '0').</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>BUSY</name>
              <description>Reflects the state of the IP:
'0': Idle/no busy.
'1': Busy:
  - Instruction is pending in the instruction FIFO.
  - Instruction is busy in a IP component (e.g. SHA1, SHA2, SHA3, DES, TDES, AES, CHACHA, ...).
  - Store FIFO is busy.
  - TR or PR command is busy.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INSTR_FF_CTL</name>
          <description>Instruction FIFO control</description>
          <addressOffset>0x1040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20000</resetValue>
          <resetMask>0x30007</resetMask>
          <fields>
            <field>
              <name>EVENT_LEVEL</name>
              <description>Event level. When the number of entries in the instruction FIFO is less than the amount of this field, an event is generated:
- 'event' = INSTR_FF_STATUS.USED &lt; EVENT_LEVEL.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the instruction FIFO is cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.

HW sets this field to '1' on when a INSTR_OPC_ERROR, INSTR_CC_ERROR or BUS_ERROR interrupt cause is activated.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK</name>
              <description>This field specifies the behavior when an instruction is written to a full FIFO (INSTR_FIFO_WR MMIO register):
'0': The write is ignored/dropped and the INTR.INSTR_FF_OVERFLOW interrupt cause is set to '1'.
'1': The write is blocked, resulting in AHB-Lite wait states and the INTR.INSTR_FF_OVERFLOW interrupt cause is set to '1' (this cause may be masked out). The instruction is written to the FIFO as soon as a FIFO entry becomes available. The maximum time is roughly the time of the execution of the slowest/longest instruction. Note that this setting may 'lock up' /stall the CPU. When the CPU is 'locked up'/stalled it can not respond to any system interrupts. As a result, the interrupt latency is increased. Note that this may not be an issue if the associated CPU is only performing cryptography functionality, e.g. the CM0+ during boot time.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INSTR_FF_STATUS</name>
          <description>Instruction FIFO status</description>
          <addressOffset>0x1044</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1000F</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Number of instructions in the instruction FIFO. The value of this field ranges from 0 to 8.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EVENT</name>
              <description>Instruction FIFO  event.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INSTR_FF_WR</name>
          <description>Instruction FIFO write</description>
          <addressOffset>0x1048</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA32</name>
              <description>Instruction or instruction operand data that is written to the instruction FIFO.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LOAD0_FF_STATUS</name>
          <description>Load 0 FIFO status</description>
          <addressOffset>0x10C0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000001F</resetMask>
          <fields>
            <field>
              <name>USED5</name>
              <description>Number of Bytes in the FIFO. The value of this field is in the range [0, 19].</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>Reflects the state of the FIFO:
'0': FIFO load engine is idle and a new FIFO instruction can be accepted.
'1': FIFO load engine is busy and NO new FIFO instruction can be accepted.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LOAD1_FF_STATUS</name>
          <description>Load 1 FIFO status</description>
          <addressOffset>0x10D0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000001F</resetMask>
          <fields>
            <field>
              <name>USED5</name>
              <description>See LOAD1_FF_STATUS.USED.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>See LOAD1_FF_STATUS.BUSY.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STORE_FF_STATUS</name>
          <description>Store FIFO status</description>
          <addressOffset>0x10F0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000001F</resetMask>
          <fields>
            <field>
              <name>USED5</name>
              <description>Number of Bytes in the FIFO. The value of this field is in the range [0, 16].</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>Reflects the state of the FIFO:
'0': FIFO store engine is idle and a new FIFO instruction can be accepted (USED is '0').
'1': FIFO store engine is busy and NO new FIFO instruction can be accepted.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_CTL</name>
          <description>AES control</description>
          <addressOffset>0x1100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>KEY_SIZE</name>
              <description>AES key size:
'0': 128-bit key, 10 rounds AES (inverse) cipher operation. 
'1': 192-bit key, 12 rounds AES (inverse) cipher operation. 
'2': 256-bit key, 14 rounds AES (inverse) cipher operation. 
'3': Undefined</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AES128</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AES192</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AES256</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RESULT</name>
          <description>Result</description>
          <addressOffset>0x1180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>BLOCK_CMP operation (DATA[0]):
'0': source 0 equals source 1.
'1': source 0 does NOT equal source 1.

CRC operation (DATA[31:0]). State of a 32-bit Linear Feedback Shift Registers (LFSR) that is used to implement CRC. This register needs to be initialized by SW to provide the CRC seed value.

The seed value should be aligned such that the more significant bits (bit 31 and down) contain the seed value and the less significant bits (bit 0 and up) contain padding '0's.  

Note that SW can write this field. This functionality can be used prevent information leakage.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_CTL</name>
          <description>CRC control</description>
          <addressOffset>0x1400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x101</resetMask>
          <fields>
            <field>
              <name>DATA_REVERSE</name>
              <description>Specifies the bit order in which a data Byte is processed (reversal is performed after XORing):
'0': Most significant bit (bit 1) first.
'1': Least significant bit (bit 0) first.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REM_REVERSE</name>
              <description>Specifies whether the remainder is bit reversed (reversal is performed after XORing):
'0': No.
'1': Yes.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_DATA_CTL</name>
          <description>CRC data control</description>
          <addressOffset>0x1410</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA_XOR</name>
              <description>Specifies a byte mask with which each data byte is XOR'd. The XOR is performed before data reversal.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_POL_CTL</name>
          <description>CRC polynomial control</description>
          <addressOffset>0x1420</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POLYNOMIAL</name>
              <description>CRC polynomial. The polynomial is represented WITHOUT the high order bit (this bit is always assumed '1'). The polynomial should be aligned/shifted such that the more significant bits (bit 31 and down) contain the polynomial and the less significant bits (bit 0 and up) contain padding '0's. Some frequently used polynomials:
- CRC32: POLYNOMIAL is 0x04c11db7 (x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1).
- CRC16: POLYNOMIAL is 0x80050000 (x^16 + x^15 + x^2 + 1, shifted by 16 bit positions).
- CRC16 CCITT: POLYNOMIAL is 0x10210000 (x^16 + x^12 + x^5 + 1, shifted by 16 bit positions).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_REM_CTL</name>
          <description>CRC remainder control</description>
          <addressOffset>0x1440</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REM_XOR</name>
              <description>Specifies a mask with which the CRC_LFSR_CTL.LFSR32 register is XOR'd to produce a remainder. The XOR is performed before remainder reversal.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_REM_RESULT</name>
          <description>CRC remainder result</description>
          <addressOffset>0x1448</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REM</name>
              <description>Remainder value. The alignment of the remainder depends on CRC_REM_CTL0.REM_REVERSE: 
'0': the more significant bits (bit 31 and down) contain the remainder.
'1': the less significant bits (bit 0 and up) contain the remainder. 

Note: This field is combinatorially derived from CRC_LFSR_CTL.LFSR32, CRC_REM_CTL0.REM_REVERSE and CRC_REM_CTL1.REM_XOR.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VU_CTL0</name>
          <description>Vector unit control 0</description>
          <addressOffset>0x1480</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>ALWAYS_EXECUTE</name>
              <description>Specifies if a conditional instruction is executed or not, when its condition code evaluates to false/'0'.
'0': The instruction is NOT executed. As a result, the instruction may be handled faster than when it is executed.
'1': The instruction is executed, but the execution result (including status field information) is not reflected in the IP. The instruction is handled just as fast as when it is executed.

Note: a conditional instruction with a condition code that evaluates to false/'0' does not affect the architectural state: VU_STATUS fields, memory or register-file data.

Note: Always execution is useful to prevent/complicate differential timing and differential power attacks.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VU_CTL1</name>
          <description>Vector unit control 1</description>
          <addressOffset>0x1484</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>ADDR24</name>
              <description>Specifies the memory address for the vector unit operand memory region. The register-file registers provide 13-bit word offsets within this memory region. Given ADDR[31:8], VU_VTL2.MASK[14:8] and a 13-bit word offset offset[14:2], a vector operand memory address VU_OPERAND_ADDR[31:0] is calculated as follows:
- VU_OPERAND_ADDR[31:15] = ADDR[31:15]
- VU_OPERAND_ADDR[14:8] = (ADDR[14:8] &amp; MASK[14:8]) | (offset[14:8] &amp; ~MASK[14:8])
- VU_OPERAND_ADDR[7:2] = offset[7:2]
- VU_OPERAND_ADDR[1:0] = 0 (always word aligned)

The vector unit operand memory region uses either the IP's memory buffer or system memory. For best performance, the IP's memory buffer should be used and ADDR should be set to MEM_BUFF and MASK should specify the IP memory buffer size. 

If a vector operand memory address is mapped on a memory hole, read accesses return a '0' and write accesses are ignored.

Note: The base address of the IP internal memory buffer is equal to IP_ADDR + MEM_BUFF where.
- IP_ADDR is the top-level design time parameter.
- MEM_BUFF is address offset value for MEM_BUFF MMIO register.</description>
              <bitRange>[31:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VU_CTL2</name>
          <description>Vector unit control 2</description>
          <addressOffset>0x1488</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x7F00</resetValue>
          <resetMask>0x7F00</resetMask>
          <fields>
            <field>
              <name>MASK</name>
              <description>Specifies the size of  the vector operand memory region. Legal values:
'0b0000000': 32 KB memory region (VU_VTL1.ADDR[14:8] ignored).
'0b1000000': 16 KB memory region (VU_VTL1.ADDR[13:8] ignored).
'0b1100000': 8 KB memory region (VU_VTL1.ADDR[12:8] ignored).
'0b1110000': 4 KB memory region (VU_VTL1.ADDR[11:8] ignored).
'0b1111000': 2 KB memory region (VU_VTL1.ADDR[10:8] ignored).
'0b1111100': 1 KB memory region (VU_VTL1.ADDR[9:8] ignored).
'0b1111110': 512 B memory region (VU_VTL1.ADDR[8] ignored).
'0b1111111': 256 B memory region.

Note: the default specifies a 256 B memory region.</description>
              <bitRange>[14:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VU_STATUS</name>
          <description>Vector unit status</description>
          <addressOffset>0x1490</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>CARRY</name>
              <description>STATUS CARRY field.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EVEN</name>
              <description>STATUS EVEN field.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ZERO</name>
              <description>STATUS ZERO field.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ONE</name>
              <description>STATUS ONE field.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>VU_RF_DATA[%s]</name>
          <description>Vector unit register-file</description>
          <addressOffset>0x14C0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA32</name>
              <description>Vector unit register-file data. A register-file register has the following layout:
DATA[28:16]: data (typically used as a word offset in vector unit operand memory).
DATA[12:0]: bit size minus 1.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEV_KEY_ADDR0_CTL</name>
          <description>Device key address 0 control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Specifies if the address in the associated DEV_KEY_ADDR0 is valid:
'0': Address not valid; i.e. no device key specified.
'1': Address valid; i.e. device key specified.

Note: A LOAD_DEV_KEY instruction requires that the device key's valid field is '1'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEV_KEY_ADDR0</name>
          <description>Device key address 0</description>
          <addressOffset>0x2004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR32</name>
              <description>Specifies the memory address of the device key in memory. A LOAD_DEV_KEY instruction uses this address to load a device key from memory into the IP register buffer blocks 4 and 5.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEV_KEY_ADDR1_CTL</name>
          <description>Device key address 1 control</description>
          <addressOffset>0x2020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>See DEV_KEY_ADDR0_CTL.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEV_KEY_ADDR1</name>
          <description>Device key address 1 control</description>
          <addressOffset>0x2024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR32</name>
              <description>See DEV_KEY_ADDR0.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEV_KEY_STATUS</name>
          <description>Device key status</description>
          <addressOffset>0x2080</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>LOADED</name>
              <description>Specifies if a device key is present in the IP register buffer blocks 4 and 5.

HW sets this field to '1' on successful completion of a LOAD_DEV_KEY instruction.
HW clears this field to '0' when a CLEAR instruction is executed (the CLEAR instruction also sets the IP register buffer to '0').</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEV_KEY_CTL0</name>
          <description>Device key control 0</description>
          <addressOffset>0x2100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>ALLOWED</name>
              <description>Specifies if a LOAD_DEV_KEY instruction is allowed to use the device key in memory:
'0': Not allowed.
'1': Allowed.

Note: For successful completion of a LOAD_DEV_KEY instruction, both the associated DEV_KEY_ADDR_CTL.VALID and DEV_KEY_CTL.ALLOWED fields must be '1'. On successful instruction completion, DEV_KEY_STATUS.LOADED is set to '1'. On unsuccessful completion, the instruction FIFO is cleared and the IP is locked; an Active reset or an IP reset (CTL.ENABLED), which reinitializes the IP, is required.

Note: A LOAD_DEV_KEY loads the device key from memory with protection context '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEV_KEY_CTL1</name>
          <description>Device key control 1</description>
          <addressOffset>0x2120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>ALLOWED</name>
              <description>See DEV_KEY_CTL0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CPUSS</name>
      <description>CPU subsystem (CPUSS)</description>
      <baseAddress>0x40200000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>ioss_interrupts_gpio_dpslp_0</name>
        <description>GPIO Port Interrupt #0</description>
        <value>0</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_dpslp_1</name>
        <description>GPIO Port Interrupt #1</description>
        <value>1</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_dpslp_4</name>
        <description>GPIO Port Interrupt #4</description>
        <value>2</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_dpslp_5</name>
        <description>GPIO Port Interrupt #5</description>
        <value>3</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_dpslp_6</name>
        <description>GPIO Port Interrupt #6</description>
        <value>4</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_dpslp_7</name>
        <description>GPIO Port Interrupt #7</description>
        <value>5</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_dpslp_8</name>
        <description>GPIO Port Interrupt #8</description>
        <value>6</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_dpslp_9</name>
        <description>GPIO Port Interrupt #9</description>
        <value>7</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_dpslp_10</name>
        <description>GPIO Port Interrupt #10</description>
        <value>8</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_dpslp_11</name>
        <description>GPIO Port Interrupt #11</description>
        <value>9</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_dpslp_12</name>
        <description>GPIO Port Interrupt #12</description>
        <value>10</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_dpslp_13</name>
        <description>GPIO Port Interrupt #13</description>
        <value>11</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupt_gpio_dpslp</name>
        <description>GPIO All Ports</description>
        <value>12</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupt_vdd</name>
        <description>GPIO Supply Detect Interrupt</description>
        <value>13</value>
      </interrupt>
      <interrupt>
        <name>scb_0_interrupt</name>
        <description>Serial Communication Block #6 (DeepSleep capable)</description>
        <value>14</value>
      </interrupt>
      <interrupt>
        <name>srss_interrupt_mcwdt_0</name>
        <description>Multi Counter Watchdog Timer interrupt</description>
        <value>15</value>
      </interrupt>
      <interrupt>
        <name>srss_interrupt_mcwdt_1</name>
        <description>Multi Counter Watchdog Timer interrupt</description>
        <value>16</value>
      </interrupt>
      <interrupt>
        <name>usbhsdev_interrupt_u2d_dpslp_o</name>
        <description>USBHS DEV interuupt</description>
        <value>17</value>
      </interrupt>
      <interrupt>
        <name>srss_interrupt</name>
        <description>Other combined Interrupts for SRSS (LVD, WDT, CLKCAL)</description>
        <value>18</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_0</name>
        <description>CPUSS Inter Process Communication Interrupt #0</description>
        <value>19</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_1</name>
        <description>CPUSS Inter Process Communication Interrupt #1</description>
        <value>20</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_2</name>
        <description>CPUSS Inter Process Communication Interrupt #2</description>
        <value>21</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_3</name>
        <description>CPUSS Inter Process Communication Interrupt #3</description>
        <value>22</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_4</name>
        <description>CPUSS Inter Process Communication Interrupt #4</description>
        <value>23</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_5</name>
        <description>CPUSS Inter Process Communication Interrupt #5</description>
        <value>24</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_6</name>
        <description>CPUSS Inter Process Communication Interrupt #6</description>
        <value>25</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_7</name>
        <description>CPUSS Inter Process Communication Interrupt #7</description>
        <value>26</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_8</name>
        <description>CPUSS Inter Process Communication Interrupt #8</description>
        <value>27</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_9</name>
        <description>CPUSS Inter Process Communication Interrupt #9</description>
        <value>28</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_10</name>
        <description>CPUSS Inter Process Communication Interrupt #10</description>
        <value>29</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_11</name>
        <description>CPUSS Inter Process Communication Interrupt #11</description>
        <value>30</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_12</name>
        <description>CPUSS Inter Process Communication Interrupt #12</description>
        <value>31</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_13</name>
        <description>CPUSS Inter Process Communication Interrupt #13</description>
        <value>32</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_14</name>
        <description>CPUSS Inter Process Communication Interrupt #14</description>
        <value>33</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_15</name>
        <description>CPUSS Inter Process Communication Interrupt #15</description>
        <value>34</value>
      </interrupt>
      <interrupt>
        <name>lvds2usb32ss_usb32_wakeup_int_o</name>
        <description>usb32 deepslp interrupt</description>
        <value>35</value>
      </interrupt>
      <interrupt>
        <name>lvds2usb32ss_lvds_wakeup_int_o</name>
        <description>lvds deepslp interrupt</description>
        <value>36</value>
      </interrupt>
      <interrupt>
        <name>scb_1_interrupt</name>
        <description>Serial Communication Block #1</description>
        <value>46</value>
      </interrupt>
      <interrupt>
        <name>scb_2_interrupt</name>
        <description>Serial Communication Block #2</description>
        <value>47</value>
      </interrupt>
      <interrupt>
        <name>scb_3_interrupt</name>
        <description>Serial Communication Block #3</description>
        <value>48</value>
      </interrupt>
      <interrupt>
        <name>scb_4_interrupt</name>
        <description>Serial Communication Block #4</description>
        <value>49</value>
      </interrupt>
      <interrupt>
        <name>scb_5_interrupt</name>
        <description>Serial Communication Block #5</description>
        <value>50</value>
      </interrupt>
      <interrupt>
        <name>scb_6_interrupt</name>
        <description>Serial Communication Block #6</description>
        <value>51</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dmac_0</name>
        <description>CPUSS DMAC, Channel #0</description>
        <value>52</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dmac_1</name>
        <description>CPUSS DMAC, Channel #1</description>
        <value>53</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dmac_2</name>
        <description>CPUSS DMAC, Channel #2</description>
        <value>54</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dmac_3</name>
        <description>CPUSS DMAC, Channel #3</description>
        <value>55</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dmac_4</name>
        <description>CPUSS DMAC, Channel #4</description>
        <value>56</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dmac_5</name>
        <description>CPUSS DMAC, Channel #5</description>
        <value>57</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_0</name>
        <description>CPUSS DataWire #0, Channel #0</description>
        <value>58</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_1</name>
        <description>CPUSS DataWire #0, Channel #1</description>
        <value>59</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_2</name>
        <description>CPUSS DataWire #0, Channel #2</description>
        <value>60</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_3</name>
        <description>CPUSS DataWire #0, Channel #3</description>
        <value>61</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_4</name>
        <description>CPUSS DataWire #0, Channel #4</description>
        <value>62</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_5</name>
        <description>CPUSS DataWire #0, Channel #5</description>
        <value>63</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_6</name>
        <description>CPUSS DataWire #0, Channel #6</description>
        <value>64</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_7</name>
        <description>CPUSS DataWire #0, Channel #7</description>
        <value>65</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_8</name>
        <description>CPUSS DataWire #0, Channel #8</description>
        <value>66</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_9</name>
        <description>CPUSS DataWire #0, Channel #9</description>
        <value>67</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_10</name>
        <description>CPUSS DataWire #0, Channel #10</description>
        <value>68</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_11</name>
        <description>CPUSS DataWire #0, Channel #11</description>
        <value>69</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_12</name>
        <description>CPUSS DataWire #0, Channel #12</description>
        <value>70</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_13</name>
        <description>CPUSS DataWire #0, Channel #13</description>
        <value>71</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_14</name>
        <description>CPUSS DataWire #0, Channel #14</description>
        <value>72</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_15</name>
        <description>CPUSS DataWire #0, Channel #15</description>
        <value>73</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_16</name>
        <description>CPUSS DataWire #0, Channel #16</description>
        <value>74</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_17</name>
        <description>CPUSS DataWire #0, Channel #17</description>
        <value>75</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_18</name>
        <description>CPUSS DataWire #0, Channel #18</description>
        <value>76</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_19</name>
        <description>CPUSS DataWire #0, Channel #19</description>
        <value>77</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_20</name>
        <description>CPUSS DataWire #0, Channel #20</description>
        <value>78</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_21</name>
        <description>CPUSS DataWire #0, Channel #21</description>
        <value>79</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_22</name>
        <description>CPUSS DataWire #0, Channel #22</description>
        <value>80</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_23</name>
        <description>CPUSS DataWire #0, Channel #23</description>
        <value>81</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_0</name>
        <description>CPUSS DataWire #1, Channel #0</description>
        <value>82</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_1</name>
        <description>CPUSS DataWire #1, Channel #1</description>
        <value>83</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_2</name>
        <description>CPUSS DataWire #1, Channel #2</description>
        <value>84</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_3</name>
        <description>CPUSS DataWire #1, Channel #3</description>
        <value>85</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_4</name>
        <description>CPUSS DataWire #1, Channel #4</description>
        <value>86</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_5</name>
        <description>CPUSS DataWire #1, Channel #5</description>
        <value>87</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_6</name>
        <description>CPUSS DataWire #1, Channel #6</description>
        <value>88</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_7</name>
        <description>CPUSS DataWire #1, Channel #7</description>
        <value>89</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_8</name>
        <description>CPUSS DataWire #1, Channel #8</description>
        <value>90</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_9</name>
        <description>CPUSS DataWire #1, Channel #9</description>
        <value>91</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_10</name>
        <description>CPUSS DataWire #1, Channel #10</description>
        <value>92</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_11</name>
        <description>CPUSS DataWire #1, Channel #11</description>
        <value>93</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_12</name>
        <description>CPUSS DataWire #1, Channel #12</description>
        <value>94</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_13</name>
        <description>CPUSS DataWire #1, Channel #13</description>
        <value>95</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_14</name>
        <description>CPUSS DataWire #1, Channel #14</description>
        <value>96</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_15</name>
        <description>CPUSS DataWire #1, Channel #15</description>
        <value>97</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_16</name>
        <description>CPUSS DataWire #1, Channel #16</description>
        <value>98</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_17</name>
        <description>CPUSS DataWire #1, Channel #17</description>
        <value>99</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_18</name>
        <description>CPUSS DataWire #1, Channel #18</description>
        <value>100</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_19</name>
        <description>CPUSS DataWire #1, Channel #19</description>
        <value>101</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_20</name>
        <description>CPUSS DataWire #1, Channel #20</description>
        <value>102</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_21</name>
        <description>CPUSS DataWire #1, Channel #21</description>
        <value>103</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_22</name>
        <description>CPUSS DataWire #1, Channel #22</description>
        <value>104</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_23</name>
        <description>CPUSS DataWire #1, Channel #23</description>
        <value>105</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_fault_0</name>
        <description>CPUSS Fault Structure Interrupt #0</description>
        <value>106</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_fault_1</name>
        <description>CPUSS Fault Structure Interrupt #1</description>
        <value>107</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_crypto</name>
        <description>CRYPTO Accelerator Interrupt</description>
        <value>108</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_fm</name>
        <description>FLASH Macro Interrupt</description>
        <value>109</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_cm4_fp</name>
        <description>Floating Point operation fault</description>
        <value>110</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_cm0_cti_0</name>
        <description>CM0+ CTI #0</description>
        <value>111</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_cm0_cti_1</name>
        <description>CM0+ CTI #1</description>
        <value>112</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_cm4_cti_0</name>
        <description>CM4 CTI #0</description>
        <value>113</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_cm4_cti_1</name>
        <description>CM4 CTI #1</description>
        <value>114</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_0</name>
        <description>TCPWM #0, Counter #0</description>
        <value>115</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_1</name>
        <description>TCPWM #0, Counter #1</description>
        <value>116</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_2</name>
        <description>TCPWM #0, Counter #2</description>
        <value>117</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_3</name>
        <description>TCPWM #0, Counter #3</description>
        <value>118</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_4</name>
        <description>TCPWM #0, Counter #4</description>
        <value>119</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_5</name>
        <description>TCPWM #0, Counter #5</description>
        <value>120</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_6</name>
        <description>TCPWM #0, Counter #6</description>
        <value>121</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_7</name>
        <description>TCPWM #0, Counter #7</description>
        <value>122</value>
      </interrupt>
      <interrupt>
        <name>tdm_0_interrupts_rx_0</name>
        <description>TDM0 Audio interrupt RX</description>
        <value>123</value>
      </interrupt>
      <interrupt>
        <name>tdm_0_interrupts_tx_0</name>
        <description>TDM0 Audio interrupt TX</description>
        <value>124</value>
      </interrupt>
      <interrupt>
        <name>smif_interrupt</name>
        <description>Serial Memory Interface interrupt</description>
        <value>125</value>
      </interrupt>
      <interrupt>
        <name>usb_interrupt_hi</name>
        <description>USB Interrupt</description>
        <value>126</value>
      </interrupt>
      <interrupt>
        <name>usb_interrupt_med</name>
        <description>USB Interrupt</description>
        <value>127</value>
      </interrupt>
      <interrupt>
        <name>usb_interrupt_lo</name>
        <description>USB Interrupt</description>
        <value>128</value>
      </interrupt>
      <interrupt>
        <name>usbhsdev_interrupt_u2d_active_o</name>
        <description>USB HS dev Interrupt</description>
        <value>129</value>
      </interrupt>
      <interrupt>
        <name>canfd_0_interrupt0</name>
        <description>Can #0, Consolidated interrupt #0</description>
        <value>130</value>
      </interrupt>
      <interrupt>
        <name>canfd_0_interrupts0_0</name>
        <description>CAN #0, Interrupt #0, Channel #0</description>
        <value>131</value>
      </interrupt>
      <interrupt>
        <name>canfd_0_interrupts1_0</name>
        <description>CAN #0, Interrupt #1, Channel #0</description>
        <value>132</value>
      </interrupt>
      <interrupt>
        <name>pdm_0_interrupts_0</name>
        <description>PDM interrupt</description>
        <value>133</value>
      </interrupt>
      <interrupt>
        <name>pdm_0_interrupts_1</name>
        <description>PDM interrupt</description>
        <value>134</value>
      </interrupt>
      <interrupt>
        <name>lvds2usb32ss_lvds_int_o</name>
        <description />
        <value>135</value>
      </interrupt>
      <interrupt>
        <name>lvds2usb32ss_tra_int_o</name>
        <description />
        <value>136</value>
      </interrupt>
      <interrupt>
        <name>lvds2usb32ss_usb32_egrs_dma_int_o</name>
        <description />
        <value>137</value>
      </interrupt>
      <interrupt>
        <name>lvds2usb32ss_usb32_ingrs_dma_int_o</name>
        <description />
        <value>138</value>
      </interrupt>
      <interrupt>
        <name>lvds2usb32ss_usb32_int_o</name>
        <description />
        <value>139</value>
      </interrupt>
      <interrupt>
        <name>lvds2usb32ss_lvds_dma_adap0_int_o</name>
        <description />
        <value>140</value>
      </interrupt>
      <interrupt>
        <name>lvds2usb32ss_lvds_dma_adap1_int_o</name>
        <description />
        <value>141</value>
      </interrupt>
      <registers>
        <register>
          <name>IDENTITY</name>
          <description>Identity</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>P</name>
              <description>This field specifies the privileged setting ('0': user mode; '1': privileged mode) of the transfer that reads the register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NS</name>
              <description>This field specifies the security setting ('0': secure mode; '1': non-secure mode) of the transfer that reads the register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PC</name>
              <description>This field specifies the protection context of the transfer that reads the register.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MS</name>
              <description>This field specifies the bus master identifier of the transfer that reads the register.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_STATUS</name>
          <description>CM4 status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x13</resetValue>
          <resetMask>0x13</resetMask>
          <fields>
            <field>
              <name>SLEEPING</name>
              <description>Specifies if the CPU is in Active, Sleep or DeepSleep power mode:
- Active power mode: SLEEPING is '0'.
- Sleep power mode: SLEEPING is '1' and SLEEPDEEP is '0'.
- DeepSleep power mode: SLEEPING is '1' and SLEEPDEEP is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SLEEPDEEP</name>
              <description>Specifies if the CPU is in Sleep or DeepSleep power mode. See SLEEPING field.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWR_DONE</name>
              <description>After a PWR_MODE change this flag indicates if the new power mode has taken effect or not. 
Note: this flag can also change as a result of  a change in debug power up req</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CLOCK_CTL</name>
          <description>CM4 clock control</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF00</resetMask>
          <fields>
            <field>
              <name>FAST_INT_DIV</name>
              <description>Specifies the fast clock divider (from the high frequency clock 'clk_hf' to the peripheral clock 'clk_fast'). Integer division by (1+FAST_INT_DIV). Allows for integer divisions in the range [1, 256] (FAST_INT_DIV is in the range [0, 255]).
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CTL</name>
          <description>CM4 control</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x9F000000</resetMask>
          <fields>
            <field>
              <name>IOC_MASK</name>
              <description>CPU floating point unit (FPU) exception mask for the CPU's FPCSR.IOC 'invalid operation' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt. 

Note: the ARM architecture does NOT support FPU exceptions; i.e. there is no precise FPU exception handler. Instead, FPU conditions are captured in the CPU's FPCSR register and the conditions are provided as CPU interface signals. The interface signals are 'masked' with the fields a provide by this register (CM7_0_CTL). The 'masked' signals are reduced/OR-ed into a single CPU floating point interrupt signal. The associated CPU interrupt handler allows for imprecise handling of FPU exception conditions.

Note: the CPU's FPCSR exception conditions are 'sticky'. Typically, the CPU FPU interrupt handler will clear the exception condition(s) to '0'.

Note: by default, the FPU exception masks are '0'. Therefore, FPU exception conditions will NOT activate the CPU's floating point interrupt.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DZC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.DZC 'divide by zero' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OFC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.OFC 'overflow' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UFC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.UFC 'underflow' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IXC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.IXC 'inexact' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt.

Note: the 'inexact' condition is set as a result of rounding. Rounding may occur frequently and is typically not an error condition. To prevent frequent CPU FPU interrupts as a result of rounding, this field is typically set to '0'.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.IDC 'input denormalized' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt. 

Note: if the CPU FPCSR.FZ field is set to '1', denormalized inputs are 'flushed to zero'. Dependent on the FPU algorithm, this may or may not occur frequently. To prevent frequent CPU FPU interrupts as a result of denormalized inputs, this field may be set to '0'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT0_STATUS</name>
          <description>CM4 interrupt 0 status</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 0.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT1_STATUS</name>
          <description>CM4 interrupt 1 status</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 1.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT2_STATUS</name>
          <description>CM4 interrupt 2 status</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 2.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT3_STATUS</name>
          <description>CM4 interrupt 3 status</description>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 3.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT4_STATUS</name>
          <description>CM4 interrupt 4 status</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 4.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT5_STATUS</name>
          <description>CM4 interrupt 5 status</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 5.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT6_STATUS</name>
          <description>CM4 interrupt 6 status</description>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 6.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT7_STATUS</name>
          <description>CM4 interrupt 7 status</description>
          <addressOffset>0x11C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 7.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_VECTOR_TABLE_BASE</name>
          <description>CM4 vector table base</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFC00</resetMask>
          <fields>
            <field>
              <name>ADDR22</name>
              <description>Address of CM4 vector table. This register is used for CM4 warm and cold boot purposes: the CM0+ CPU initializes the CM4_VECTOR_TABLE_BASE register and the CM4 boot code uses the register to initialize the CM4 internal VTOR register.

Note: the CM4 vector table is at an address that is a 1024 B multiple.</description>
              <bitRange>[31:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM4_NMI_CTL[%s]</name>
          <description>CM4 NMI control</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FF</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>System interrupt select for CPU NMI. The reset value ('1023') ensures that the CPU NMI is NOT connected to any system interrupt after DeepSleep reset.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UDB_PWR_CTL</name>
          <description>UDB power control</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050001</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Set Power mode for UDBs</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UDB_PWR_DELAY_CTL</name>
          <description>UDB power control</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x12C</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>UP</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CTL</name>
          <description>CM0+ control</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050002</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>SLV_STALL</name>
              <description>Processor debug access control:
'0': Access.
'1': Stall access.

This field is used to stall/delay debug accesses. This is useful to protect execution of code that needs to be protected from debug accesses.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Processor enable:
'0': Disabled. Processor clock is turned off and reset is activated. After SW clears this field to '0', HW automatically sets this field to '1'. This effectively results in a CM0+ reset, followed by a CM0+ warm boot.
'1': Enabled.
Note: The intent is that this bit is modified only through an external probe or by the CM4 while the CM0+ is in Sleep or DeepSleep power mode. If this field is cleared to '0' by the CM0+ itself, it should be done under controlled conditions (such that undesirable side effects can be prevented).

Note: The CM0+ CPU has a AIRCR.SYSRESETREQ register field that allows the CM0+ to reset the complete device (ENABLED only disables/enables the CM0+), resulting in a warm boot. This CPU register field has similar 'built-in protection' as this CM0_CTL register to prevent accidental system writes (the upper 16-bits of the register need to be written with a 0x05fa key value; see CPU user manual for more details).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_STATUS</name>
          <description>CM0+ status</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>SLEEPING</name>
              <description>Specifies if the CPU is in Active, Sleep or DeepSleep power mode:
- Active power mode: SLEEPING is '0'.
- Sleep power mode: SLEEPING is '1' and SLEEPDEEP is '0'.
- DeepSleep power mode: SLEEPING is '1' and SLEEPDEEP is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SLEEPDEEP</name>
              <description>Specifies if the CPU is in Sleep or DeepSleep power mode. See SLEEPING field.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CLOCK_CTL</name>
          <description>CM0+ clock control</description>
          <addressOffset>0x1008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF00FF00</resetMask>
          <fields>
            <field>
              <name>SLOW_INT_DIV</name>
              <description>Specifies the slow clock divider (from the peripheral clock 'clk_peri' to the slow clock 'clk_slow'). Integer division by (1+SLOW_INT_DIV). Allows for integer divisions in the range [1, 256] (SLOW_INT_DIV is in the range [0, 255]).
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERI_INT_DIV</name>
              <description>Specifies the peripheral clock divider (from the high frequency clock 'clk_hf' to the peripheral clock 'clk_peri'). Integer division by (1+PERI_INT_DIV). Allows for integer divisions in the range [1, 256] (PERI_INT_DIV is in the range [0, 255]).
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.

Note that Fperi &lt;= Fperi_max. Fperi_max is likely to be smaller than Fhf_max. In other words, if Fhf = Fhf_max, PERI_INT_DIV should not be set to '0'.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT0_STATUS</name>
          <description>CM0+ interrupt 0 status</description>
          <addressOffset>0x1100</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 0.

Multiple system interrupts can be mapped on the same CPU interrupt. The selected system interrupt is the system interrupt with the lowest system interrupt index that has an activated interrupt request at the time of the fetch (system_interrupts[SYSTEM_INT_IDX] is '1'). 

The CPU interrupt handler SW can read SYSTEM_INT_IDX to determine the system interrupt that activated the handler.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>Valid indication for SYSTEM_INT_IDX. When '0', no system interrupt for CPU interrupt 0 is valid/activated.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT1_STATUS</name>
          <description>CM0+ interrupt 1 status</description>
          <addressOffset>0x1104</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 1.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT2_STATUS</name>
          <description>CM0+ interrupt 2 status</description>
          <addressOffset>0x1108</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 2.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT3_STATUS</name>
          <description>CM0+ interrupt 3 status</description>
          <addressOffset>0x110C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 3.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT4_STATUS</name>
          <description>CM0+ interrupt 4 status</description>
          <addressOffset>0x1110</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 4.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT5_STATUS</name>
          <description>CM0+ interrupt 5 status</description>
          <addressOffset>0x1114</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 5.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT6_STATUS</name>
          <description>CM0+ interrupt 6 status</description>
          <addressOffset>0x1118</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 6.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT7_STATUS</name>
          <description>CM0+ interrupt 7 status</description>
          <addressOffset>0x111C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 7.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_VECTOR_TABLE_BASE</name>
          <description>CM0+ vector table base</description>
          <addressOffset>0x1120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>ADDR24</name>
              <description>Address of CM0+ vector table. This register is used for CM0+ warm boot purposes: the CM0+ warm boot code uses the register to initialize the CM0+ internal VTOR register.

Note: the CM0+ vector table is at an address that is a 256 B multiple.</description>
              <bitRange>[31:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM0_NMI_CTL[%s]</name>
          <description>CM0+ NMI control</description>
          <addressOffset>0x1140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FF</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>System interrupt select for CPU NMI. The reset value ('1023') ensures that the CPU NMI is NOT connected to any system interrupt after DeepSleep reset.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_PWR_CTL</name>
          <description>CM4 power control</description>
          <addressOffset>0x1200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050001</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Power mode.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Switch CM4 off
Power off, clock off, isolate, reset and no retain.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>Reset CM4
Clock off, no isolated, no retain and reset.
...</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>Put CM4 in Retained mode
This can only become effective if CM4 is in SleepDeep mode. Check PWR_DONE flag to see if CM4 RETAINED state has been reached.
Power off, clock off, isolate, no reset and retain.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Switch CM4 on.
Power on, clock on, no isolate, no reset and no retain.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_PWR_DELAY_CTL</name>
          <description>CM4 power control</description>
          <addressOffset>0x1204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x12C</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>UP</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM0_CTL0</name>
          <description>RAM 0 control</description>
          <addressOffset>0x1300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30001</resetValue>
          <resetMask>0x70303</resetMask>
          <fields>
            <field>
              <name>SLOW_WS</name>
              <description>Memory wait states for the slow clock domain ('clk_slow'). The number of wait states is expressed in 'clk_hf' clock domain cycles.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_WS</name>
              <description>Memory wait states for the fast clock domain ('clk_fast'). The number of wait states is expressed in 'clk_hf' clock domain cycles.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC checking:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_AUTO_CORRECT</name>
              <description>HW ECC autocorrect functionality:
'0': Disabled.
'1': Enabled. HW automatically writes back SRAM with corrected data when a recoverable ECC error is detected.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable error injection for system SRAM 0.
When '1', the parity (ECC_CTL.PARITY) is used when a full 32-bit write is done to the ECC_CTL.WORD_ADDR word address of system SRAM 0.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM0_STATUS</name>
          <description>RAM 0 status</description>
          <addressOffset>0x1304</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WB_EMPTY</name>
              <description>Write buffer empty. This information is used when entering DeepSleep power mode: WB_EMPTY must be '1' before a transition to system DeepSleep power mode.
'0': Write buffer NOT empty.
'1': Write buffer empty.

Note: the SRAM controller write buffer is only used when ECC checking is enabled. (RAMi_CTL.ECC_EN is '1').</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>RAM0_PWR_MACRO_CTL[%s]</name>
          <description>RAM 0 power control</description>
          <addressOffset>0x1340</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050003</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>SRAM Power mode.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Turn OFF the SRAM. This will trun OFF both array and periphery power of the SRAM and SRAM memory contents are lost.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>undefined</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>Keep SRAM in Retained mode. This will turn OFF the SRAM periphery power, but array power is ON to retain memory contents.
The SRAM contents will be retained in DeepSleep system power mode.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enable SRAM for regular operation. 
The SRAM contents will be retained in DeepSleep system power mode.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_CTL0</name>
          <description>RAM 1 control</description>
          <addressOffset>0x1380</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30001</resetValue>
          <resetMask>0x70303</resetMask>
          <fields>
            <field>
              <name>SLOW_WS</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_WS</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_EN</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_AUTO_CORRECT</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_STATUS</name>
          <description>RAM 1 status</description>
          <addressOffset>0x1384</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WB_EMPTY</name>
              <description>See RAM0_STATUS.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_PWR_CTL</name>
          <description>RAM 1 power control</description>
          <addressOffset>0x1388</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050003</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Power mode.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>See RAM0_PWR_MACRO_CTL.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>undefined</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>See RAM0_PWR_MACRO_CTL.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>See RAM0_PWR_MACRO_CTL.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>See RAM0_PWR_MACRO_CTL.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM2_CTL0</name>
          <description>RAM 2 control</description>
          <addressOffset>0x13A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30001</resetValue>
          <resetMask>0x70303</resetMask>
          <fields>
            <field>
              <name>SLOW_WS</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_WS</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_EN</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_AUTO_CORRECT</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM2_STATUS</name>
          <description>RAM 2 status</description>
          <addressOffset>0x13A4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WB_EMPTY</name>
              <description>See RAM0_STATUS.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM2_PWR_CTL</name>
          <description>RAM 2 power control</description>
          <addressOffset>0x13A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050003</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Power mode.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>See RAM0_PWR_MACRO_CTL.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>undefined</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>See RAM0_PWR_MACRO_CTL.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>See RAM0_PWR_MACRO_CTL.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>See RAM0_PWR_MACRO_CTL.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM_PWR_DELAY_CTL</name>
          <description>Power up delay used for all SRAM power domains</description>
          <addressOffset>0x13C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x96</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>UP</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ROM_CTL</name>
          <description>ROM control</description>
          <addressOffset>0x13C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x303</resetMask>
          <fields>
            <field>
              <name>SLOW_WS</name>
              <description>Memory wait states for the slow clock domain ('clk_slow'). The number of wait states is expressed in 'clk_hf' clock domain cycles.

Timing paths to and from the memory have a (fixed) minimum duration  that always needs to be considered/met. The 'clk_hf' clock domain frequency determines this field's value such that the timing paths minimum duration is met. A table/formula will be provided for this field's values for different 'clk_hf' frequencies.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_WS</name>
              <description>Memory wait states for the fast clock domain ('clk_fast'). The number of wait states is expressed in 'clk_hf' clock domain cycles.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x13C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where an error will be injected.
- On a write transfer to this SRAM address and when the corresponding RAM0/RAM1/RAM2_CTL0.ECC_INJ_EN bit is '1', the parity (PARITY) is injected.
This field needs to be written with the offset address within the memory, divided by 4.
For example, if the RAM1 start address is 0x08010000, and an error is to be injected to address 0x08010040, then this field needs to configured to 0x000010.</description>
              <bitRange>[24:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR.</description>
              <bitRange>[31:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRODUCT_ID</name>
          <description>Product identifier and version (same as CoreSight RomTables)</description>
          <addressOffset>0x1400</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FAMILY_ID</name>
              <description>Family ID a.k.a. Partnumber a.k.a. Silicon ID</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAJOR_REV</name>
              <description>Major Revision, starts with 1, increments with all layer tape-out (implemented with metal ECO-able  tie-off)</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MINOR_REV</name>
              <description>Minor Revision, starts with 1, increments with metal layer only tape-out (implemented with metal ECO-able  tie-off)</description>
              <bitRange>[23:20]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DP_STATUS</name>
          <description>Debug port status</description>
          <addressOffset>0x1410</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x4</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>SWJ_CONNECTED</name>
              <description>Specifies if the SWJ debug port is connected; i.e. debug host interface is active:
'0': Not connected/not active.
'1': Connected/active.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SWJ_DEBUG_EN</name>
              <description>Specifies if SWJ debug is enabled, i.e. CDBGPWRUPACK is '1' and thus debug clocks are on:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SWJ_JTAG_SEL</name>
              <description>Specifies if the JTAG or SWD interface is selected. This signal is valid when DP_CTL.PTM_SEL is '0' (SWJ mode selected) and SWJ_CONNECTED is '1' (SWJ is connected).
'0': SWD selected.
'1': JTAG selected.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AP_CTL</name>
          <description>Access port control</description>
          <addressOffset>0x1414</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x70007</resetMask>
          <fields>
            <field>
              <name>CM0_ENABLE</name>
              <description>Enables the CM0 AP interface:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM4_ENABLE</name>
              <description>Enables the CM4 AP interface:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SYS_ENABLE</name>
              <description>Enables the system AP interface:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM0_DISABLE</name>
              <description>Disables the CM0 AP interface:
'0': Enabled.
'1': Disabled.

Typically, this field is set by the Cypress boot code with information from eFUSE. The access port is only enabled when CM0_DISABLE is '0' and CM0_ENABLE is '1'.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM4_DISABLE</name>
              <description>Disables the CM4 AP interface:
'0': Enabled.
'1': Disabled.

Typically, this field is set by the Cypress boot code with information from eFUSE. The access port is only enabled when CM4_DISABLE is '0' and CM4_ENABLE is '1'.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SYS_DISABLE</name>
              <description>Disables the system AP interface:
'0': Enabled.
'1': Disabled.

Typically, this field is set by the Cypress boot code with information from eFUSE. The access port is only enabled when SYS_DISABLE is '0' and SYS_ENABLE is '1'.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BUFF_CTL</name>
          <description>Buffer control</description>
          <addressOffset>0x1500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WRITE_BUFF</name>
              <description>Specifies if write transfer can be buffered in the bus infrastructure bridges:
'0': Write transfers are not buffered, independent of the transfer's bufferable attribute.
'1': Write transfers can be buffered, if the transfer's bufferable attribute indicates that the transfer is a bufferable/posted write.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSTICK_CTL</name>
          <description>SysTick timer control</description>
          <addressOffset>0x1600</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000147</resetValue>
          <resetMask>0xC3FFFFFF</resetMask>
          <fields>
            <field>
              <name>TENMS</name>
              <description>Specifies the number of clock source cycles (minus 1) that make up 10 ms. E.g., for a 32,768 Hz reference clock, TENMS is 328 - 1 = 327.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLOCK_SOURCE</name>
              <description>Specifies an external clock source:
'0': The low frequency clock 'clk_lf' is selected. The precision of this clock depends on whether the low frequency clock source is a SRSS internal RC oscillator (imprecise) or a device external crystal oscillator (precise).
'1': The internal main oscillator (IMO) clock 'clk_imo' is selected. The MXS40 platform uses a fixed frequency IMO clock.
o '2': The external crystal oscillator (ECO) clock 'clk_eco' is selected.
'3': The SRSS 'clk_timer' is selected ('clk_timer' is a divided/gated version of 'clk_hf' or 'clk_imo').

Note: If NOREF is '1', the CLOCK_SOURCE value is NOT used.
Note: It is SW's responsibility to provide the correct NOREF, SKEW and TENMS field values for the selected clock source.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SKEW</name>
              <description>Specifies the precision of the clock source and if the TENMS field represents exactly 10 ms (clock source frequency is a multiple of 100 Hz). This affects the suitability of the SysTick timer as a SW real-time clock:
'0': Precise.
'1': Imprecise.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOREF</name>
              <description>Specifies if an external clock source is provided:
'0': An external clock source is provided. 
'1': An external clock source is NOT provided and only the CPU internal clock can be used as SysTick timer clock source.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MBIST_STAT</name>
          <description>Memory BIST status</description>
          <addressOffset>0x1704</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>SFP_READY</name>
              <description>Flag indicating the BIST run is done. Note that after starting a BIST run this flag must be set before a new run can be started. For the first BIST run this will be 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SFP_FAIL</name>
              <description>Report status of the BIST run, only valid if SFP_READY=1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAL_SUP_SET</name>
          <description>Calibration support set and read</description>
          <addressOffset>0x1800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Read without side effect, write 1 to set</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAL_SUP_CLR</name>
          <description>Calibration support clear and reset</description>
          <addressOffset>0x1804</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Read side effect: when read all bits are cleared, write 1 to clear a specific bit 
Note: no exception for the debug host, it also causes the read side effect</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_PC_CTL</name>
          <description>CM0+ protection context control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Valid fields for the protection context handler CM0_PCi_HANDLER registers:
Bit 0: Valid field for CM0_PC0_HANDLER.
Bit 1: Valid field for CM0_PC1_HANDLER.
Bit 2: Valid field for CM0_PC2_HANDLER.
Bit 3: Valid field for CM0_PC3_HANDLER.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_PC0_HANDLER</name>
          <description>CM0+ protection context 0 handler</description>
          <addressOffset>0x2040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 0 handler. This field is used to detect entry to Cypress 'trusted' code through an exception/interrupt.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_PC1_HANDLER</name>
          <description>CM0+ protection context 1 handler</description>
          <addressOffset>0x2044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 1 handler.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_PC2_HANDLER</name>
          <description>CM0+ protection context 2 handler</description>
          <addressOffset>0x2048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 2 handler.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_PC3_HANDLER</name>
          <description>CM0+ protection context 3 handler</description>
          <addressOffset>0x204C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 3 handler.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PROTECTION</name>
          <description>Protection status</description>
          <addressOffset>0x20C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>STATE</name>
              <description>Protection state:
'0': UNKNOWN.
'1': VIRGIN.
'2': NORMAL.
'3': SECURE.
'4': DEAD.

The following state transitions are allowed (and enforced by HW):
- UNKNOWN =&gt; VIRGIN/NORMAL/SECURE/DEAD
- NORMAL =&gt; DEAD
- SECURE =&gt; DEAD
An attempt to make a NOT allowed state transition will NOT affect this register field.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_ROM_CTL</name>
          <description>ROM trim control</description>
          <addressOffset>0x2100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRIM</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_RAM_CTL</name>
          <description>RAM trim control</description>
          <addressOffset>0x2104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRIM</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>1023</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM0_SYSTEM_INT_CTL[%s]</name>
          <description>CM0+ system interrupt control</description>
          <addressOffset>0x8000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>CPU_INT_IDX</name>
              <description>CPU interrupt index (legal range [0, 7]). This field specifies to which CPU interrupt the system interrupt is mapped. E.g., if CPU_INT_IDX is '6', the system interrupt is mapped to CPU interrupt '6'.

Note: it is possible to map multiple system interrupts to the same CPU interrupt. It is advised to assign different priorities to the CPU interrupts and to assign system interrupts to CPU interrupts accordingly.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_INT_VALID</name>
              <description>Interrupt enable:
'0': Disabled. The system interrupt will NOT be mapped to any CPU interrupt.
'1': Enabled. The system interrupt is mapped on CPU interrupt CPU_INT_IDX.

Note: the CPUs have dedicated XXX_SYSTEM_INT_CTL registers. In other words, the CPUs can use different CPU interrupts for the same system interrupt. However, typically only one of the CPUs will have the ENABLED field of a specific system interrupt set to '1'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>1023</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM4_SYSTEM_INT_CTL[%s]</name>
          <description>CM4 system interrupt control</description>
          <addressOffset>0xA000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>CPU_INT_IDX</name>
              <description>N/A</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_INT_VALID</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FAULT</name>
      <description>Fault structures</description>
      <baseAddress>0x40210000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>256</dimIncrement>
          <name>STRUCT[%s]</name>
          <description>Fault structure</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Fault control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>TR_EN</name>
                <description>Trigger output enable:
'0': Disabled. The trigger output 'tr_fault' is '0'.
'1': Enabled. The trigger output 'tr_fault' reflects STATUS.VALID. The trigger can be used to initiate a Datawire transfer of the FAULT data (FAULT_DATA0 through FAULT_DATA3).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT_EN</name>
                <description>IO output signal enable:
'0': Disabled. The IO output signal 'fault_out' is '0'. The IO output enable signal 'fault_out_en' is '0'.
'1': Enabled. The IO output signal 'fault_out' reflects STATUS.VALID. The IO output enable signal 'fault_out_en' is '1'.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESET_REQ_EN</name>
                <description>Reset request enable:
'0': Disabled.
'1': Enabled. The output reset request signal 'fault_reset_req' reflects STATUS.VALID. This reset causes a warm/soft/core reset. This warm/soft/core reset does not affect the fault logic STATUS, DATA0, ..., DATA3 registers (allowing for post soft reset failure analysis).

The 'fault_reset_req' signals of the individual fault report structures are combined (logically OR'd) into a single SRSS 'fault_reset_req' signal.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Fault status</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>IDX</name>
                <description>The fault source index for which fault information is captured in DATA0 through DATA3. The fault information is fault source specific and described below.

Note: this register field (and associated fault source data in DATA0 through DATA3) should only be considered valid, when VALID is '1'.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Valid indication:
'0': Invalid.
'1': Valid. HW sets this field to '1' when new fault source data is captured. New fault source data is ONLY captured when VALID is '0'. SW can clear this field to '0' when the fault is handled (by SW).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>4</dim>
            <dimIncrement>4</dimIncrement>
            <name>DATA[%s]</name>
            <description>Fault data</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Captured fault source data. 

Note: the fault source index STATUS.IDX specifies the format of the DATA registers.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PENDING0</name>
            <description>Fault pending 0</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>This field specifies the following sources:
Bit 0: CM0 MPU.
Bit 1: CRYPTO MPU.
Bit 2: DW 0 MPU.
Bit 3: DW 1 MPU.
...
Bit 14: CM4 code bus MPU.
Bit 15: DAP MPU.
Bit 16: CM4 s+G92ystem bus MPU.


Bit 28: Peripheral master interface 0 PPU. 
Bit 29: Peripheral master interface 1 PPU. 
Bit 30: Peripheral master interface 2 PPU. 
Bit 31: Peripheral master interface 3 PPU.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PENDING1</name>
            <description>Fault pending 1</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>This field specifies the following sources:
Bit 0: Peripheral group 0 PPU.
Bit 1: Peripheral group 1 PPU.
Bit 2: Peripheral group 2 PPU.
Bit 3: Peripheral group 3 PPU.
Bit 4: Peripheral group 4 PPU.
Bit 5: Peripheral group 5 PPU.
Bit 6: Peripheral group 6 PPU.
Bit 7: Peripheral group 7 PPU.
...
Bit 15: Peripheral group 15 PPU.

Bit 18: Flash controller, main interface, bus error.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PENDING2</name>
            <description>Fault pending 2</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>This field specifies the following sources:
Bit 0 - 31: TBD.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MASK0</name>
            <description>Fault mask 0</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>Fault source enables:
Bits 31-0: Fault sources 31 to 0.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MASK1</name>
            <description>Fault mask 1</description>
            <addressOffset>0x54</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>Fault source enables:
Bits 31-0: Fault sources 63 to 32.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MASK2</name>
            <description>Fault mask 2</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>Fault source enables:
Bits 31-0: Fault sources 95 to 64.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>This interrupt cause field is activated (HW sets the field to '1') when an enabled (MASK0/MASK1/MASK2) pending fault source is captured:
- STATUS.VALID is set to '1'.
- STATUS.IDX specifies the fault source index.
- DATA0 through DATA3 captures the fault source data.

SW writes a '1' to these field to clear the interrupt cause to '0'.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0xC8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0xCC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>IPC</name>
      <description>IPC</description>
      <baseAddress>0x40220000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>16</dim>
          <dimIncrement>32</dimIncrement>
          <name>STRUCT[%s]</name>
          <description>IPC structure</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>ACQUIRE</name>
            <description>IPC acquire</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the access that successfully acquired the lock.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NS</name>
                <description>Secure/non-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the access that successfully acquired the lock.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC</name>
                <description>This field specifies the protection context that successfully acquired the lock.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MS</name>
                <description>This field specifies the bus master identifier that successfully acquired the lock.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SUCCESS</name>
                <description>Specifies if the lock is successfully acquired or not (reading the ACQUIRE register can have affect on SUCCESS and LOCK_STATUS.ACQUIRED):
'0': Not successfully acquired; i.e. the lock was already acquired by another read transaction and not released. The P, NS, PC and MS fields reflect the access attributes of the transaction that previously successfully acuired the lock; the fields are NOT affected by the current access.
'1': Successfully acquired. The P, NS, PC and MS fields reflect the access attributes of the current access.

Note that this field is NOT SW writable. A lock is released by writing to the associated RELEASE register (irrespective of the write value).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RELEASE</name>
            <description>IPC release</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>INTR_RELEASE</name>
                <description>Writing this field releases a lock and allows for the generation of release events to the IPC interrupt structures, but only when the lock is acquired (LOCK_STATUS.ACQUIRED is '1'). The IPC release cause fields associated with this IPC structure are set to '1', but only for those IPC interrupt structures for which the corresponding bit field in INTR_RELEASE[] is set to '1'. 

SW writes a '1' to the bit fields to generate a release event. Due to the transient nature of this event, SW always reads a '0' from this field.</description>
                <bitRange>[15:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>NOTIFY</name>
            <description>IPC notification</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>INTR_NOTIFY</name>
                <description>This field allows for the generation of notification events to the IPC interrupt structures. The IPC notification cause fields associated with this IPC structure are set to '1', but only for those IPC interrupt structures for which the corresponding bit field in INTR_NOTIFY[] is set to '1'. 

SW writes a '1' to the bit fields to generate a notify event. Due to the transient nature of this event, SW always reads a '0' from this field.</description>
                <bitRange>[15:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA0</name>
            <description>IPC data 0</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>This field holds a 32-bit data element that is associated with the IPC structure.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA1</name>
            <description>IPC data 1</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>This field holds a 32-bit data element that is associated with the IPC structure.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOCK_STATUS</name>
            <description>IPC lock status</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>This field specifies the user/privileged access control:
'0': user mode.
'1': privileged mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NS</name>
                <description>This field specifies the secure/non-secure access control:
'0': secure.
'1': non-secure.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC</name>
                <description>This field specifies the protection context that successfully acquired the lock.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MS</name>
                <description>This field specifies the bus master identifier that successfully acquired the lock.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ACQUIRED</name>
                <description>Specifies if the lock is acquired. This field is set to '1', if a ACQUIRE read transfer successfully acquires the lock (the ACQUIRE read transfer returns ACQUIRE.SUCCESS as '1'). If zero, P, NS, PC, and MS are not valid.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>32</dimIncrement>
          <name>INTR_STRUCT[%s]</name>
          <description>IPC interrupt structure</description>
          <addressOffset>0x00001000</addressOffset>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>These interrupt cause fields are activated (HW sets the field to '1') when a IPC release event is detected. One bit field for each master. SW writes a '1' to these field to clear the interrupt cause.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>These interrupt cause fields are activated (HW sets the field to '1') when a IPC notification event is detected. One bit field for each master. SW writes a '1' to these field to clear the interrupt cause.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>PROT</name>
      <description>Protection</description>
      <baseAddress>0x40230000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <name>SMPU</name>
          <description>SMPU</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>MS0_CTL</name>
            <description>Master 0 protection context control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>Privileged setting ('0': user mode; '1': privileged mode).

Notes:
This field is ONLY used for masters that do NOT provide their own user/privileged access control attribute.
The default/reset field value provides privileged mode access capabilities.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>Security setting ('0': secure mode; '1': non-secure mode).

Notes:
This field is ONLY used for masters that do NOT provide their own secure/non-secure access control attribute.
Note that the default/reset field value provides non-secure mode access capabilities to all masters.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>Device wide bus arbitration priority setting ('0': highest priority, '3': lowest priority).

Notes: 
The AHB-Lite interconnect performs arbitration on the individual  beats/transfers of a burst (this optimizes latency over locality/bandwidth).
The AXI-Lite interconnects performs a single arbitration for the complete burst (this optimizes locality/bandwidth over latency).
Masters with the same priority setting form a 'priority group'. Within a 'priority group', round robin arbitration is performed.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>Protection context mask for protection context '0'. This field is a constant '0':
- PC_MASK_0 is '0': MPU MS_CTL.PC[3:0] can NOT be set to '0' and PC[3:0] is not changed. If the protection context of the write transfer is '0', protection is not applied and PC[3:0] can be changed.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>Protection context mask for protection contexts '15' down to '1'. Bit PC_MASK_15_TO_1[i] indicates if the MPU MS_CTL.PC[3:0] protection context field can be set to the value 'i+1':
- PC_MASK_15_TO_1[i] is '0': MPU MS_CTL.PC[3:0] can NOT be set to 'i+1'; and PC[3:0] is not changed. If the protection context of the write transfer is '0', protection is not applied and PC[3:0] can be changed.
- PC_MASK_15_TO_1[i] is '1': MPU MS_CTL.PC[3:0] can be set to 'i+1'.

Note: When CPUSS_CM0_PC_CTL.VALID[i] is '1' (the associated protection context handler is valid), write transfers to PC_MASK_15_TO_1[i-1] always write '0', regardless of data written. This ensures that when valid protection context handlers are used to enter protection contexts 1, 2 or 3 through (HW modifies MPU MS_CTL.PC[3:0] on entry of the handler), it is NOT possible for SW to enter those protection contexts (SW modifies MPU MS_CTL.PC[3:0]).</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS1_CTL</name>
            <description>Master 1 protection context control</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS2_CTL</name>
            <description>Master 2 protection context control</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS3_CTL</name>
            <description>Master 3 protection context control</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS4_CTL</name>
            <description>Master 4 protection context control</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS5_CTL</name>
            <description>Master 5 protection context control</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS6_CTL</name>
            <description>Master 6 protection context control</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS7_CTL</name>
            <description>Master 7 protection context control</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS8_CTL</name>
            <description>Master 8 protection context control</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS9_CTL</name>
            <description>Master 9 protection context control</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS10_CTL</name>
            <description>Master 10 protection context control</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS11_CTL</name>
            <description>Master 11 protection context control</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS12_CTL</name>
            <description>Master 12 protection context control</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS13_CTL</name>
            <description>Master 13 protection context control</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS14_CTL</name>
            <description>Master 14 protection context control</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS15_CTL</name>
            <description>Master 15 protection context control</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <cluster>
            <dim>16</dim>
            <dimIncrement>64</dimIncrement>
            <name>SMPU_STRUCT[%s]</name>
            <description>SMPU structure</description>
            <addressOffset>0x00002000</addressOffset>
            <register>
              <name>ADDR0</name>
              <description>SMPU region address 0 (slave structure)</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x0</resetMask>
              <fields>
                <field>
                  <name>SUBREGION_DISABLE</name>
                  <description>This field is used to individually disabled the eight equally sized subregions in which a region is partitioned. Subregion disable:
Bit 0: subregion 0 disable.
Bit 1: subregion 1 disable.
Bit 2: subregion 2 disable.
Bit 3: subregion 3 disable.
Bit 4: subregion 4 disable.
Bit 5: subregion 5 disable.
Bit 6: subregion 6 disable.
Bit 7: subregion 7 disable.
E.g., a 64 KByte address region (ATT0.REGION_SIZE is '15') has eight 8 KByte subregions. The access control as defined by ATT0 applies if the bus transfer address is within the address region AND the addressed subregion is NOT disabled. Note that the smallest region size is 256 B and the smallest subregion size is 32 B.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADDR24</name>
                  <description>This field specifies the most significant bits of the 32-bit address of an address region. The region size is defined by ATT0.REGION_SIZE. A region of n Byte is always n Byte aligned. As a result, some of the lesser significant address bits of ADDR24 may be ignored in determining whether a bus transfer address is within an address region. E.g., a 64 KByte address region (REGION_SIZE is '15') is 64 KByte aligned, and ADDR24[7:0] are ignored.</description>
                  <bitRange>[31:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ATT0</name>
              <description>SMPU region attributes 0 (slave structure)</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x100</resetValue>
              <resetMask>0x80000100</resetMask>
              <fields>
                <field>
                  <name>UR</name>
                  <description>User read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UW</name>
                  <description>User write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UX</name>
                  <description>User execute enable:
'0': Disabled (user, execute accesses are NOT allowed).
'1': Enabled (user, execute accesses are allowed).</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PR</name>
                  <description>Privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PW</name>
                  <description>Privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PX</name>
                  <description>Privileged execute enable:
'0': Disabled (privileged, execute accesses are NOT allowed).
'1': Enabled (privileged, execute accesses are allowed).</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NS</name>
                  <description>Non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PC_MASK_0</name>
                  <description>This field specifies protection context identifier based access control for protection context '0'.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PC_MASK_15_TO_1</name>
                  <description>This field specifies protection context identifier based access control.
Bit i: protection context i+1 enable. If '0', protection context i+1 access is disabled; i.e. not allowed. If '1', protection context i+1 access is enabled; i.e. allowed.</description>
                  <bitRange>[23:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REGION_SIZE</name>
                  <description>This field specifies the region size:
'0'-'6': Undefined.
'7': 256 B region
'8': 512 B region
'9': 1 KB region
'10': 2 KB region
'11': 4 KB region
'12': 8 KB region
'13': 16 KB region
'14': 32 KB region
'15': 64 KB region
'16': 128 KB region
'17': 256 KB region
'18': 512 KB region
'19': 1 MB region
'20': 2 MB region
'21': 4 MB region
'22': 8 MB region
'23': 16 MB region
'24': 32 MB region
'25': 64 MB region
'26': 128 MB region
'27': 256 MB region
'28': 512 MB region
'39': 1 GB region
'30': 2 GB region
'31': 4 GB region</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PC_MATCH</name>
                  <description>This field specifies if the PC field participates in the 'matching' process or the 'access evaluation' process:
'0': PC field participates in 'access evaluation'.
'1': PC field participates in 'matching'.

'Matching' process. For each protection structure, the process identifies if a transfer address is contained within the address range. This identifies the 'matching' regions.
'Access evaluation' process. For each protection structure, the process evaluates the bus transfer access attributes against the access control attributes.

Note that it is possible to define different access control for multiple protection contexts by using multiple protection structures with the same address region and PC_MATCH set to '1'.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLED</name>
                  <description>Region enable:
'0': Disabled. A disabled region will never result in a match on the bus transfer address.
'1': Enabled.

Note: a disabled address region performs logic gating to reduce dynamic power consumption.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ADDR1</name>
              <description>SMPU region address 1 (master structure)</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>SUBREGION_DISABLE</name>
                  <description>This field is used to individually disabled the eight equally sized subregions in which a region is partitioned. Subregion disable:
Bit 0: subregion 0 disable.
Bit 1: subregion 1 disable.
Bit 2: subregion 2 disable.
Bit 3: subregion 3 disable.
Bit 4: subregion 4 disable.
Bit 5: subregion 5 disable.
Bit 6: subregion 6 disable.
Bit 7: subregion 7 disable.

Two out of a total of eight 32 B subregions are enabled. These subregions includes region structures 0 and 1. 

Note: this field is read-only.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ADDR24</name>
                  <description>This field specifies the most significant bits of the 32-bit address of an address region.

'ADDR_DEF1': base address of structure.

Note: this field is read-only.</description>
                  <bitRange>[31:8]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ATT1</name>
              <description>SMPU region attributes 1 (master structure)</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x7000109</resetValue>
              <resetMask>0x9F00012D</resetMask>
              <fields>
                <field>
                  <name>UR</name>
                  <description>User read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).

Note that this register is constant '1'; i.e. user read accesses are ALWAYS allowed.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>UW</name>
                  <description>User write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UX</name>
                  <description>User execute enable:
'0': Disabled (user, execute accesses are NOT allowed).
'1': Enabled (user, execute accesses are allowed).

Note that this register is constant '0'; i.e. user execute accesses are NEVER allowed.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PR</name>
                  <description>Privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).

Note that this register is constant '1'; i.e. privileged read accesses are ALWAYS allowed.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PW</name>
                  <description>Privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PX</name>
                  <description>Privileged execute enable:
'0': Disabled (privileged, execute accesses are NOT allowed).
'1': Enabled (privileged, execute accesses are allowed).

Note that this register is constant '0'; i.e. privileged execute accesses are NEVER allowed.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>NS</name>
                  <description>Non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PC_MASK_0</name>
                  <description>This field specifies protection context identifier based access control for protection context '0'.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PC_MASK_15_TO_1</name>
                  <description>This field specifies protection context identifier based access control.
Bit i: protection context i+1 enable. If '0', protection context i+1 access is disabled; i.e. not allowed. If '1', protection context i+1 access is enabled; i.e. allowed.</description>
                  <bitRange>[23:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REGION_SIZE</name>
                  <description>This field specifies the region size:
'7': 256 B region (8 32 B subregions)

Note: this field is read-only.</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PC_MATCH</name>
                  <description>This field specifies if the PC field participates in the 'matching' process or the 'access evaluation' process:
'0': PC field participates in 'access evaluation'.
'1': PC field participates in 'matching'.

'Matching' process. For each protection structure, the process identifies if a transfer address is contained within the address range. This identifies the 'matching' regions.
'Access evaluation' process. For each protection structure, the process evaluates the bus transfer access attributes against the access control attributes.

Note that it is possible to define different access control for multiple protection contexts by using multiple protection structures with the same address region and PC_MATCH set to '1'.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLED</name>
                  <description>Region enable:
'0': Disabled. A disabled region will never result in a match on the bus transfer address.
'1': Enabled.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>1024</dimIncrement>
          <name>MPU[%s]</name>
          <description>MPU</description>
          <addressOffset>0x00004000</addressOffset>
          <register>
            <name>MS_CTL</name>
            <description>Master control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF000F</resetMask>
            <fields>
              <field>
                <name>PC</name>
                <description>Active protection context (PC). Modifications to this field are constrained by the associated SMPU MS_CTL.PC_MASK_0 and MS_CTL.PC_MASK_15_TO_1[] fields. In addition, a write transfer with protection context '0' can change this field (protection context 0 has unrestricted access).

The CM0+ MPU MS_CTL register is special: the PC field is modifiable by BOTH HW and SW (for all other masters, the MPU MS_CTL.PC field is modifiable by SW ONLY. For CM0+ PC field HW modifications, the following holds:
* On entry of a CM0_PC0/1/2/3_HANDLER exception/interrupt handler:
   IF (the new PC is the same as MS_CTL.PC)
       PC is not affected; PC_SAVED is not affected.
   ELSE IF (CM0_PC_CTL.VALID[MS_CTL.PC])
       An AHB-Lite bus error is generated for the exception handler fetch;
       PC is not affected; PC_SAVED is not affected.
   ELSE
       PC = 'new PC'; PC_SAVED = PC (push operation).
* On entry of any other exception/interrupt handler:
   PC = PC_SAVED; PC_SAVED is not affected (pop operation).

Note that the CM0_PC0/1/2/3_HANDLER and CM0_PC_CTL registers are part of repecitve CPUSS MMIO registers.

Note: this field is NOT used by the DW controllers, DMA controller, AXI DMA controller, CRYPTO component and VIDEOSS.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_SAVED</name>
                <description>Saved protection context. Modifications to this field are constrained by the associated SMPU MS_CTL.PC_MASK_0 and MS_CTL.PC_MASK_15_TO_1[] fields.

Note: this field is ONLY used by the CM0+.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>127</dim>
            <dimIncrement>4</dimIncrement>
            <name>MS_CTL_READ_MIR[%s]</name>
            <description>Master control read mirror</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF000F</resetMask>
            <fields>
              <field>
                <name>PC</name>
                <description>Read-only mirror of MS_CTL.PC</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_SAVED</name>
                <description>Read-only mirror of MS_CTL.PC_SAVED</description>
                <bitRange>[19:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <cluster>
            <dim>8</dim>
            <dimIncrement>32</dimIncrement>
            <name>MPU_STRUCT[%s]</name>
            <description>MPU structure</description>
            <addressOffset>0x00000200</addressOffset>
            <register>
              <name>ADDR</name>
              <description>MPU region address</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x0</resetMask>
              <fields>
                <field>
                  <name>SUBREGION_DISABLE</name>
                  <description>This field is used to individually disabled the eight equally sized subregions in which a region is partitioned. Subregion disable:
Bit 0: subregion 0 disable.
Bit 1: subregion 1 disable.
Bit 2: subregion 2 disable.
Bit 3: subregion 3 disable.
Bit 4: subregion 4 disable.
Bit 5: subregion 5 disable.
Bit 6: subregion 6 disable.
Bit 7: subregion 7 disable.
E.g., a 64 KByte address region (REGION_SIZE is '15') has eight 8 KByte subregions. The access control as defined by MPU_REGION_ATT applies if the bus transfer address is within the address region AND the addressed subregion is NOT disabled. Note that the smallest region size is 256 B and the smallest subregion size is 32 B.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADDR24</name>
                  <description>This field specifies the most significant bits of the 32-bit address of an address region. The region size is defined by ATT.REGION_SIZE. A region of n Byte is always n Byte aligned. As a result, some of the lesser significant address bits of ADDR24 may be ignored in determining whether a bus transfer address is within an address region. E.g., a 64 KByte address region (REGION_SIZE is '15') is 64 KByte aligned, and ADDR24[7:0] are ignored.</description>
                  <bitRange>[31:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ATT</name>
              <description>MPU region attrributes</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x80000000</resetMask>
              <fields>
                <field>
                  <name>UR</name>
                  <description>User read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UW</name>
                  <description>User write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UX</name>
                  <description>User execute enable:
'0': Disabled (user, execute accesses are NOT allowed).
'1': Enabled (user, execute accesses are allowed).</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PR</name>
                  <description>Privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PW</name>
                  <description>Privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PX</name>
                  <description>Privileged execute enable:
'0': Disabled (privileged, execute accesses are NOT allowed).
'1': Enabled (privileged, execute accesses are allowed).</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NS</name>
                  <description>Non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REGION_SIZE</name>
                  <description>This field specifies the region size:
'0'-'6': Undefined.
'7': 256 B region
'8': 512 B region
'9': 1 KB region
'10': 2 KB region
'11': 4 KB region
'12': 8 KB region
'13': 16 KB region
'14': 32 KB region
'15': 64 KB region
'16': 128 KB region
'17': 256 KB region
'18': 512 KB region
'19': 1 MB region
'20': 2 MB region
'21': 4 MB region
'22': 8 MB region
'23': 16 MB region
'24': 32 MB region
'25': 64 MB region
'26': 128 MB region
'27': 256 MB region
'28': 512 MB region
'39': 1 GB region
'30': 2 GB region
'31': 4 GB region</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLED</name>
                  <description>Region enable:
'0': Disabled. A disabled region will never result in a match on the bus transfer address.
'1': Enabled.

Note: a disabled address region performs logic gating to reduce dynamic power consumption.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>FLASHC</name>
      <description>Flash controller</description>
      <baseAddress>0x40240000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>FLASH_CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x110000</resetValue>
          <resetMask>0x77330F</resetMask>
          <fields>
            <field>
              <name>MAIN_WS</name>
              <description>N/A</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAIN_MAP</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_MAP</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAIN_BANK_MODE</name>
              <description>N/A</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_BANK_MODE</name>
              <description>N/A</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAIN_ECC_EN</name>
              <description>N/A</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAIN_ECC_INJ_EN</name>
              <description>N/A</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAIN_ERR_SILENT</name>
              <description>N/A</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_ECC_EN</name>
              <description>N/A</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_ECC_INJ_EN</name>
              <description>N/A</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_ERR_SILENT</name>
              <description>N/A</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_PWR_CTL</name>
          <description>Flash power control</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Enables power to the flash memory</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_HV</name>
              <description>Enables HV power to the flash memory</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_CMD</name>
          <description>Command</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>INV</name>
              <description>Invalidation of ALL caches (for CM0+ and CM4) and ALL buffers. SW writes a '1' to clear the caches. HW sets this field to '0' when the operation is completed. The operation takes a maximum of three clock cycles on the slowest of the clk_slow and clk_fast clocks. The caches' LRU structures are also reset to their default state.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUFF_INV</name>
              <description>Invalidation of ALL buffers (does not invalidate the caches). SW writes a '1' to clear the buffers. HW sets this field to '0' when the operation is completed. The operation takes a maximum of three clock cycles on the slowest of the clk_slow and clk_fast clocks.

Note: the caches only capture FLASH macro main array data. Therefore, invalidating just the buffers (BUFF_INV) does not invalidate captures main array data in the caches.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x2A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where an error will be injected.
- For cache SRAM ECC, the word address WORD_ADDR[23:0] is device address A[25:2]. On a FLASH macro refill to this word address and when the corresponding CM0/4_CA_CTL.RAM_ECC_INJ_EN bit is '1', the parity (PARITY[6:0]) is injected and stored in the cache.
- For FLASH main interface ECC, the word address WORD_ADDR[23:0] is device address A[26:3]. On a FLASH main interface read and when FLASH_CTL.MAIN_ECC_INJ_EN bit is '1', the parity (PARITY[7:0]) replaces the FLASH macro parity (FLASH main interface read path is manipulated).
- For FLASH work interface ECC, the word address WORD_ADDR[23:0] is device address A[25:2]. On a FLASH work interface read and when FLASH_CTL.WORK_ECC_INJ_EN bit is '1', the parity (PARITY[6:0]) replaces the FLASH macro parity (FLASH work interface read path is manipulated).</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR. 
- For cache SRAM ECC, the 7-bit parity PARITY[6:0] is for a 32-bit word.
- For FLASH main interface ECC, the 8-bit parity PARITY[7:0] is for a 64-bit word.
- For FLASH work interface ECC, the 7-bit parity PARITY[6:0] is for a 32-bit word.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FM_SRAM_ECC_CTL0</name>
          <description>eCT Flash SRAM ECC control 0</description>
          <addressOffset>0x2B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ECC_INJ_DATA</name>
              <description>32-bit data for ECC error injection test of eCT Flash SRAM ECC logic.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FM_SRAM_ECC_CTL1</name>
          <description>eCT Flash SRAM ECC control 1</description>
          <addressOffset>0x2B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F</resetMask>
          <fields>
            <field>
              <name>ECC_INJ_PARITY</name>
              <description>7-bit parity for ECC error injection test of eCT Flash SRAM ECC logic.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FM_SRAM_ECC_CTL2</name>
          <description>eCT Flash SRAM ECC control 2</description>
          <addressOffset>0x2B8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CORRECTED_DATA</name>
              <description>32-bit corrected data output of the ECC syndrome logic.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FM_SRAM_ECC_CTL3</name>
          <description>eCT Flash SRAM ECC control 3</description>
          <addressOffset>0x2BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x111</resetMask>
          <fields>
            <field>
              <name>ECC_ENABLE</name>
              <description>ECC generation/check enable for eCT Flash SRAM memory.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>eCT Flash SRAM ECC error injection test enable. Follow the steps below for ECC logic test:
1. Write corrupted or uncorrupted 39-bit data to FM_SRAM_ECC_CTL0/1 registers.
2. Set the ECC_INJ_EN bit to '1'.
3. Confirm that the bit ECC_TEST_FAIL is '0'. If this is not the case, start over at item 1 because the eCT Flash was not idle.
4. Check the corrected data in FM_SRAM_ECC_CTL2.
5. Confirm that fault was reported to fault structure, and check syndrome (only applicable if
corrupted data was written in step 1).
6. If not finished, start over at 1 with different data.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_TEST_FAIL</name>
              <description>Status of ECC test.
1 : ECC test failed because eCT Flash macro is busy and using the SRAM.
0: ECC was performed.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_CTL0</name>
          <description>CM0+ cache control</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0000001</resetValue>
          <resetMask>0xC7030003</resetMask>
          <fields>
            <field>
              <name>RAM_ECC_EN</name>
              <description>Enable ECC checking for cache accesses:
0: Disabled.
1: Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAM_ECC_INJ_EN</name>
              <description>Enable error injection for cache.
When '1', the parity (ECC_CTL.PARITY[6:0]) is used when a refill is done from the FLASH macro to the ECC_CTL.WORD_ADDR[23:0] word address.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAY</name>
              <description>Specifies the cache way for which cache information is provided in CM0_CA_STATUS0/1/2.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_ADDR</name>
              <description>Specifies the cache set for which cache information is provided in CM0_CA_STATUS0/1/2.</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>Prefetch enable:
0: Disabled.
1: Enabled.

Prefetching requires the cache to be enabled; i.e. ENABLED is '1'.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CA_EN</name>
              <description>Cache enable:
0: Disabled. The cache tag valid bits are reset to '0's and the cache LRU information is set to '1's (making way 0 the LRU way and way 3 the MRU way).
1: Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_CTL1</name>
          <description>CM0+ cache control</description>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050003</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Specifies power mode for CM0 cache.
The following sequnece should be followed for turning OFF/ON the cache SRAM.
Turn OFF sequence:
a) Write CM0_CA_CTL0 to disable cache.
b) Write CM0_CA_CTL1 to turn OFF cache SRAM.
Turn ON sequence:
a) Write CM0_CA_CTL1 to turn ON cache SRAM.
b) Delay to allow power up of cache SRAM. Delay should be at a minimum of CM0_CA_CTL2.PWRUP_DELAY CLK_SLOW clock cycles.
c) Write CM0_CA_CTL0 to enable cache.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Power OFF the CM0 cache SRAM.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>Undefined</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>Put CM0 cache SRAM in retained mode.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enable/Turn ON the CM0 cache SRAM.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.

Note: Although the SW attribute for this field says ''R', SW need to write the key 0x05fa in this field for this register write to happen. This is a built in protection provided to prevent accidental writes from SW.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_CTL2</name>
          <description>CM0+ cache control</description>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x12C</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>PWRUP_DELAY</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_STATUS0</name>
          <description>CM0+ cache status 0</description>
          <addressOffset>0x440</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALID32</name>
              <description>Sixteen valid bits of the cache line specified by CM0_CA_CTL.WAY and CM0_CA_CTL.SET_ADDR.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_STATUS1</name>
          <description>CM0+ cache status 1</description>
          <addressOffset>0x444</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>TAG</name>
              <description>Cache line address of the cache line specified by CM0_CA_CTL.WAY and CM0_CA_CTL.SET_ADDR.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_STATUS2</name>
          <description>CM0+ cache status 2</description>
          <addressOffset>0x448</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>LRU</name>
              <description>Six bit LRU representation of the cache set specified by CM0_CA_CTL.SET_ADDR. The encoding of the field is as follows ('X_LRU_Y' indicates that way X is Less Recently Used than way Y):
Bit 5: 0_LRU_1: way 0 less recently used than way 1.
Bit 4: 0_LRU_2.
Bit 3: 0_LRU_3.
Bit 2: 1_LRU_2.
Bit 1: 1_LRU_3.
Bit 0: 2_LRU_3.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_STATUS</name>
          <description>CM0+ interface status</description>
          <addressOffset>0x460</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>MAIN_INTERNAL_ERR</name>
              <description>Specifies/registers the occurrence of a FLASH macro main interface internal error (typically the result of a read access while a program erase operation is ongoing) as a result of a CM0+ access (or debug access via SYS_AP/CM0_AP). 

SW clears this field to '0'. HW sets this field to '1' on a FLASH macro main interface internal error. Typically, SW reads this field after a code section to detect the occurrence of an error.

Note: this field is independent of FLASH_CTL.MAIN_ERR_SILENT.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_INTERNAL_ERR</name>
              <description>See CM0_STATUS.MAIN_INTERNAL_ERROR.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CA_CTL0</name>
          <description>CM4 cache control</description>
          <addressOffset>0x480</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0000001</resetValue>
          <resetMask>0xC7030003</resetMask>
          <fields>
            <field>
              <name>RAM_ECC_EN</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAM_ECC_INJ_EN</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAY</name>
              <description>Specifies the cache way for which cache information is provided in CM4_CA_STATUS0/1/2.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_ADDR</name>
              <description>Specifies the cache set for which cache information is provided in CM4_CA_STATUS0/1/2.</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>Prefetch enable:
0: Disabled.
1: Enabled.

Prefetching requires the cache to be enabled; i.e. ENABLED is '1'.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CA_EN</name>
              <description>Cache enable:
0: Disabled. The cache tag valid bits are reset to '0's and the cache LRU information is set to '1's (making way 0 the LRU way and way 3 the MRU way).
1: Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CA_CTL1</name>
          <description>CM4 cache control</description>
          <addressOffset>0x484</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050003</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Specifies power mode for CM4 cache.
The following sequnece should be followed for truning OFF/ON the cache SRAM.
Turn OFF sequence:
a) Write CM4_CA_CTL0 to disable cache.
b) Write CM4_CA_CTL1 to turn OFF cache SRAM.
Turn ON sequence:
a) Write CM4_CA_CTL1 to turn ON cache SRAM.
b) Delay to allow power up of cache SRAM. Delay should be at a minimum of CM4_CA_CTL2.PWRUP_DELAY CLK_SLOW clock cycles.
c) Write CM4_CA_CTL0 to enable cache.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>See CM0_CA_CTL1</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>Undefined</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>See CM0_CA_CTL1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>See CM0_CA_CTL1</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.

Note: Although the SW attribute for this field says ''R', SW need to write the key 0x05fa in this field for this register write to happen. This is a built in protection provided to prevent accidental writes from SW.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CA_CTL2</name>
          <description>CM4 cache control</description>
          <addressOffset>0x488</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x12C</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>PWRUP_DELAY</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CA_STATUS0</name>
          <description>CM4 cache status 0</description>
          <addressOffset>0x4C0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALID32</name>
              <description>See CM0_CA_STATUS0.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CA_STATUS1</name>
          <description>CM4 cache status 1</description>
          <addressOffset>0x4C4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>TAG</name>
              <description>See CM0_CA_STATUS1.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CA_STATUS2</name>
          <description>CM4 cache status 2</description>
          <addressOffset>0x4C8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>LRU</name>
              <description>See CM0_CA_STATUS2.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_STATUS</name>
          <description>CM4 interface status</description>
          <addressOffset>0x4E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>MAIN_INTERNAL_ERR</name>
              <description>Specifies/registers the occurrence of a FLASH macro main interface internal error (typically the result of a read access while a program erase operation is ongoing) as a result of a CM4 access (or debug access via SYS_AP/CM4_AP). 

SW clears this field to '0'. HW sets this field to '1' on a FLASH macro main interface internal error. Typically, SW reads this field after a code section to detect the occurrence of an error.

Note: this field is independent of FLASH_CTL.MAIN_ERR_SILENT.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_INTERNAL_ERR</name>
              <description>See CM4_STATUS.MAIN_INTERNAL_ERROR.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_BUFF_CTL</name>
          <description>Cryptography buffer control</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>Prefetch enable:
0: Disabled.
1: Enabled.
A prefetch will be done when there is read 'hit' on the last 32-bit word of the buffer.
For eCT work Flash, prefetch will not be done.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DW0_BUFF_CTL</name>
          <description>Datawire 0 buffer control</description>
          <addressOffset>0x580</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>See CRYPTO_BUFF_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DW1_BUFF_CTL</name>
          <description>Datawire 1 buffer control</description>
          <addressOffset>0x600</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>See CRYPTO_BUFF_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_BUFF_CTL</name>
          <description>DMA controller buffer control</description>
          <addressOffset>0x680</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>See CRYPTO_BUFF_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_MS0_BUFF_CTL</name>
          <description>External master 0 buffer control</description>
          <addressOffset>0x700</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>See CRYPTO_BUFF_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_MS1_BUFF_CTL</name>
          <description>External master 1 buffer control</description>
          <addressOffset>0x780</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>See CRYPTO_BUFF_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <name>FM_CTL</name>
          <description>Flash Macro Registers</description>
          <addressOffset>0x0000F000</addressOffset>
          <register>
            <name>FM_CTL</name>
            <description>Flash macro control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x37F030F</resetMask>
            <fields>
              <field>
                <name>FM_MODE</name>
                <description>N/A</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FM_SEQ</name>
                <description>N/A</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DAA_MUX_SEL</name>
                <description>N/A</description>
                <bitRange>[22:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IF_SEL</name>
                <description>N/A</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WR_EN</name>
                <description>0: normal mode
1: Fm Write Enable
Set to enable flash writes. Note: IF_SEL and WR_EN cannot be changed at the same time</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Status</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x1800</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMER_ENABLED</name>
                <description>This is the timer_en bit set by writing a '1' in the TIMER_CTL bit 31. It is reset by HW when the timer expires
0: timer not running
1: Timer is enabled and not expired yet</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HV_REGS_ISOLATED</name>
                <description>Indicates the isolation status at HV trim and redundancy registers inputs
0: Not isolated, writing permitted
1: isolated writing disabled</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ILLEGAL_HVOP</name>
                <description>Indicates a bulk, sector erase, program has been requested when axa=1
0: no error
1: illegal HV operation error</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TURBO_N</name>
                <description>After FM power up indicates the analog blocks currents are boosted to faster reach their functional state.. 
Used in the testchip boot only as an 'FM READY' flag.  
0: turbo mode 
1: normal mode</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WR_EN_MON</name>
                <description>FM_CTL.WR_EN bit after being synchronized in clk_r domain</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IF_SEL_MON</name>
                <description>FM_CTL.IF_SEL bit after being synchronized in clk_r domain</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TIMER_STATUS</name>
                <description>The actual timer state sync-ed in clk_c domain:
0: timer is not running:
1: timer is running;</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>R_GRANT_DELAY_STATUS</name>
                <description>0: R_GRANT_DELAY timer is not running
1: R_GRANT_DELAY timer is running</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FM_BUSY</name>
                <description>0': FM not busy 
1: FM BUSY : R_GRANT is 0 as result of a busy request from FM ready, or from HV operations.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FM_READY</name>
                <description>0: FM not ready
1: FM ready</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>POS_PUMP_VLO</name>
                <description>POS pump VLO</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NEG_PUMP_VHI</name>
                <description>NEG pump VHI</description>
                <bitRange>[11:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RWW</name>
                <description>FM Type  (Read While Write or Not Read While Write):
0: Non RWW FM Type
1:  RWW FM Type</description>
                <bitRange>[12:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MAX_DOUT_WIDTH</name>
                <description>Internal memory core max data out size 
(number of data out bits per column):
0: x128 bits
1: x256 bits</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SECTOR0_SR</name>
                <description>0:  Sector 0 does not contain special rows. The special rows are located in separate special sectors.
1:  Sector 0 contains special rows</description>
                <bitRange>[14:14]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RESET_MM</name>
                <description>Test_only, internal node: mpcon  reset_mm</description>
                <bitRange>[15:15]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ROW_ODD</name>
                <description>Test_only, internal node: mpcon  row_odd</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ROW_EVEN</name>
                <description>Test_only, internal node: mpcon  row_even</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HVOP_SUB_SECTOR_N</name>
                <description>Test_only, internal node: mpcon  bk_subb</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HVOP_SECTOR</name>
                <description>Test_only, internal node: mpcon  bk_sec</description>
                <bitRange>[19:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HVOP_BULK_ALL</name>
                <description>Test_only, internal node: mpcon  bk_all</description>
                <bitRange>[20:20]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CBUS_RA_MATCH</name>
                <description>Test_only, internal node: mpcon  ra match</description>
                <bitRange>[21:21]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CBUS_RED_ROW_EN</name>
                <description>Test_only, internal node: mpcon  red_row_en</description>
                <bitRange>[22:22]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RQ_ERROR</name>
                <description>Test_only, internal node:  rq_error  sync-de in clk_c domain</description>
                <bitRange>[23:23]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PUMP_PDAC</name>
                <description>Test_only, internal node: regif pdac outputs to pos pump</description>
                <bitRange>[27:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PUMP_NDAC</name>
                <description>Test_only, internal node: regif ndac outputs to pos pump</description>
                <bitRange>[31:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FM_ADDR</name>
            <description>Flash macro address</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FFFFFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Row address.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BA</name>
                <description>Bank address.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AXA</name>
                <description>Auxiliary address field:
0: regular flash memory.
1: supervisory flash memory.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BOOKMARK</name>
            <description>Bookmark register - keeps the current FW HV seq</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BOOKMARK</name>
                <description>Used by FW. Keeps the Current HV cycle sequence</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GEOMETRY</name>
            <description>Regular flash geometry</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ROW_COUNT</name>
                <description>Number of rows (minus 1):
0: 1 row
1: 2 rows
2: 3 rows
...
'65535': 65536 rows</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BANK_COUNT</name>
                <description>Number of banks (minus 1):
0: 1 bank
1: 2 banks
...
'255': 256 banks</description>
                <bitRange>[23:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WORD_SIZE_LOG2</name>
                <description>Number of Bytes per word (log 2). A word is defined as the data that is read from the flash macro over the R interface with a single read access:
0: 1 Byte
1: 2 Bytes
2: 4 Bytes
...
3: 128 Bytes

The currently planned flash macros have a word size of either 32-bit, 64-bit or 128-bit, resulting in WORD_SIZE_LOG2 settings of 2, 3 and 4 respectively.</description>
                <bitRange>[27:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PAGE_SIZE_LOG2</name>
                <description>Number of Bytes per page (log 2):
0: 1 Byte
1: 2 Bytes
2: 4 Bytes
...
15: 32768 Bytes

The currently planned flash macros have a page size of either 256 Byte or 512 Byte, resulting in PAGE_SIZE_LOG2 settings of 8 and 9 respectively.</description>
                <bitRange>[31:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GEOMETRY_SUPERVISORY</name>
            <description>Supervisory flash geometry</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ROW_COUNT</name>
                <description>Number of rows (minus 1). ROW_COUNT is typically less than GEOMETRY.ROW_COUNT</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BANK_COUNT</name>
                <description>Number of banks (minus 1). BANK_COUNT is less or equal to GEOMETRY.BANK_COUNT.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WORD_SIZE_LOG2</name>
                <description>Number of Bytes per word (log 2). See GEOMETRY.WORD_SIZE_LOG2. Typically, WORD_SIZE_LOG2 equals GEOMETRY.WORD_SIZE_LOG2.</description>
                <bitRange>[27:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PAGE_SIZE_LOG2</name>
                <description>Number of Bytes per page (log 2). See GEOMETRY.PAGE_SIZE_LOG2. Typically, PAGE_SIZE_LOG2 equals GEOMETRY.PAGE_SIZE_LOG2.</description>
                <bitRange>[31:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ANA_CTL0</name>
            <description>Analog control 0</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x400</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MDAC</name>
                <description>Trimming of the output margin Voltage as a function of Vpos and Vneg.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CSLDAC</name>
                <description>Trimming of common source line DAC.</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLIP_AMUXBUS_AB</name>
                <description>Flips amuxbusa and amuxbusb 
0: amuxbusa, amuxbusb
1:  amuxbusb, amuxbusb</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NDAC_MIN</name>
                <description>NDAC staircase min value</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PDAC_MIN</name>
                <description>PDAC staircase min value</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_PRG_SEQ01</name>
                <description>PROG&amp;PRE_PROG: Scale for R_GRANT_DELAY on seq0-seq1 transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_PRG_SEQ12</name>
                <description>PROG&amp;PRE_PROG: Scale for R_GRANT_DELAY on seq1-seq2 transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[23:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_PRG_SEQ23</name>
                <description>PROG&amp;PRE_PROG: Scale for R_GRANT_DELAY on seq2-seq3 transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_SEQ30</name>
                <description>PROG&amp;PRE_PROG&amp; ERASE: Scale for R_GRANT_DELAY on seq3-seq0 transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[27:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_PRG_PEON</name>
                <description>PROG&amp;PRE_PROG: Scale for R_GRANT_DELAY on PE On transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_PRG_PEOFF</name>
                <description>PROG&amp;PRE_PROG: Scale for R_GRANT_DELAY on PE OFF transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ANA_CTL1</name>
            <description>Analog control 1</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xD32FAFA</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>NDAC_MAX</name>
                <description>Ndac Max Value.Trimming of negative pump output Voltage.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NDAC_STEP</name>
                <description>Ndac step increment</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PDAC_MAX</name>
                <description>Pdac Max Value.Trimming of positive pump output Voltage:</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PDAC_STEP</name>
                <description>Pdac step increment</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NPDAC_STEP_TIME</name>
                <description>Ndac/Pdac step duration: (1uS .. 255uS) * 8
When = 0 N/PDAC_MAX control the pumps</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NPDAC_ZERO_TIME</name>
                <description>Ndac/Pdac LO duration: (1uS .. 255uS) * 8
When 0, N/PDAC don't return to 0</description>
                <bitRange>[31:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WAIT_CTL</name>
            <description>Wait State control</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x30B09</resetValue>
            <resetMask>0x3F070F0F</resetMask>
            <fields>
              <field>
                <name>WAIT_FM_MEM_RD</name>
                <description>Number of C interface wait cycles (on 'clk_c') for a read from the memory</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WAIT_FM_HV_RD</name>
                <description>Number of C interface wait cycles (on 'clk_c') for a read from the high Voltage page latches.
Common for reading HV Page Latches and the DATA_COMP_RESULT bit</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WAIT_FM_HV_WR</name>
                <description>Number of C interface wait cycles (on 'clk_c') for a write to the high Voltage page latches.</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FM_RWW_MODE</name>
                <description>00: Full CBUS MODE
01: RWW
10: RWW. R_GRANT is stalling r_bus for the whole program/erase duration</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LV_SPARE_1</name>
                <description>Spare register</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRMM</name>
                <description>0: Normal
1: Test mode to enable Margin mode for 2 rows at a time</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MBA</name>
                <description>0: Normal
1: Test mode to enable Master Bulk Access which allows both normal rows and redundant rows to be erased / programmed in one HV cycle (Bulk / Sector Erase and Sector Program).</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PL_SOFT_SET_EN</name>
                <description>Page latch soft set enable, 0 = disabled, 1 = enabled (at end of seq_2), taken care in API</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIMER_CLK_CTL</name>
            <description>Timer prescaler (clk_t to timer clock frequency divider)</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x8</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMER_CLOCK_FREQ</name>
                <description>Clk_t frequency divider to provide the 1MHz reference clock for the Regif Timer.
Equal to the frequency in MHz of the timer clock 'clk_t'.
Example: if 'clk_t' has a frequency of 4 MHz then this field value is '4'
Max clk_t frequency = 100MHz.
This field is updated at runtime with the  'SW_TIMER_CLOCK_FREQ ' value from the HV parameters table</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_PRG_PEON</name>
                <description>PROG&amp;PRE_PROG: R-grant blocking delay on PE ON. Scale = ANA_CTL0.SCALE_PEON
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_PRG_PEOFF</name>
                <description>PROG&amp;PRE_PROG: R-grant blocking delay on PE OFF. Scale = ANA_CTL0.SCALE_PEOFF
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_PRG_SEQ01</name>
                <description>PROG&amp;PRE_PROG: R-grant blocking delay on seq0-seq1 transition. Scale = ANA_CTL0.SCALE_SEQ01
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[31:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIMER_CTL</name>
            <description>Timer control</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x4000001</resetValue>
            <resetMask>0xE700FFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Timer period in either microseconds (SCALE is '0') or 100's of microseconds (SCALE is '1') multiples.</description>
                <bitRange>[14:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE</name>
                <description>Timer tick scale:
0: 1 microsecond.
1: 100 microseconds.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_SEQUENCE</name>
                <description>1': Starts1 the HV automatic sequencing 
Cleared by HW</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRE_PROG</name>
                <description>1 during pre-program operation</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRE_PROG_CSL</name>
                <description>0: CSL lines driven by CSL_DAC
1: CSL lines driven by VNEG_G</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PUMP_EN</name>
                <description>Pump enable:
0: disabled
1: enabled (also requires FM_CTL.IF_SEL to be'1', this additional restriction is required to prevent non intentional clearing of the FM).
SW sets this field to '1' to generate a single PE pulse. 
HW clears this field when timer is expired.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ACLK_EN</name>
                <description>ACLK enable (generates a single cycle pulse for the FM):
0: disabled
1: enabled. SW set this field to '1' to generate a single cycle pulse. HW sets this field to '0' when the pulse is generated.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMER_EN</name>
                <description>Timer enable:
0: disabled
1: enabled. SW sets this field to '1' to start the timer. HW sets this field to '0' when the timer is expired.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ACLK_CTL</name>
            <description>MPCON clock</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>ACLK_GEN</name>
                <description>A write to this register generates the clock pulse for HV control registers (mpcon outputs)</description>
                <bitRange>[0:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>TIMER_EXPIRED</name>
                <description>Set to '1', when event is detected. Write INTR field with '1', to clear bit. Write INTR_SET field with '1', to set bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>TIMER_EXPIRED</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>TIMER_EXPIRED</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0x4C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>TIMER_EXPIRED</name>
                <description>Logical and of corresponding request and mask fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL0</name>
            <description>Cal control BG LO trim bits</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x38F8F</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>VCT_TRIM_LO_HV</name>
                <description>LO Bandgap Voltage Temperature Compensation trim control.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CDAC_LO_HV</name>
                <description>LO Temperature compensated trim DAC. To control Vcstat slope for Vpos.</description>
                <bitRange>[7:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VBG_TRIM_LO_HV</name>
                <description>LO Bandgap Voltage trim control.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VBG_TC_TRIM_LO_HV</name>
                <description>LO Bandgap Voltage Temperature Compensation trim control</description>
                <bitRange>[15:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ICREF_TC_TRIM_LO_HV</name>
                <description>LO Bandgap Current Temperature Compensation trim control</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IPREF_TRIMA_LO_HV</name>
                <description>Adds 100-150nA boost on IPREF_LO</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL1</name>
            <description>Cal control BG HI trim bits</description>
            <addressOffset>0x54</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x38F8F</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>VCT_TRIM_HI_HV</name>
                <description>HI Bandgap Voltage Temperature Compensation trim control.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CDAC_HI_HV</name>
                <description>HI Temperature compensated trim DAC. To control Vcstat slope for Vpos.</description>
                <bitRange>[7:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VBG_TRIM_HI_HV</name>
                <description>HI Bandgap Voltage trim control.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VBG_TC_TRIM_HI_HV</name>
                <description>HI Bandgap Voltage Temperature Compensation trim control.</description>
                <bitRange>[15:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ICREF_TC_TRIM_HI_HV</name>
                <description>HI Bandgap Current Temperature Compensation trim control.</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IPREF_TRIMA_HI_HV</name>
                <description>Adds 100-150nA boost on IPREF_HI</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL2</name>
            <description>Cal control BG LO&amp;HI trim bits</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x7BE10</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>ICREF_TRIM_LO_HV</name>
                <description>LO Bandgap Current  trim control.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ICREF_TRIM_HI_HV</name>
                <description>HI Bandgap Current  trim control.</description>
                <bitRange>[9:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IPREF_TRIM_LO_HV</name>
                <description>LO Bandgap IPTAT trim control.</description>
                <bitRange>[14:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IPREF_TRIM_HI_HV</name>
                <description>HI  Bandgap IPTAT trim control.</description>
                <bitRange>[19:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL3</name>
            <description>Cal control osc trim bits, idac, sdac, itim</description>
            <addressOffset>0x5C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2004</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>OSC_TRIM_HV</name>
                <description>Flash macro pump clock trim control.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OSC_RANGE_TRIM_HV</name>
                <description>0: Oscillator High Frequency Range
1: Oscillator Low Frequency range</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VPROT_ACT_HV</name>
                <description>Forces VPROT in active mode all the time</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IPREF_TC_HV</name>
                <description>0: Increases the IPREF Tempco by subtracting ICREF from IPREF - IPREF internal will be 0.5uA
1: Reduces the IPREF Tempco without subtracting ICREF from IPREF - IPREF internal will be 1uA</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL_HV</name>
                <description>Voltage reference:
0: internal bandgap reference
1: external voltage reference</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IREF_SEL_HV</name>
                <description>Current reference:
0: internal current reference
1: external current reference</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>REG_ACT_HV</name>
                <description>0: VBST regulator will operate in active/standby mode based on control signal.
1: Forces the VBST regulator in active mode all the time</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FDIV_TRIM_HV</name>
                <description>FDIV_TRIM_HV[1:0]: Assuming oscillator frequency of 8MHz in standby.
Following are the clock frequencies seen by doubler
00: F = 1MHz 
01: F = 0.5MHz 
10: F = 2MHz
11: F = 4MHz</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VDDHI_HV</name>
                <description>0: vdd &lt; 2.3V 
1: vdd &gt;= 2.3V
'0' setting can used for vdd &gt; 2.3V also, but with a current penalty.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TURBO_PULSEW_HV</name>
                <description>Turbo pulse width trim (Typical)
00: 40 us
01: 20 us
10: 15 us 
11: 8 us</description>
                <bitRange>[14:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BGLO_EN_HV</name>
                <description>0: Normal (Automatic change over from HI to LO)
1: Force enable LO Bandgap</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BGHI_EN_HV</name>
                <description>0: Normal (Automatic change over from HI to LO)
1: Force enable HI Bandgap 
When both BGLO_EN_HV and BGHI_EN_HV are HIGH, only BGHI output is used and turbo_hv_n pulse is active</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CL_ISO_DIS_HV</name>
                <description>0: The internal logic controls the CL isolation
1: Forces CL bypass</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>R_GRANT_EN_HV</name>
                <description>0: r_grant handshake disabled, r_grant always 1.
1: r_grand handshake  enabled</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LP_ULP_SW_HV</name>
                <description>LP&lt;--&gt;ULP switch for trim signals:
0: LP
1: ULP</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL4</name>
            <description>Cal Control Vlim, SA, fdiv, reg_act</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x12AE0</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>VLIM_TRIM_ULP_HV</name>
                <description>VLIM_TRIM[1:0]: 
00: V2 = 650mV
01: V2 = 600mV
10: V2 = 750mV
11: V2 = 700mV</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IDAC_ULP_HV</name>
                <description>Sets the sense current reference offset value. Refer to trim tables for details.</description>
                <bitRange>[5:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SDAC_ULP_HV</name>
                <description>Sets the sense current reference temp slope. Refer to trim tables for details.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ITIM_ULP_HV</name>
                <description>Trimming of timing current</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FM_READY_DEL_ULP_HV</name>
                <description>00: Default : delay 1ns
01: Delayed by 1.5us
10: Delayed by 2.0us
11: Delayed by 2.5us</description>
                <bitRange>[14:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE451_ULP_HV</name>
                <description>N/A</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>READY_RESTART_N_HV</name>
                <description>Toggle: 1--&gt;0, ready goes low, ready will remain low as long as the bit is low. Toggle the bit back to 1 to activate the ready logic. To be used by API only.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VBST_S_DIS_HV</name>
                <description>0: VBST_S voltage for each sector to allow VBST level to be dropped to VCC during Erase in the selected sector, reducing coupling to GBL. 
1: VBST_S voltage for each sector stays at VBST level during Erase in the selected sector.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_HVPULSE_HV</name>
                <description>0: HV Pulse controlled by FW
1: HV Pulse controlled by Hardware</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>UGB_EN_HV</name>
                <description>UGB enable in TM control</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL5</name>
            <description>Cal control</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2AE0</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>VLIM_TRIM_LP_HV</name>
                <description>VLIM_TRIM[1:0]: 
00: V2 = 650mV
01: V2 = 600mV
10: V2 = 750mV
11: V2 = 700mV</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IDAC_LP_HV</name>
                <description>Sets the sense current reference offset value. Refer to trim tables for details.</description>
                <bitRange>[5:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SDAC_LP_HV</name>
                <description>Sets the sense current reference temp slope. Refer to trim tables for details.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ITIM_LP_HV</name>
                <description>Trimming of timing current</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FM_READY_DEL_LP_HV</name>
                <description>00: Delayed by 1us
01: Delayed by 1.5us
10: Delayed by 2.0us
11: Delayed by 2.5us</description>
                <bitRange>[14:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE451_LP_HV</name>
                <description>N/A</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE52_HV</name>
                <description>N/A</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AMUX_SEL_HV</name>
                <description>Amux Select in AMUX_UGB
00: Bypass UGB for both amuxbusa and amuxbusb
01: Bypass UGB for amuxbusb while passing amuxbusa through UGB.
10: Bypass UGB for amuxbusa while passing amuxbusb through UGB.
11: UGB Calibrate mode</description>
                <bitRange>[19:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL6</name>
            <description>SA trim LP/ULP</description>
            <addressOffset>0x68</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x36F7F</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>SA_CTL_TRIM_T1_ULP_HV</name>
                <description>clk_trk delay</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T4_ULP_HV</name>
                <description>SA_CTL_TRIM_T4_ULP_HV&lt;2&gt;= eqi (eq current trim)
SA_CTL_TRIM_T4_ULP_HV&lt;1:0&gt; = eqc (eq cap trim)</description>
                <bitRange>[3:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T5_ULP_HV</name>
                <description>SA_CTL_TRIM_T5_ULP_HV&lt;2&gt;= evi (integration current trim)
SA_CTL_TRIM_T5_ULP_HV&lt;1:0&gt; = evc (integration cap trim)</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T6_ULP_HV</name>
                <description>SA_CTL_TRIM_T6_ULP_HV&lt;1&gt;= eni (enable current trim)
SA_CTL_TRIM_T6_ULP_HV&lt;0&gt; = ecn (enable cap trim)</description>
                <bitRange>[8:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T8_ULP_HV</name>
                <description>saen3 pulse width trim (Current trim)</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T1_LP_HV</name>
                <description>clk_trk delay</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T4_LP_HV</name>
                <description>SA_CTL_TRIM_T4_LP_HV&lt;2&gt;= eqi (eq current trim)
SA_CTL_TRIM_T4_LP_HV&lt;1:0&gt; = eqc (eq cap trim)</description>
                <bitRange>[13:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T5_LP_HV</name>
                <description>SA_CTL_TRIM_T5_LP_HV&lt;2&gt;= evi (integration current trim)
SA_CTL_TRIM_T5_LP_HV&lt;1:0&gt; = evc (integration cap trim)</description>
                <bitRange>[16:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T6_LP_HV</name>
                <description>SA_CTL_TRIM_T6_LP_HV&lt;1&gt;= eni (enable current trim)
SA_CTL_TRIM_T6_LP_HV&lt;0&gt; = ecn (enable cap trim)</description>
                <bitRange>[18:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T8_LP_HV</name>
                <description>saen3 pulse width trim (Current trim)</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL7</name>
            <description>Cal control</description>
            <addressOffset>0x6C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>ERSX8_CLK_SEL_HV</name>
                <description>Clock frequency into the ersx8 shift register block 
00: Oscillator clock
01: Oscillator clock / 2
10: Oscillator clock / 4
11: Oscillator clock</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FM_ACTIVE_HV</name>
                <description>0: Normal operation
1: Forces FM SYS in active mode</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TURBO_EXT_HV</name>
                <description>0: Normal operation
1: Uses external turbo pulse</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NPDAC_HWCTL_DIS_HV</name>
                <description>0': ndac, pdac staircase hardware controlled
1: ndac, pdac staircase disabled. Enables FW control.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FM_READY_DIS_HV</name>
                <description>0': fm ready is enabled 
1: fm ready is disabled (fm_ready is always '1')</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERSX8_EN_ALL_HV</name>
                <description>0': Staggered turn on/off of GWL
1: GWL are turned on/off at the same time (old FM legacy)</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLE_LOAD_ONCE_HV</name>
                <description>0: Load common HV params during API HV operations depends on the HV_PARAMS_LOADED bit in RGRANT_DELAY_PRG register.
1: All HV params are loaded during every API HV operation irrespective of HV_PARAMS_LOADED bit in the RGRANT_DELAY_PRG register.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE7_HV</name>
                <description>N/A</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE7_ULP_HV</name>
                <description>N/A</description>
                <bitRange>[14:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE7_LP_HV</name>
                <description>N/A</description>
                <bitRange>[19:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RED_CTL01</name>
            <description>Redundancy Control normal sectors 0,1</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>RED_ADDR_0</name>
                <description>Bad Row Pair Address for Sector 0</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_0</name>
                <description>1: Redundancy Enable for Sector 0</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_ADDR_1</name>
                <description>Bad Row Pair Address for Sector 1</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_1</name>
                <description>1: Redundancy Enable for Sector 1</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RED_CTL23</name>
            <description>Redundancy Control normal sectors 2,3</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>RED_ADDR_2</name>
                <description>Bad Row Pair Address for Sector 2</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_2</name>
                <description>1: Redundancy Enable for Sector 2</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_ADDR_3</name>
                <description>Bad Row Pair Address for Sector 3</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_3</name>
                <description>1: Redundancy Enable for Sector 3</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RED_CTL45</name>
            <description>Redundancy Control normal sectors 4,5</description>
            <addressOffset>0x88</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>RED_ADDR_4</name>
                <description>Bad Row Pair Address for Sector 4</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_4</name>
                <description>1: Redundancy Enable for Sector 4</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_ADDR_5</name>
                <description>Bad Row Pair Address for Sector 5</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_5</name>
                <description>1: Redundancy Enable for Sector 5</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RED_CTL67</name>
            <description>Redundancy Control normal sectors 6,7</description>
            <addressOffset>0x8C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>RED_ADDR_6</name>
                <description>Bad Row Pair Address for Sector 6</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_6</name>
                <description>1: Redundancy Enable for Sector 6</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_ADDR_7</name>
                <description>Bad Row Pair Address for Sector 7</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_7</name>
                <description>1: Redundancy Enable for Sector 7</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RED_CTL_SM01</name>
            <description>Redundancy Control special sectors 0,1</description>
            <addressOffset>0x90</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>RED_ADDR_SM0</name>
                <description>Bad Row Pair Address for Special Sector 0</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_SM0</name>
                <description>Redundancy Enable for Special Sector 0</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_ADDR_SM1</name>
                <description>Bad Row Pair Address for Special Sector 1</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_SM1</name>
                <description>Redundancy Enable for Special Sector 1</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RGRANT_DELAY_PRG</name>
            <description>R-grant delay for program</description>
            <addressOffset>0x98</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1000000</resetValue>
            <resetMask>0x8FFFFFFF</resetMask>
            <fields>
              <field>
                <name>RGRANT_DELAY_PRG_SEQ12</name>
                <description>PROG&amp;PRE_PROG: R-grant blocking delay on seq1-seq2 transition. Scale = ANA_CTL0.SCALE_SEQ12
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_PRG_SEQ23</name>
                <description>PROG&amp;PRE_PROG: R-grant blocking delay on seq2-seq3 transition. Scale = ANA_CTL0.SCALE_SEQ23
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_SEQ30</name>
                <description>PROG&amp;PRE_PROG &amp; ERASE: R-grant blocking delay on seq3-seq0 transition. Scale = ANA_CTL0.SCALE_SEQ30
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_CLK</name>
                <description>Frequency divider from clk_t  to create the 8MHz reference clock for R_grant delay
The value of this field is the integer result of 'clk_t frequency / 8'.
Example: for clk_t=100 this field is INT(100/8) =12.
This field is updated at runtime with the  'SW_RGRANT_DELAY_CLK ' value from the HV parameters table</description>
                <bitRange>[27:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HV_PARAMS_LOADED</name>
                <description>0: HV Pulse common params not loaded
1: HV Pulse common params  loaded: r-grant delays, r-grant scale, prescaler, timer values for seq1,seq2_pre, seq2_post, seq3</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PW_SEQ12</name>
            <description>HV Pulse Delay for seq 1&amp;2 pre</description>
            <addressOffset>0xA0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PW_SEQ1</name>
                <description>Seq1 delay</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PW_SEQ2_PRE</name>
                <description>Seq2 pre delay</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PW_SEQ23</name>
            <description>HV Pulse Delay for seq2 post &amp; seq3</description>
            <addressOffset>0xA4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PW_SEQ2_POST</name>
                <description>Seq2 post  delay</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PW_SEQ3</name>
                <description>Seq3 delay</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RGRANT_SCALE_ERS</name>
            <description>R-grant delay scale for erase</description>
            <addressOffset>0xA8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF03FF</resetMask>
            <fields>
              <field>
                <name>SCALE_ERS_SEQ01</name>
                <description>ERASE: Scale for R_GRANT_DELAY on seq0-seq1 transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_ERS_SEQ12</name>
                <description>ERASE: Scale for R_GRANT_DELAY on seq1-seq2 transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_ERS_SEQ23</name>
                <description>ERASE: Scale for R_GRANT_DELAY on seq2-seq3 transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_ERS_PEON</name>
                <description>ERASE: Scale for R_GRANT_DELAY on PE On transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_ERS_PEOFF</name>
                <description>ERASE: Scale for R_GRANT_DELAY on PE OFF transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_ERS_PEON</name>
                <description>ERASE: R-grant blocking delay on PE ON. Scale = ANA_CTL0.SCALE_PEON
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_ERS_PEOFF</name>
                <description>ERASE: R-grant blocking delay on PE OFF. Scale = ANA_CTL0.SCALE_PEOFF
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[31:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RGRANT_DELAY_ERS</name>
            <description>R-grant delay for erase</description>
            <addressOffset>0xAC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFF</resetMask>
            <fields>
              <field>
                <name>RGRANT_DELAY_ERS_SEQ01</name>
                <description>ERASE: R-grant blocking delay on seq0-seq1 transition. Scale = ANA_CTL0.SCALE_SEQ01
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_ERS_SEQ12</name>
                <description>ERASE: R-grant blocking delay on seq1-seq2 transition. Scale = ANA_CTL0.SCALE_SEQ12
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_ERS_SEQ23</name>
                <description>ERASE: R-grant blocking delay on seq2-seq3 transition. Scale = ANA_CTL0.SCALE_SEQ23
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FM_PL_WRDATA_ALL</name>
            <description>Flash macro write page latches all</description>
            <addressOffset>0x7FC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA32</name>
                <description>Write all high Voltage page latches with the same 32-bit data in a single write cycle
Read always returns 0.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>FM_PL_DATA[%s]</name>
            <description>Flash macro Page Latches data</description>
            <addressOffset>0x800</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA32</name>
                <description>Four page latch Bytes 
When reading the page latches it requires FM_CTL.IF_SEL to be '1'
Note: the high Voltage page latches are readable for test mode functionality.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>FM_MEM_DATA[%s]</name>
            <description>Flash macro memory sense amplifier and column decoder data</description>
            <addressOffset>0xC00</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA32</name>
                <description>Sense amplifier and column multiplexer structure Bytes. The read data is dependent on FM_CTL.IF_SEL:
- IF_SEL is 0: data as specified by the R interface address
- IF_SEL is 1: data as specified by FM_MEM_ADDR and the offset of the accessed FM_MEM_DATA register.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>SRSS</name>
      <description>SRSS Core Registers</description>
      <baseAddress>0x40260000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PWR_CTL</name>
          <description>Power Mode Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFC0033</resetMask>
          <fields>
            <field>
              <name>POWER_MODE</name>
              <description>Current power mode of the device.  Note that this field cannot be read in all power modes on actual silicon.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>System is resetting.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACTIVE</name>
                  <description>At least one CPU is running.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLEEP</name>
                  <description>No CPUs are running.  Peripherals may be running.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DEEPSLEEP</name>
                  <description>Main high-frequency clock is off; low speed clocks are available.  Communication interface clocks may be present.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEBUG_SESSION</name>
              <description>Indicates whether a debug session is active (CDBGPWRUPREQ signal is 1)</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_SESSION</name>
                  <description>No debug session active</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SESSION_ACTIVE</name>
                  <description>Debug session is active.  Power modes behave differently to keep the debug session active, and current consumption may be higher than datasheet specification.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPM_READY</name>
              <description>Indicates whether certain low power functions are ready.  The low current circuits take longer to startup after XRES/POR/BOD/HIBERNATE wakeup than the normal mode circuits.  HIBERNATE mode may be entered regardless of this bit.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: If a low power circuit operation is requested, it will stay in its normal operating mode until it is ready.  If DEEPSLEEP is requested by all processors WFI/WFE, the device will instead enter SLEEP.  When low power circuits are ready, device will automatically enter the originally requested mode.
1: Normal operation.  DEEPSLEEP and low power circuits operate as requested in other registers.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IREF_LPMODE</name>
              <description>Control the power mode of the reference current generator.  The value in this register is ignored and normal mode is used until LPM_READY==1.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: Current reference generator operates in normal mode.
1: Current reference generator operates in low power mode.  Response time is reduced to save current.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VREFBUF_OK</name>
              <description>Indicates that the voltage reference buffer is ready.  Due to synchronization delays, it may take two IMO clock cycles for hardware to clear this bit after asserting VREFBUF_DIS=1.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPSLP_REG_DIS</name>
              <description>Disable the DeepSleep regulator.  This is only legal when the on-chip buck regulator supplies vccd, but there is no hardware protection for this case.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: DeepSleep Regulator is on.
1: DeepSleep Regulator is off.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RET_REG_DIS</name>
              <description>Disable the Retention regulator.  This is only legal when the on-chip buck regulator supplies vccd, but there is no hardware protection for this case.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: Retention Regulator is on.
1: Retention Regulator is off.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NWELL_REG_DIS</name>
              <description>Disable the Nwell regulator.  This is only legal when the on-chip buck regulator supplies vccd, but there is no hardware protection for this case.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: Nwell Regulator is on.
1: Nwell Regulator is off.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LINREG_DIS</name>
              <description>Disable the linear Core Regulator.  This is only legal when the on-chip buck regulator supplies vccd, but there is no hardware protection for this case.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: Linear regulator is on.
1: Linear regulator is off.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LINREG_LPMODE</name>
              <description>Control the power mode of the Linear Regulator.  The value in this register is ignored and normal mode is used until LPM_READY==1.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: Linear Regulator operates in normal mode.
1: Linear Regulator operates in low power mode.  Load current capability is reduced, and firmware must ensure the current is kept within the limit for this operating mode.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PORBOD_LPMODE</name>
              <description>Control the power mode of the POR/BOD circuits.  The value in this register is ignored and normal mode is used until LPM_READY==1.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: POR/BOD circuits operate in normal mode.
1: POR/BOD circuits operate in low power mode.  Response time is reduced to save current.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BGREF_LPMODE</name>
              <description>Control the power mode of the Bandgap Voltage and Current References.  This applies to voltage and current generation and is different than the reference voltage buffer.  The value in this register is ignored and normal mode is used until LPM_READY==1.  When lower power mode is used, the Active Reference circuit can be disabled to reduce current.  Firmware is responsible to ensure ACT_REF_OK==1 before changing back to normal mode.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: Active Bandgap Voltage and Current Reference operates in normal mode.
1: Active Bandgap Voltage and Current Reference operates in low power mode.  Power supply rejection is reduced to save current.  The Active Reference may be disabled using ACT_REF_DIS=0.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_LS_BYPASS</name>
              <description>Bypass level shifter inside the PLL.  
0: Do not bypass the level shifter.  This setting is ok for all operational modes and vccd target voltage.
1: Bypass the level shifter.  This may reduce jitter on the PLL output clock, but can only be used when vccd is targeted to 1.1V nominal.  Otherwise, it can result in clock degradation and static current.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VREFBUF_LPMODE</name>
              <description>Control the power mode of the 800mV voltage reference buffer.  The value in this register is ignored and normal mode is used until LPM_READY==1.
0: Voltage Reference Buffer operates in normal mode. This register is only reset by XRES/POR/BOD/HIBERNATE.
1: Voltage Reference Buffer operates in low power mode.  Power supply rejection is reduced to save current.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VREFBUF_DIS</name>
              <description>Disable the 800mV voltage reference buffer.  Firmware should only disable the buffer when there is no connected circuit that is using it.  SRSS circuits that require it are the PLL and ECO.  A particular product may have circuits outside the SRSS that use the buffer.  This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_REF_DIS</name>
              <description>Disables the Active Reference.  Firmware must ensure that LPM_READY==1 and BGREF_LPMODE==1 for at least 1us before disabling the Active Reference.  When enabling the Active Reference, use ACT_REF_OK indicator to know when it is ready.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: Active Reference is enabled
1: Active Reference is disabled</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_REF_OK</name>
              <description>Indicates that the normal mode of the Active Reference is ready.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_HIBERNATE</name>
          <description>HIBERNATE Mode Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCFFEFFFF</resetMask>
          <fields>
            <field>
              <name>TOKEN</name>
              <description>Contains a 8-bit token that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware to differentiate WAKEUP from a general RESET event.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNLOCK</name>
              <description>This byte must be set to 0x3A for FREEZE or HIBERNATE fields to operate.  Any other value in this register will cause FREEZE/HIBERNATE to have no effect, except as noted in the FREEZE description.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>Controls whether mode and state of GPIOs and SIOs in the system are frozen.  This is intended to be used as part of the HIBERNATE entry and exit sequences.  When entering HIBERNATE mode, the first write instructs DEEPSLEEP peripherals that they cannot ignore the upcoming freeze command.  This occurs even in the illegal condition where UNLOCK is not set.  If UNLOCK and HIBERNATE are properly set, the IOs actually freeze on the second write.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_HIBALARM</name>
              <description>When set, HIBERNATE will wakeup for a RTC interrupt</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_HIBWDT</name>
              <description>When set, HIBERNATE will wakeup if WDT matches</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY_HIBPIN</name>
              <description>Each bit sets the active polarity of the corresponding wakeup pin.
0: Pin input of 0 will wakeup the part from HIBERNATE
1: Pin input of 1 will wakeup the part from HIBERNATE</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_HIBPIN</name>
              <description>When set, HIBERNATE will wakeup if the corresponding pin input matches the POLARITY_HIBPIN setting.  Each bit corresponds to one of the HIBERNATE wakeup pins.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIBERNATE_DISABLE</name>
              <description>Hibernate disable bit.
0: Normal operation, HIBERNATE works as described
1: Further writes to this register are ignored
Note: This bit is a write-once bit until the next reset.  Avoid changing any other bits in this register while disabling HIBERNATE mode.  Also, it is recommended to clear the UNLOCK code, if it was previously written..</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIBERNATE</name>
              <description>Firmware sets this bit to enter HIBERNATE mode.  The system will enter HIBERNATE mode immediately after writing to this bit and will wakeup only in response to XRES or WAKEUP event.  Both UNLOCK and FREEZE must have been set correctly in a previous write operations.  Otherwise, it will not enter HIBERNATE.  External supplies must have been stable for 250us before entering HIBERNATE mode.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_LVD_CTL</name>
          <description>Low Voltage Detector (LVD) Configuration Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>HVLVD1_TRIPSEL</name>
              <description>Threshold selection for HVLVD1.  Disable the LVD (HVLVD1_EN=0) before changing the threshold.
0: rise=1.225V (nom), fall=1.2V (nom)
1: rise=1.425V (nom), fall=1.4V (nom)
2: rise=1.625V (nom), fall=1.6V (nom)
3: rise=1.825V (nom), fall=1.8V (nom)
4: rise=2.025V (nom), fall=2V (nom)
5: rise=2.125V (nom), fall=2.1V (nom)
6: rise=2.225V (nom), fall=2.2V (nom)
7: rise=2.325V (nom), fall=2.3V (nom)
8: rise=2.425V (nom), fall=2.4V (nom)
9: rise=2.525V (nom), fall=2.5V (nom)
10: rise=2.625V (nom), fall=2.6V (nom)
11: rise=2.725V (nom), fall=2.7V (nom)
12: rise=2.825V (nom), fall=2.8V (nom)
13: rise=2.925V (nom), fall=2.9V (nom)
14: rise=3.025V (nom), fall=3.0V (nom)
15: rise=3.125V (nom), fall=3.1V (nom)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_SRCSEL</name>
              <description>Source selection for HVLVD1</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VDDD</name>
                  <description>Select VDDD</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AMUXBUSA</name>
                  <description>Select AMUXBUSA (VDDD branch)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDIO</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AMUXBUSB</name>
                  <description>Select AMUXBUSB (VDDD branch)</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HVLVD1_EN</name>
              <description>Enable HVLVD1 voltage monitor.  When the LVD is enabled, it takes 20us for it to settle.  There is no hardware stabilization counter, and it may falsely trigger during settling.  It is recommended that firmware keep the interrupt masked for at least 8us, write a 1'b1 to the corresponding SRSS_INTR field to any falsely pended interrupt, and then optionally unmask the interrupt.  After enabling, it is further recommended to read the related PWR_LVD_STATUS field, since the interrupt only triggers on edges.  This bit is cleared (LVD is disabled) when entering DEEPSLEEP to prevent false interrupts during wakeup.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BUCK_CTL</name>
          <description>Buck Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x5</resetValue>
          <resetMask>0xC0000007</resetMask>
          <fields>
            <field>
              <name>BUCK_OUT1_SEL</name>
              <description>Voltage output selection for vccbuck1 output.  This register is only reset by XRES/POR/BOD/HIBERNATE.  When increasing the voltage, it can take up to 200us for the output voltage to settle.  When decreasing the voltage, the settling time depends on the load current.
0: 0.85V
1: 0.875V
2: 0.90V
3: 0.95V
4: 1.05V
5: 1.10V
6: 1.15V
7: 1.20V</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_EN</name>
              <description>Master enable for buck converter.    This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_OUT1_EN</name>
              <description>Enable for vccbuck1 output.  The value in this register is ignored unless PWR_BUCK_CTL.BUCK_EN==1.    This register is only reset by XRES/POR/BOD/HIBERNATE.  The regulator takes up to 600us to charge the external capacitor.  If there is additional load current while charging, this will increase the startup time.  The TRM specifies the required sequence when transitioning vccd from the LDO to SIMO Buck output #1.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BUCK_CTL2</name>
          <description>Buck Control Register 2</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000007</resetMask>
          <fields>
            <field>
              <name>BUCK_OUT2_SEL</name>
              <description>Voltage output selection for vccbuck2 output.  When increasing the voltage, it can take up to 200us for the output voltage to settle.  When decreasing the voltage, the settling time depends on the load current.
0: 1.15V
1: 1.20V
2: 1.25V
3: 1.30V
4: 1.35V
5: 1.40V
6: 1.45V
7: 1.50V</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_OUT2_HW_SEL</name>
              <description>Hardware control for vccbuck2 output.  When this bit is set, the value in BUCK_OUT2_EN is ignored and a hardware signal is used instead.  If the product has supporting hardware, it can directly control the enable signal for vccbuck2.  The same charging time in BUCK_OUT2_EN applies.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_OUT2_EN</name>
              <description>Enable for vccbuck2 output.  The value in this register is ignored unless PWR_BUCK_CTL.BUCK_EN==1.  The regulator takes up to 600us to charge the external capacitor.  If there is additional load current while charging, this will increase the startup time.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_LVD_STATUS</name>
          <description>Low Voltage Detector (LVD) Status Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>HVLVD1_OK</name>
              <description>HVLVD1 output.
0: below voltage threshold
1: above voltage threshold</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>PWR_HIB_DATA[%s]</name>
          <description>HIBERNATE Data Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HIB_DATA</name>
              <description>Additional data that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware for any application-specific purpose.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CTL</name>
          <description>Watchdog Counter Control Register</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0000001</resetValue>
          <resetMask>0xC0000001</resetMask>
          <fields>
            <field>
              <name>WDT_EN</name>
              <description>Enable this watchdog timer.  This field is retained during Deep Sleep and Hibernate modes. Even though the default value is 1, in most cases the Cortex-M0+ executing the SROM code will change the value of this bit to 0. So effectively the user code starts with the WDT disabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_LOCK</name>
              <description>Prohibits writing to WDT_*, CLK_ILO_CONFIG, CLK_SELECT.LFCLK_SEL, and CLK_TRIM_ILO_CTL registers when not equal 0.  Requires at least two different writes to unlock.  A change in WDT_LOCK takes effect beginning with the next write cycle.
Note that this field is 2 bits to force multiple writes only.  It represents only a single write protect signal protecting all those registers at the same time.  WDT will lock on any reset.  This field is not retained during Deep Sleep or Hibernate mode, so the WDT will be locked after wakeup from these modes.</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_CHG</name>
                  <description>No effect</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR0</name>
                  <description>Clears bit 0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR1</name>
                  <description>Clears bit 1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SET01</name>
                  <description>Sets both bits 0 and 1</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CNT</name>
          <description>Watchdog Counter Count Register</description>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER</name>
              <description>Current value of WDT Counter.  The write feature of this register is for verification purposes, has no synchronization, and can only be applied when the WDT is off.  When writing, the value is updated immediately in the WDT counter, but it will read back as the old value until this register resynchronizes just after the negative edge of ILO.  Writes will be ignored if they occur when the WDT is enabled.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_MATCH</name>
          <description>Watchdog Counter Match Register</description>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000</resetValue>
          <resetMask>0xFFFFF</resetMask>
          <fields>
            <field>
              <name>MATCH</name>
              <description>Match value for Watchdog counter.  Every time WDT_COUNTER reaches MATCH an interrupt is generated.  Two unserviced interrupts will lead to a system reset (i.e. at the third match).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IGNORE_BITS</name>
              <description>The number of MSB bits of the watchdog timer that are NOT checked against MATCH.  This value provides control over the time-to-reset of the watchdog (which happens after 3 successive matches).  Up to 12 MSB can be ignored.  Settings &gt;12 behave like a setting of 12.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>2</dim>
          <dimIncrement>64</dimIncrement>
          <name>MCWDT_STRUCT[%s]</name>
          <description>Multi-Counter Watchdog Timer</description>
          <headerStructName>MCWDT_STRUCT</headerStructName>
          <addressOffset>0x00000200</addressOffset>
          <register>
            <name>MCWDT_CNTLOW</name>
            <description>Multi-Counter Watchdog Sub-counters 0/1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WDT_CTR0</name>
                <description>Current value of sub-counter 0 for this MCWDT.  Software writes are ignored when the sub-counter is enabled.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_CTR1</name>
                <description>Current value of sub-counter 1 for this MCWDT.  Software writes are ignored when the sub-counter is enabled</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_CNTHIGH</name>
            <description>Multi-Counter Watchdog Sub-counter 2</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WDT_CTR2</name>
                <description>Current value of sub-counter 2 for this MCWDT.  Software writes are ignored when the sub-counter is enabled</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_MATCH</name>
            <description>Multi-Counter Watchdog Counter Match Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WDT_MATCH0</name>
                <description>Match value for sub-counter 0 of this MCWDT</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_MATCH1</name>
                <description>Match value for sub-counter 1 of this MCWDT</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_CONFIG</name>
            <description>Multi-Counter Watchdog Counter Configuration</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F010F0F</resetMask>
            <fields>
              <field>
                <name>WDT_MODE0</name>
                <description>Watchdog Counter Action on Match.  Action is taken on the next increment after the values match (WDT_CTR0=WDT_MATCH0).</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT</name>
                    <description>Assert WDT_INTx</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET</name>
                    <description>Assert WDT Reset</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT_THEN_RESET</name>
                    <description>Assert WDT_INTx, assert WDT Reset after 3rd unhandled interrupt</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WDT_CLEAR0</name>
                <description>Clear Watchdog Counter when WDT_CTR0=WDT_MATCH0. In other words WDT_CTR0 divides LFCLK by (WDT_MATCH0+1).
0: Free running counter
1: Clear on match.  In this mode, the minimum legal setting of WDT_MATCH0 is 1.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_CASCADE0_1</name>
                <description>Cascade Watchdog Counters 0,1.  Counter 1 increments the cycle after WDT_CTR0=WDT_MATCH0.
0: Independent counters
1: Cascaded counters</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_MODE1</name>
                <description>Watchdog Counter Action on Match.  Action is taken on the next increment after the values match (WDT_CTR1=WDT_MATCH1).</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT</name>
                    <description>Assert WDT_INTx</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET</name>
                    <description>Assert WDT Reset</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT_THEN_RESET</name>
                    <description>Assert WDT_INTx, assert WDT Reset after 3rd unhandled interrupt</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WDT_CLEAR1</name>
                <description>Clear Watchdog Counter when WDT_CTR1==WDT_MATCH1. In other words WDT_CTR1 divides LFCLK by (WDT_MATCH1+1).
0: Free running counter
1: Clear on match.  In this mode, the minimum legal setting of WDT_MATCH1 is 1.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_CASCADE1_2</name>
                <description>Cascade Watchdog Counters 1,2.  Counter 2 increments the cycle after WDT_CTR1=WDT_MATCH1.  It is allowed to cascade all three WDT counters.
0: Independent counters
1: Cascaded counters.  When cascading all three counters, WDT_CLEAR1 must be 1.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_MODE2</name>
                <description>Watchdog Counter 2 Mode.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Free running counter with no interrupt requests</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT</name>
                    <description>Free running counter with interrupt request that occurs one LFCLK cycle after the specified bit in CTR2 toggles (see WDT_BITS2).</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WDT_BITS2</name>
                <description>Bit to observe for WDT_INT2:
0: Assert after bit0 of WDT_CTR2 toggles (one int every tick)
...
31: Assert after bit31 of WDT_CTR2 toggles (one int every 2^31 ticks)</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_CTL</name>
            <description>Multi-Counter Watchdog Counter Control</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xB0B0B</resetMask>
            <fields>
              <field>
                <name>WDT_ENABLE0</name>
                <description>Enable subcounter 0.  May take up to 2 LFCLK cycles to take effect.
0: Counter is disabled (not clocked)
1: Counter is enabled (counting up)</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_ENABLED0</name>
                <description>Indicates actual state of counter.  May lag WDT_ENABLE0 by up to two LFCLK cycles.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WDT_RESET0</name>
                <description>Resets counter 0 back to 0000.  Hardware will reset this bit after counter was reset.  This will take up to one LFCLK cycle to take effect.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_ENABLE1</name>
                <description>Enable subcounter 1.  May take up to 2 LFCLK cycles to take effect.
0: Counter is disabled (not clocked)
1: Counter is enabled (counting up)</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_ENABLED1</name>
                <description>Indicates actual state of counter.  May lag WDT_ENABLE1 by up to two LFCLK cycles.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WDT_RESET1</name>
                <description>Resets counter 1 back to 0000.  Hardware will reset this bit after counter was reset.  This will take up to one LFCLK cycle to take effect.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_ENABLE2</name>
                <description>Enable subcounter 2.  May take up to 2 LFCLK cycles to take effect.
0: Counter is disabled (not clocked)
1: Counter is enabled (counting up)</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_ENABLED2</name>
                <description>Indicates actual state of counter.  May lag WDT_ENABLE2 by up to two LFCLK cycles.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WDT_RESET2</name>
                <description>Resets counter 2 back to 0000.  Hardware will reset this bit after counter was reset.  This will take up to one LFCLK cycle to take effect.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_INTR</name>
            <description>Multi-Counter Watchdog Counter Interrupt Register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>MCWDT_INT0</name>
                <description>MCWDT Interrupt Request for sub-counter 0.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.  Clearing this bit also prevents Reset from happening when WDT_MODE0=3.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT1</name>
                <description>MCWDT Interrupt Request for sub-counter 1.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.  Clearing this bit also prevents Reset from happening when WDT_MODE1=3.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT2</name>
                <description>MCWDT Interrupt Request for sub-counter 2.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.  Clearing this bit also prevents Reset from happening when WDT_MODE2=3.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_INTR_SET</name>
            <description>Multi-Counter Watchdog Counter Interrupt Set Register</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>MCWDT_INT0</name>
                <description>Set interrupt for MCWDT_INT0</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT1</name>
                <description>Set interrupt for MCWDT_INT1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT2</name>
                <description>Set interrupt for MCWDT_INT2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_INTR_MASK</name>
            <description>Multi-Counter Watchdog Counter Interrupt Mask Register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>MCWDT_INT0</name>
                <description>Interrupt Mask for sub-counter 0. The bit controls if the interrupt is forwarded to the CPU. The interrupt is blocked when the value of the bit is 0. The interrupt is forwarded if the value of the bit is 1.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT1</name>
                <description>Interrupt Mask for sub-counter 1.  The bit controls if the interrupt is forwarded to the CPU. The interrupt is blocked when the value of the bit is 0. The interrupt is forwarded if the value of the bit is 1.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT2</name>
                <description>Interrupt Mask for sub-counter 2.  The bit controls if the interrupt is forwarded to the CPU. The interrupt is blocked when the value of the bit is 0. The interrupt is forwarded if the value of the bit is 1.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_INTR_MASKED</name>
            <description>Multi-Counter Watchdog Counter Interrupt Masked Register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>MCWDT_INT0</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MCWDT_INT1</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MCWDT_INT2</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_LOCK</name>
            <description>Multi-Counter Watchdog Counter Lock Register</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC0000000</resetMask>
            <fields>
              <field>
                <name>MCWDT_LOCK</name>
                <description>Prohibits writing control and configuration registers related to this MCWDT when not equal 0 (as specified in the other register descriptions).  Requires at least two different writes to unlock.
Note that this field is 2 bits to force multiple writes only.  Each MCWDT has a separate local lock.  LFCLK settings are locked by the global WDT_LOCK register, and this register has no effect on that.</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NO_CHG</name>
                    <description>No effect</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLR0</name>
                    <description>Clears bit 0</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLR1</name>
                    <description>Clears bit 1</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SET01</name>
                    <description>Sets both bits 0 and 1</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_DSI_SELECT[%s]</name>
          <description>Clock DSI Select Register</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>DSI_MUX</name>
              <description>Selects a DSI source or low frequency clock for use in a clock path.  The output of this mux can be selected for clock PATH&lt;i&gt; using CLK_PATH_SELECT register.  Using the output of this mux as HFCLK source will result in undefined behavior.  It can be used to clocks to DSI or to the reference inputs of FLL/PLL, subject to the frequency limits of those circuits.  This mux is not glitch free, so do not change the selection while it is an actively selected clock.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DSI_OUT0</name>
                  <description>DSI0 - dsi_out[0]</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT1</name>
                  <description>DSI1 - dsi_out[1]</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT2</name>
                  <description>DSI2 - dsi_out[2]</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT3</name>
                  <description>DSI3 - dsi_out[3]</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT4</name>
                  <description>DSI4 - dsi_out[4]</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT5</name>
                  <description>DSI5 - dsi_out[5]</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT6</name>
                  <description>DSI6 - dsi_out[6]</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT7</name>
                  <description>DSI7 - dsi_out[7]</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT8</name>
                  <description>DSI8 - dsi_out[8]</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT9</name>
                  <description>DSI9 - dsi_out[9]</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT10</name>
                  <description>DSI10 - dsi_out[10]</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT11</name>
                  <description>DSI11 - dsi_out[11]</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT12</name>
                  <description>DSI12 - dsi_out[12]</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT13</name>
                  <description>DSI13 - dsi_out[13]</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT14</name>
                  <description>DSI14 - dsi_out[14]</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT15</name>
                  <description>DSI15 - dsi_out[15]</description>
                  <value>15</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>ILO - Internal Low-speed Oscillator</description>
                  <value>16</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>WCO - Watch-Crystal Oscillator</description>
                  <value>17</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>ALTLF - Alternate Low-Frequency Clock</description>
                  <value>18</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>PILO - Precision Internal Low-speed Oscillator</description>
                  <value>19</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_PATH_SELECT[%s]</name>
          <description>Clock Path Select Register</description>
          <addressOffset>0x340</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>PATH_MUX</name>
              <description>Selects a source for clock PATH&lt;i&gt;.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO - Internal R/C Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>EXTCLK - External Clock Pin</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>ECO - External-Crystal Oscillator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTHF</name>
                  <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_MUX</name>
                  <description>DSI_MUX - Output of DSI mux for this path.  Using a DSI source directly as root of HFCLK will result in undefined behavior.</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_ROOT_SELECT[%s]</name>
          <description>Clock Root Select Register</description>
          <addressOffset>0x380</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000003F</resetMask>
          <fields>
            <field>
              <name>ROOT_MUX</name>
              <description>Selects a clock path as the root of HFCLK&lt;k&gt; and for SRSS DSI input &lt;k&gt;.  Use CLK_PATH_SELECT[i] to configure the desired path.  Some paths may have FLL or PLL available (product-specific), and the control and bypass mux selections of these are in other registers.  Configure the FLL using CLK_FLL_CONFIG register.  Configure a PLL using the related CLK_PLL_CONFIG[k] register.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PATH0</name>
                  <description>Select PATH0 (can be configured for FLL)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH1</name>
                  <description>Select PATH1 (can be configured for PLL0, if available in the product)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH2</name>
                  <description>Select PATH2 (can be configured for PLL1, if available in the product)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH3</name>
                  <description>Select PATH3 (can be configured for PLL2, if available in the product)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH4</name>
                  <description>Select PATH4 (can be configured for PLL3, if available in the product)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH5</name>
                  <description>Select PATH5 (can be configured for PLL4, if available in the product)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH6</name>
                  <description>Select PATH6 (can be configured for PLL5, if available in the product)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH7</name>
                  <description>Select PATH7 (can be configured for PLL6, if available in the product)</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH8</name>
                  <description>Select PATH8 (can be configured for PLL7, if available in the product)</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH9</name>
                  <description>Select PATH9 (can be configured for PLL8, if available in the product)</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH10</name>
                  <description>Select PATH10 (can be configured for PLL9, if available in the product)</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH11</name>
                  <description>Select PATH11 (can be configured for PLL10, if available in the product)</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH12</name>
                  <description>Select PATH12 (can be configured for PLL11, if available in the product)</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH13</name>
                  <description>Select PATH13 (can be configured for PLL12, if available in the product)</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH14</name>
                  <description>Select PATH14 (can be configured for PLL13, if available in the product)</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH15</name>
                  <description>Select PATH15 (can be configured for PLL14, if available in the product)</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ROOT_DIV</name>
              <description>Selects predivider value for this clock root and DSI input.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide selected clock source by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide selected clock source by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide selected clock source by 8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Enable for this clock root.  All clock roots default to disabled (ENABLE==0) except HFCLK0, which cannot be disabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_SELECT</name>
          <description>Clock selection register</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF03</resetMask>
          <fields>
            <field>
              <name>LFCLK_SEL</name>
              <description>Select source for LFCLK.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>ILO - Internal Low-speed Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>WCO - Watch-Crystal Oscillator.  Requires Backup domain to be present and properly configured (including external watch crystal, if used).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>ALTLF - Alternate Low-Frequency Clock.  Capability is product-specific</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>PILO - Precision ILO. If present, it works in DEEPSLEEP and higher modes.  Does not work in HIBERNATE mode.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PUMP_SEL</name>
              <description>Selects clock PATH&lt;k&gt;, where k=PUMP_SEL.  The output of this mux goes to the PUMP_DIV to make PUMPCLK  Each product has a specific number of available clock paths.  Selecting a path that is not implemented on a product will result in undefined behavior.  Note that this is not a glitch free mux.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PUMP_DIV</name>
              <description>Division ratio for PUMPCLK.  Uses selected PUMP_SEL clock as the source.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide selected clock source by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide selected clock source by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide selected clock source by 8</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_16</name>
                  <description>Divide selected clock source by 16</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PUMP_ENABLE</name>
              <description>Enable the pump clock.  PUMP_ENABLE and the PUMP_SEL mux are not glitch-free to minimize side-effects, avoid changing the PUMP_SEL and PUMP_DIV while changing PUMP_ENABLE.  To change the settings, do the following: 
1) If the pump clock is enabled, write PUMP_ENABLE=0 without changing PUMP_SEL and PUMP_DIV.  
2) Change PUMP_SEL and PUMP_DIV to desired settings with PUMP_ENABLE=0.  
3) Write PUMP_ENABLE=1 without changing PUMP_SEL and PUMP_DIV.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TIMER_CTL</name>
          <description>Timer Clock Control Register</description>
          <addressOffset>0x504</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x70000</resetValue>
          <resetMask>0x80FF0301</resetMask>
          <fields>
            <field>
              <name>TIMER_SEL</name>
              <description>Select source for TIMERCLK.  The output of this mux can be further divided using TIMER_DIV.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO - Internal Main Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HF0_DIV</name>
                  <description>Select the output of the predivider configured by TIMER_HF0_DIV.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIMER_HF0_DIV</name>
              <description>Predivider used when HF0_DIV is selected in TIMER_SEL.  If HFCLK0 frequency is less than 100MHz and has approximately 50 percent duty cycle, then no division is required (NO_DIV).  Otherwise, select a divide ratio of 2, 4, or 8 before selected HF0_DIV as the timer clock.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Transparent mode, feed through selected clock source w/o dividing or correcting duty cycle.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide HFCLK0 by 2.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide HFCLK0 by 4.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide HFCLK0 by 8.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIMER_DIV</name>
              <description>Divide selected timer clock source by (1+TIMER_DIV).  The output of this divider is TIMERCLK  Allows for integer divisions in the range [1, 256].  Do not change this setting while the timer is enabled.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Enable for TIMERCLK.
0: TIMERCLK is off
1: TIMERCLK is enabled</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ILO_CONFIG</name>
          <description>ILO Configuration</description>
          <addressOffset>0x50C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80000001</resetMask>
          <fields>
            <field>
              <name>ILO_BACKUP</name>
              <description>If backup domain is present on this product, this register indicates that ILO should stay enabled for use by backup domain during XRES, HIBERNATE mode, and through power-related resets like BOD on VDDD/VCCD.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.
0: ILO turns off at XRES/BOD event or HIBERNATE entry.
1: ILO remains on if backup domain is present and powered even for XRES/BOD or HIBERNATE entry.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for ILO.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.  After enabling, it takes at most two cycles to reach the accuracy spec.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_CONFIG</name>
          <description>IMO Configuration</description>
          <addressOffset>0x510</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Master enable for IMO oscillator.  This bit must be high at all times for all functions to work properly.  Hardware will automatically disable the IMO during HIBERNATE and XRES.  It will automatically disable during DEEPSLEEP if CLK_MFO_CONFIG.DPSLP_ENABLE==0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_OUTPUT_FAST</name>
          <description>Fast Clock Output Select Register</description>
          <addressOffset>0x514</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF0FFF</resetMask>
          <fields>
            <field>
              <name>FAST_SEL0</name>
              <description>Select signal for fast clock output #0</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes, including PATH_SEL0 and HFCLK_SEL0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>External Crystal Oscillator (ECO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>External clock input (EXTCLK)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTHF</name>
                  <description>Alternate High-Frequency (ALTHF) clock input to SRSS</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERCLK</name>
                  <description>Timer clock.  It is grouped with the fast clocks because it may be a gated version of a fast clock, and therefore may have a short high pulse.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH_SEL0</name>
                  <description>Selects the clock path chosen by PATH_SEL0 field</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK_SEL0</name>
                  <description>Selects the output of the HFCLK_SEL0 mux</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLOW_SEL0</name>
                  <description>Selects the output of CLK_OUTPUT_SLOW.SLOW_SEL0</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PATH_SEL0</name>
              <description>Selects a clock path to use in fast clock output #0 logic.  0: FLL output
1-15: PLL output on path1-path15 (if available)</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HFCLK_SEL0</name>
              <description>Selects a HFCLK tree for use in fast clock output #0</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_SEL1</name>
              <description>Select signal for fast clock output #1</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes, including PATH_SEL1 and HFCLK_SEL1.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>External Crystal Oscillator (ECO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>External clock input (EXTCLK)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTHF</name>
                  <description>Alternate High-Frequency (ALTHF) clock input to SRSS</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERCLK</name>
                  <description>Timer clock.  It is grouped with the fast clocks because it may be a gated version of a fast clock, and therefore may have a short high pulse.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH_SEL1</name>
                  <description>Selects the clock path chosen by PATH_SEL1 field</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK_SEL1</name>
                  <description>Selects the output of the HFCLK_SEL1 mux</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLOW_SEL1</name>
                  <description>Selects the output of CLK_OUTPUT_SLOW.SLOW_SEL1</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PATH_SEL1</name>
              <description>Selects a clock path to use in fast clock output #1 logic.  0: FLL output
1-15: PLL output on path1-path15 (if available)</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HFCLK_SEL1</name>
              <description>Selects a HFCLK tree for use in fast clock output #1 logic</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_OUTPUT_SLOW</name>
          <description>Slow Clock Output Select Register</description>
          <addressOffset>0x518</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SLOW_SEL0</name>
              <description>Select signal for slow clock output #0</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>Internal Low Speed Oscillator (ILO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>Watch-Crystal Oscillator (WCO)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BAK</name>
                  <description>Root of the Backup domain clock tree (BAK)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>Alternate low-frequency clock input to SRSS (ALTLF)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <description>Root of the low-speed clock tree (LFCLK)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>Internal Main Oscillator (IMO).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLPCTRL</name>
                  <description>Sleep Controller clock (SLPCTRL).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>Precision Internal Low Speed Oscillator (PILO)</description>
                  <value>8</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLOW_SEL1</name>
              <description>Select signal for slow clock output #1</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>Internal Low Speed Oscillator (ILO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>Watch-Crystal Oscillator (WCO)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BAK</name>
                  <description>Root of the Backup domain clock tree (BAK)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>Alternate low-frequency clock input to SRSS (ALTLF)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <description>Root of the low-speed clock tree (LFCLK)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>Internal Main Oscillator (IMO).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLPCTRL</name>
                  <description>Sleep Controller clock (SLPCTRL).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>Precision Internal Low Speed Oscillator (PILO)</description>
                  <value>8</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_CAL_CNT1</name>
          <description>Clock Calibration Counter 1</description>
          <addressOffset>0x51C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80FFFFFF</resetMask>
          <fields>
            <field>
              <name>CAL_COUNTER1</name>
              <description>Down-counter clocked on fast clock output #0 (see CLK_OUTPUT_FAST). This register always reads as zero.  Counting starts internally when this register is written with a nonzero value.  CAL_COUNTER_DONE goes immediately low to indicate that the counter has started and will be asserted when the counters are done.  Do not write this field unless CAL_COUNTER_DONE==1.  Both clocks must be running or the measurement will not complete.  A stalled counter can be recovered by selecting valid clocks, waiting until the measurement completes, and discarding the first result.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CAL_COUNTER_DONE</name>
              <description>Status bit indicating that the internal counter #1 is finished counting and CLK_CAL_CNT2.COUNTER stopped counting up</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_CAL_CNT2</name>
          <description>Clock Calibration Counter 2</description>
          <addressOffset>0x520</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAL_COUNTER2</name>
              <description>Up-counter clocked on fast clock output  #1 (see CLK_OUTPUT_FAST). When CLK_CAL_CNT1.CAL_COUNTER_DONE==1, the counter is stopped and can be read by SW.  Do not read this value unless CAL_COUNTER_DONE==1.  The expected final value is related to the ratio of clock frequencies used for the two counters and the value loaded into counter 1: CLK_CAL_CNT2.COUNTER=(F_cnt2/F_cnt1)*(CLK_CAL_CNT1.COUNTER)</description>
              <bitRange>[23:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ECO_CONFIG</name>
          <description>ECO Configuration Register</description>
          <addressOffset>0x52C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x80000002</resetMask>
          <fields>
            <field>
              <name>AGC_EN</name>
              <description>Automatic Gain Control (AGC) enable.  When set, the oscillation amplitude is controlled to the level selected by ECO_TRIM0.ATRIM.  When low, the amplitude is not explicitly controlled and can be as high as the vddd supply.  WARNING: use care when disabling AGC because driving a crystal beyond its rated limit can permanently damage the crystal.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECO_EN</name>
              <description>Master enable for ECO oscillator.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ECO_STATUS</name>
          <description>ECO Status Register</description>
          <addressOffset>0x530</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>ECO_OK</name>
              <description>Indicates the ECO internal oscillator circuit has sufficient amplitude.  It may not meet the PPM accuracy or duty cycle spec.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ECO_READY</name>
              <description>Indicates the ECO internal oscillator circuit has had enough time to fully stabilize.  This is the output of a counter since ECO was enabled, and it does not check the ECO output.  It is recommended to also confirm ECO_OK==1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_PILO_CONFIG</name>
          <description>Precision ILO Configuration Register</description>
          <addressOffset>0x53C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80</resetValue>
          <resetMask>0xE00003FF</resetMask>
          <fields>
            <field>
              <name>PILO_FFREQ</name>
              <description>Fine frequency trim allowing +/-250ppm accuracy with periodic calibration.  The nominal step size of the LSB is 8Hz.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_CLK_EN</name>
              <description>Enable the PILO clock output.  See PILO_EN field for required sequencing.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_RESET_N</name>
              <description>Reset the PILO.  See PILO_EN field for required sequencing.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_EN</name>
              <description>Enable PILO.  When enabling PILO, set PILO_EN=1, wait 1ms, then PILO_RESET_N=1 and PILO_CLK_EN=1.  When disabling PILO, clear PILO_EN=0, PILO_RESET_N=0, and PLO_CLK_EN=0 in the same write cycle.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_MF_SELECT</name>
          <description>Medium Frequency Clock Select Register</description>
          <addressOffset>0x544</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000FF07</resetMask>
          <fields>
            <field>
              <name>MFCLK_SEL</name>
              <description>Select source for MFCLK (clk_mf).  Note that not all products support all clock sources.  Selecting a clock source that is not supported results in undefined behavior.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MFO</name>
                  <description>MFO - medium frequency oscillator</description>
                  <value>0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MFCLK_DIV</name>
              <description>Divide selected clock source by (1+MFCLK_DIV).  The output of this divider is MFCLK (clk_mf).  Allows for integer divisions in the range [1, 256].  Do not change this setting while ENABLE==1.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Enable for MFCLK (clk_mf).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_MFO_CONFIG</name>
          <description>MFO Configuration Register</description>
          <addressOffset>0x548</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>DPSLP_ENABLE</name>
              <description>Enable for MFO during DEEPSLEEP.  This bit is ignored when ENABLE==0.  When ENABLE==1:
0: MFO is automatically disabled during DEEPSLEEP and enables upon wakeup;
1: MFO is kept enabled throughout DEEPSLEEP</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Enable for MFO.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG</name>
          <description>FLL Configuration Register</description>
          <addressOffset>0x580</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0x8103FFFF</resetMask>
          <fields>
            <field>
              <name>FLL_MULT</name>
              <description>Multiplier to determine CCO frequency in multiples of the frequency of the selected reference clock (Fref).

Ffll = (FLL_MULT)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV+1)</description>
              <bitRange>[17:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLL_OUTPUT_DIV</name>
              <description>Control bits for Output divider.  Set the divide value before enabling the FLL, and do not change it while FLL is enabled.
0: no division
1: divide by 2</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLL_ENABLE</name>
              <description>Master enable for FLL.  The FLL requires firmware sequencing when enabling, disabling, and entering/exiting DEEPSLEEP.

To enable the FLL, first enable the CCO by writing CLK_FLL_CONFIG4.CCO_ENABLE=1 and wait until CLK_FLL_STATUS.CCO_READY==1.  Next, ensure the reference clock has stabilized and CLK_FLL_CONFIG3.BYPASS_SEL=FLL_REF.  Next, write FLL_ENABLE=1 and wait until CLK_FLL_STATUS.LOCKED==1.  Finally, write CLK_FLL_CONFIG3.BYPASS_SEL=FLL_OUT to switch to the FLL output.  It takes seven reference clock cycles plus four FLL output cycles to switch to the FLL output.  Do not disable the FLL before this time completes.

To disable the FLL, write CLK_FLL_CONFIG3.BYPASS_SEL=FLL_REF and (optionally) read the same register to ensure the write completes.  Then, wait at least seven FLL reference clock cycles before disabling it with FLL_ENABLE=0.  Lastly, disable the CCO by writing CLK_FLL_CONFIG4.CCO_ENABLE=0.

Before entering DEEPSLEEP, either disable the FLL using above sequence or use the following procedure to deselect/select it before/after DEEPSLEEP.  Before entering DEEPSLEEP, write CLK_FLL_CONFIG3.BYPASS_SEL=FLL_REF to change the FLL to use its reference clock.  After DEEPSLEEP wakeup, wait until CLK_FLL_STATUS.LOCKED==1 and then write CLK_FLL_CONFIG3.BYPASS_SEL=FLL_OUT to switch to the FLL output.

0: Block is powered off
1: Block is powered on</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG2</name>
          <description>FLL Configuration Register 2</description>
          <addressOffset>0x584</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20001</resetValue>
          <resetMask>0x1FF1FFF</resetMask>
          <fields>
            <field>
              <name>FLL_REF_DIV</name>
              <description>Control bits for reference divider.  Set the divide value before enabling the FLL, and do not change it while FLL is enabled.
0: illegal (undefined behavior)
1: divide by 1
...
8191: divide by 8191</description>
              <bitRange>[12:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_TOL</name>
              <description>Lock tolerance sets the error threshold for when the FLL output is considered locked to the reference input.  A high tolerance can be used to lock more quickly or to track a less accurate source.  The tolerance should be set so that the FLL does not unlock under normal conditions.  The tolerance is the allowed difference between the count value for the ideal formula and the measured value. 
0: tolerate error of 1 count value
1: tolerate error of 2 count values
...
511: tolerate error of 512 count values</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG3</name>
          <description>FLL Configuration Register 3</description>
          <addressOffset>0x588</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2800</resetValue>
          <resetMask>0x301FFFFF</resetMask>
          <fields>
            <field>
              <name>FLL_LF_IGAIN</name>
              <description>FLL Loop Filter Gain Setting #1.  The proportional gain is the sum of FLL_LF_IGAIN and FLL_LF_PGAIN.
0: 1/256
1: 1/128
2: 1/64
3: 1/32
4: 1/16
5: 1/8
6: 1/4
7: 1/2
8: 1.0
9: 2.0
10: 4.0
11: 8.0
&gt;=12: illegal</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLL_LF_PGAIN</name>
              <description>FLL Loop Filter Gain Setting #2.  The proportional gain is the sum of FLL_LF_IGAIN and FLL_LF_PGAIN.
0: 1/256
1: 1/128
2: 1/64
3: 1/32
4: 1/16
5: 1/8
6: 1/4
7: 1/2
8: 1.0
9: 2.0
10: 4.0
11: 8.0
&gt;=12: illegal</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SETTLING_COUNT</name>
              <description>Number of undivided reference clock cycles to wait after changing the CCO trim until the loop measurement restarts.  A delay allows the CCO output to settle and gives a more accurate measurement.  The default is tuned to an 8MHz reference clock since the IMO is expected to be the most common use case.
0: no settling time
1: wait one reference clock cycle
...
8191: wait 8191 reference clock cycles</description>
              <bitRange>[20:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS_SEL</name>
              <description>Bypass mux located just after FLL output.  See FLL_ENABLE description for instructions on how to use this field when enabling/disabling the FLL.</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUTO</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FLL_REF</name>
                  <description>Select FLL reference input (bypass mode).  Ignores lock indicator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FLL_OUT</name>
                  <description>Select FLL output.  Ignores lock indicator.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG4</name>
          <description>FLL Configuration Register 4</description>
          <addressOffset>0x58C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0xC1FF07FF</resetMask>
          <fields>
            <field>
              <name>CCO_LIMIT</name>
              <description>Maximum CCO offset allowed (used to prevent FLL dynamics from selecting an CCO frequency that the logic cannot support)</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_RANGE</name>
              <description>Frequency range of CCO</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RANGE0</name>
                  <description>Target frequency is in range [48, 64) MHz</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE1</name>
                  <description>Target frequency is in range [64, 85) MHz</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE2</name>
                  <description>Target frequency is in range [85, 113) MHz</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE3</name>
                  <description>Target frequency is in range [113, 150) MHz</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE4</name>
                  <description>Target frequency is in range [150, 200] MHz</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CCO_FREQ</name>
              <description>CCO frequency code.  This is updated by HW when the FLL is enabled.  It can be manually updated to use the CCO in an open loop configuration.  The meaning of each frequency code depends on the range.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_HW_UPDATE_DIS</name>
              <description>Disable CCO frequency update by FLL hardware
0: Hardware update of CCO settings is allowed.  Use this setting for normal FLL operation.
1: Hardware update of CCO settings is disabled.  Use this setting for open-loop FLL operation.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_ENABLE</name>
              <description>Enable the CCO.  It is required to enable the CCO before using the FLL.  
0: Block is powered off
1: Block is powered on</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_STATUS</name>
          <description>FLL Status Register</description>
          <addressOffset>0x590</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>LOCKED</name>
              <description>FLL Lock Indicator.  LOCKED is high when FLL is within CLK_FLL_CONFIG2.LOCK_TOL.  If FLL is outside LOCK_TOL, LOCKED goes low.  Note that this can happen during normal operation, if FLL needs to recalculate due to a change in the reference clock, change in voltage, or change in temperature.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNLOCK_OCCURRED</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_READY</name>
              <description>This indicates that the CCO is internally settled and ready to use.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_PLL_CONFIG[%s]</name>
          <description>PLL Configuration Register</description>
          <addressOffset>0x600</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20116</resetValue>
          <resetMask>0xB81F1F7F</resetMask>
          <fields>
            <field>
              <name>FEEDBACK_DIV</name>
              <description>Control bits for feedback divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0-21: illegal (undefined behavior)
22: divide by 22
...
112: divide by 112
&gt;112: illegal (undefined behavior)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFERENCE_DIV</name>
              <description>Control bits for reference divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0: illegal (undefined behavior)
1: divide by 1
...
20: divide by 20
others: illegal (undefined behavior)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTPUT_DIV</name>
              <description>Control bits for Output divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0: illegal (undefined behavior)
1: illegal (undefined behavior) 
2: divide by 2.  Suitable for direct usage as HFCLK source.
...
16: divide by 16.  Suitable for direct usage as HFCLK source.
&gt;16: illegal (undefined behavior)</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_LF_MODE</name>
              <description>VCO frequency range selection.  Configure this bit according to the targeted VCO frequency.  Do not change this setting while the PLL is enabled.
0: VCO frequency is [200MHz, 400MHz]
1: VCO frequency is [170MHz, 200MHz)</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS_SEL</name>
              <description>Bypass mux located just after PLL output.  This selection is glitch-free and can be changed while the PLL is running.</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUTO</name>
                  <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO1</name>
                  <description>Same as AUTO</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PLL_REF</name>
                  <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PLL_OUT</name>
                  <description>Select PLL output.  Ignores lock indicator.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for PLL.  Setup FEEDBACK_DIV, REFERENCE_DIV, and OUTPUT_DIV at least one cycle before setting ENABLE=1.  To disable the PLL, first deselect it using .BYPASS_SEL=PLL_REF, wait at least six PLL clock cycles, and then disable it with .ENABLE=0.

Fpll = (FEEDBACK_DIV)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV)

0: Block is disabled
1: Block is enabled</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_PLL_STATUS[%s]</name>
          <description>PLL Status Register</description>
          <addressOffset>0x640</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>LOCKED</name>
              <description>PLL Lock Indicator</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNLOCK_OCCURRED</name>
              <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR</name>
          <description>SRSS Interrupt Register</description>
          <addressOffset>0x700</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x23</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>WDT Interrupt Request.  This bit is set each time WDT_COUNTR==WDT_MATCH.  W1C also feeds the watch dog.  Missing 2 interrupts in a row will generate a reset.  Due to internal synchronization, it takes 2 SYSCLK cycles to update after a W1C.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1</name>
              <description>Interrupt for low voltage detector HVLVD1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Clock calibration counter is done.  This field is reset during DEEPSLEEP mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_SET</name>
          <description>SRSS Interrupt Set Register</description>
          <addressOffset>0x704</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x23</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>Set interrupt for low voltage detector WDT_MATCH</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1</name>
              <description>Set interrupt for low voltage detector HVLVD1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Set interrupt for clock calibration counter done.  This field is reset during DEEPSLEEP mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_MASK</name>
          <description>SRSS Interrupt Mask Register</description>
          <addressOffset>0x708</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x23</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>Mask for watchdog timer.  Clearing this bit will not forward the interrupt to the CPU.  It will not, however, disable the WDT reset generation on 2 missed interrupts.  When WDT resets the chip, it also internally pends an interrupt that survives the reset.  To prevent unintended ISR execution, clear SRSS_INTR.WDT_MATCH before setting this bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1</name>
              <description>Mask for low voltage detector HVLVD1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Mask for clock calibration done</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_MASKED</name>
          <description>SRSS Interrupt Masked Register</description>
          <addressOffset>0x70C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x23</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HVLVD1</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_CFG</name>
          <description>SRSS Interrupt Configuration Register</description>
          <addressOffset>0x710</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>HVLVD1_EDGE_SEL</name>
              <description>Sets which edge(s) will trigger an IRQ for HVLVD1</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RES_CAUSE</name>
          <description>Reset Cause Observation Register</description>
          <addressOffset>0x800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FF</resetMask>
          <fields>
            <field>
              <name>RESET_WDT</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_ACT_FAULT</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_DPSLP_FAULT</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_CSV_WCO_LOSS</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_SOFT</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT0</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT1</name>
              <description>N/A</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT2</name>
              <description>Multi-Counter Watchdog timer reset #2 has occurred since last power cycle.  This hardware is not present in PSoC6 devices.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT3</name>
              <description>Multi-Counter Watchdog timer reset #3 has occurred since last power cycle. This hardware is not present in PSoC6 devices.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RES_CAUSE2</name>
          <description>Reset Cause Observation Register 2</description>
          <addressOffset>0x804</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESET_CSV_HF_LOSS</name>
              <description>Clock supervision logic requested a reset due to loss of a high-frequency clock.  Each bit index K corresponds to a HFCLK&lt;K&gt;.  Unimplemented clock bits return zero.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_CSV_HF_FREQ</name>
              <description>Clock supervision logic requested a reset due to frequency error of high-frequency clock.  Each bit index K corresponds to a HFCLK&lt;K&gt;.  Unimplemented clock bits return zero.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_TRIM_REF_CTL</name>
          <description>Reference Trim Register</description>
          <addressOffset>0x7F00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x70F00000</resetValue>
          <resetMask>0xF1FF5FFF</resetMask>
          <fields>
            <field>
              <name>ACT_REF_TCTRIM</name>
              <description>Active-Reference temperature trim.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0 -&gt; default setting at POR; not for trimming use
others -&gt; normal trim range</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_REF_ITRIM</name>
              <description>Active-Reference current trim.   This register is only reset by XRES/POR/BOD/HIBERNATE.
0 -&gt; default setting at POR; not for trimming use
others -&gt; normal trim range</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_REF_ABSTRIM</name>
              <description>Active-Reference absolute voltage trim.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0 -&gt; default setting at POR; not for trimming use
others -&gt; normal trim range</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_REF_IBOOST</name>
              <description>Active-Reference current boost.   This register is only reset by XRES/POR/BOD/HIBERNATE.
0: normal operation
others: risk mitigation</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPSLP_REF_TCTRIM</name>
              <description>DeepSleep-Reference temperature trim.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0 -&gt; default setting at POR; not for trimming use
others -&gt; normal trim range</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPSLP_REF_ABSTRIM</name>
              <description>DeepSleep-Reference absolute voltage trim.  This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[24:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPSLP_REF_ITRIM</name>
              <description>DeepSleep current reference trim.   This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[31:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_TRIM_BODOVP_CTL</name>
          <description>BOD/OVP Trim Register</description>
          <addressOffset>0x7F04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40D04</resetValue>
          <resetMask>0xFDFF7</resetMask>
          <fields>
            <field>
              <name>HVPORBOD_TRIPSEL</name>
              <description>HVPORBOD trip point selection.  Monitors vddd.  This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVPORBOD_OFSTRIM</name>
              <description>HVPORBOD offset trim.  This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVPORBOD_ITRIM</name>
              <description>HVPORBOD current trim.  This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[9:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LVPORBOD_TRIPSEL</name>
              <description>LVPORBOD trip point selection.  Monitors vccd.  This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[12:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LVPORBOD_OFSTRIM</name>
              <description>LVPORBOD offset trim.  This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[16:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LVPORBOD_ITRIM</name>
              <description>LVPORBOD current trim.  This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[19:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_CCO_CTL</name>
          <description>CCO Trim Register</description>
          <addressOffset>0x7F08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA7000020</resetValue>
          <resetMask>0xBF00003F</resetMask>
          <fields>
            <field>
              <name>CCO_RCSTRIM</name>
              <description>CCO reference current source trim.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_STABLE_CNT</name>
              <description>Terminal count for the stabilization counter from CCO_ENABLE until stable.</description>
              <bitRange>[29:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_CNT</name>
              <description>Enables the automatic stabilization counter.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_CCO_CTL2</name>
          <description>CCO Trim Register 2</description>
          <addressOffset>0x7F0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x884110</resetValue>
          <resetMask>0x1FFFFFF</resetMask>
          <fields>
            <field>
              <name>CCO_FCTRIM1</name>
              <description>CCO frequency 1st range calibration</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_FCTRIM2</name>
              <description>CCO frequency 2nd range calibration</description>
              <bitRange>[9:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_FCTRIM3</name>
              <description>CCO frequency 3rd range calibration</description>
              <bitRange>[14:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_FCTRIM4</name>
              <description>CCO frequency 4th range calibration</description>
              <bitRange>[19:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_FCTRIM5</name>
              <description>CCO frequency 5th range calibration</description>
              <bitRange>[24:20]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_TRIM_WAKE_CTL</name>
          <description>Wakeup Trim Register</description>
          <addressOffset>0x7F30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>WAKE_DELAY</name>
              <description>Wakeup holdoff.  Spec (fastest) wake time is achieved with a setting of 0.  Additional delay can be added for debugging or workaround.  The delay is counted by the IMO.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_TRIM_LVD_CTL</name>
          <description>LVD Trim Register</description>
          <addressOffset>0xFF10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20</resetValue>
          <resetMask>0x77</resetMask>
          <fields>
            <field>
              <name>HVLVD1_OFSTRIM</name>
              <description>HVLVD1 offset trim</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_ITRIM</name>
              <description>HVLVD1 current trim</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_ILO_CTL</name>
          <description>ILO Trim Register</description>
          <addressOffset>0xFF18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2C</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>ILO_FTRIM</name>
              <description>ILO frequency trims.  LSB step size is 1.5 percent (typical) of the frequency.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_TRIM_PWRSYS_CTL</name>
          <description>Power System Trim Register</description>
          <addressOffset>0xFF1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x17</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>ACT_REG_TRIM</name>
              <description>Trim for the Active-Regulator.  This sets the output voltage level.  This register is only reset by XRES/POR/BOD/HIBERNATE.  The nominal output voltage is vccd=812.5mV + ACT_REG_TRIM*12.5mV.  The actual output voltage will vary depending on conditions and load.  The following settings are explicitly shown for convenience, and other values may be calculated using the formula:
5'h07: 900mV (nominal)
5'h17: 1100mV (nominal)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_REG_BOOST</name>
              <description>Controls the tradeoff between output current and internal operating current for the Active Regulator.  The maximum output current depends on the silicon implementation, but an application may limit its maximum current to less than that.  This may allow a reduction in the internal operating current of the regulator.  The regulator internal operating current depends on the boost setting:
2'b00: 50uA
2'b01: 100uA
2'b10: 150uA
2'b11: 200uA

The allowed setting is a lookup table based on the chip-specific maximum (set in factory) and an application-specific maximum (set by customer).  The defaults are set assuming the application consumes the maximum allowed by the chip.
50mA chip: 2'b00 (default);
100mA chip: 2'b00 (default);
150mA chip: 50..100mA app =&gt; 2'b00, 150mA app =&gt; 2'b01 (default);
200mA chip: 50mA app =&gt; 2'b00, 100..150mA app =&gt; 2'b01,  200mA app =&gt; 2'b10 (default);
250mA chip: 50mA app =&gt; 2'b00, 100..150mA app =&gt; 2'b01,  200..250mA app =&gt; 2'b10 (default);
300mA chip: 50mA app =&gt; 2'b00, 100..150mA app =&gt; 2'b01, 200..250mA app =&gt; 2'b10, 300mA app =&gt; 2'b11 (default);

This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_ECO_CTL</name>
          <description>ECO Trim Register</description>
          <addressOffset>0xFF20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1F0003</resetValue>
          <resetMask>0x3F3FF7</resetMask>
          <fields>
            <field>
              <name>WDTRIM</name>
              <description>Watch Dog Trim -  Delta voltage below steady state level
0x0 - 50mV
0x1 - 75mV
0x2 - 100mV
0x3 - 125mV
0x4 - 150mV
0x5 - 175mV
0x6 - 200mV
0x7 - 225mV</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ATRIM</name>
              <description>Amplitude trim to set the crystal drive level when ECO_CONFIG.AGC_EN=1.  WARNING: use care when setting this field because driving a crystal beyond its rated limit can permanently damage the crystal.
0x0 - 150mV
0x1 - 175mV
0x2 - 200mV
0x3 - 225mV
0x4 - 250mV
0x5 - 275mV
0x6 - 300mV
0x7 - 325mV
0x8 - 350mV
0x9 - 375mV
0xA - 400mV
0xB - 425mV
0xC - 450mV
0xD - 475mV
0xE - 500mV
0xF - 525mV</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FTRIM</name>
              <description>Filter Trim - 3rd harmonic oscillation</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTRIM</name>
              <description>Feedback resistor Trim</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GTRIM</name>
              <description>Gain Trim - Startup time</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ITRIM</name>
              <description>Current Trim</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_PILO_CTL</name>
          <description>PILO Trim Register</description>
          <addressOffset>0xFF24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x108500F</resetValue>
          <resetMask>0x7DFF703F</resetMask>
          <fields>
            <field>
              <name>PILO_CFREQ</name>
              <description>Coarse frequency trim to meet 32.768kHz +/-2 percent across PVT without calibration.  The nominal step size of the LSB is 1kHz.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_OSC_TRIM</name>
              <description>Trim for current in oscillator block.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_COMP_TRIM</name>
              <description>Trim for comparator bias current.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_NBIAS_TRIM</name>
              <description>Trim for biasn by trimming sub-Vth NMOS width in beta-multiplier</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_RES_TRIM</name>
              <description>Trim for beta-multiplier branch current</description>
              <bitRange>[24:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_ISLOPE_TRIM</name>
              <description>Trim for beta-multiplier current slope</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_VTDIFF_TRIM</name>
              <description>Trim for VT-DIFF output (internal power supply)</description>
              <bitRange>[30:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_PILO_CTL2</name>
          <description>PILO Trim Register 2</description>
          <addressOffset>0xFF28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xDA10E0</resetValue>
          <resetMask>0xFF1FFF</resetMask>
          <fields>
            <field>
              <name>PILO_VREF_TRIM</name>
              <description>Trim for voltage reference</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_IREFBM_TRIM</name>
              <description>Trim for beta-multiplier current reference</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_IREF_TRIM</name>
              <description>Trim for current reference</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_PILO_CTL3</name>
          <description>PILO Trim Register 3</description>
          <addressOffset>0xFF2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x4800</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>PILO_ENGOPT</name>
              <description>Engineering options for PILO circuits
0: Short vdda to vpwr
1: Beta:mult current change
2: Iref generation Ptat current addition
3: Disable current path in secondary Beta:mult startup circuit
4: Double oscillator current
5: Switch between deep:sub:threshold and sub:threshold stacks in Vref generation block
6: Spare
7: Ptat component increase in Iref
8: vpwr_rc and vpwr_dig_rc shorting testmode
9: Switch b/w psub connection for cascode nfet for vref generation
10: Switch between sub:threshold and deep:sub:threshold stacks in comparator.
15-11: Frequency fine trim.  See AKK-444 for an overview of the trim strategy.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DW0</name>
      <description>Datawire Controller</description>
      <headerStructName>DW</headerStructName>
      <baseAddress>0x40280000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x80000003</resetMask>
          <fields>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC checking:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable parity injection for SRAM.
When '1', the parity (ECC_CTL.PARITY) is used when a full 32-bit write is done to the ECC_CTL.WORD_ADDR word address of the SRAM.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. Disabling the IP activates the IP's Active logic reset: Active logic and non-retention MMIO registers are reset (retention MMIO registers are not affected).
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF0000000</resetMask>
          <fields>
            <field>
              <name>P</name>
              <description>Active channel, user/privileged access control:
'0': user mode.
'1': privileged mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NS</name>
              <description>Active channel, secure/non-secure access control:
'0': secure.
'1': non-secure.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>B</name>
              <description>Active channel, non-bufferable/bufferable access control:
'0': non-bufferable
'1': bufferable.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PC</name>
              <description>Active channel protection context.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PRIO</name>
              <description>Active channel priority.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>Active channel preemptable.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CH_IDX</name>
              <description>Active channel index.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STATE</name>
              <description>State of the DW controller. 
'0': Default/inactive state.
'1': Loading descriptor.
'2': Loading data element from source location.
'3': Storing data element to destination location.
'4': CRC functionality (only used for CRC transfer descriptor type).
'5': Update of active control information (e.g. source and destination addresses) and wait for trigger de-activation.
'6': Error.</description>
              <bitRange>[30:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>Active channel present: 
'0': No.
'1': Yes.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_CTL</name>
          <description>Active descriptor control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_SRC</name>
          <description>Active descriptor source</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Copy of DESCR_SRC of the currently active descriptor.

Base address of source location.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_DST</name>
          <description>Active descriptor destination</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Copy of DESCR_DST of the currently active descriptor.

Base address of destination location. 

Note: For a CRC transfer descriptor, this field should be programmed with the address of the CRC_LFSR_CTL register. The calculated CRC LFSR state is written to this address (through the CRYPTO AHB-Lite master interface) when the input trigger is processed. The write transfer will be submitted to the CPUSS and PERI protection schemes.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_X_CTL</name>
          <description>Active descriptor X loop control</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Copy of DESCR_X_CTL of the currently active descriptor.

[11:0] SRC_X_INCR
Specifies increment of source address for each X loop iteration (in multiples of SRC_TRANSFER_SIZE). This field is a signed number in the range [-2048, 2047]. If this field is '0', the source address is not incremented. This is useful for reading from RX FIFO structures.

[23:12] DST_X_INCR
Specifies increment of destination address for each X loop iteration (in multiples of DST_TRANSFER_SIZE). This field is a signed number in the range [-2048, 2047]. If this field is '0', the destination address is not incremented. This is useful for writing to TX FIFO structures.

Note: this field is not used for CRC transfer descriptors and must be set to '0'.

[31:24] X_COUNT
Number of iterations (minus 1) of the 'X loop' (X_COUNT+1 is the number of single transfers in a 1D transfer). This field is an unsigned number in the range [0, 255], representing 1 through 256 iterations.

For a single transfer descriptor type, descriptor will not have X_CTL.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_Y_CTL</name>
          <description>Active descriptor Y loop control</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Copy of DESCR_Y_CTL of the currently active descriptor.

[11:0] SRC_Y_INCR
Specifies increment of source address for each Y loop iteration (in multiples of SRC_TRANSFER_SIZE). This field is a signed number in the range [-2048, 2047].

[23:12] DST_Y_INCR
Specifies increment of destination address for each Y loop iteration (in multiples of DST_TRANSFER_SIZE). This field is a signed number in the range [-2048, 2047].

[31:24] Y_COUNT
Number of iterations (minus 1) of the 'Y loop' (X_COUNT+1)*(Y_COUNT+1) is the number of single transfers in a 2D transfer). This field is an unsigned number in the range [0, 255], representing 1 through 256 iterations.

For single, 1D and CRC transfer descriptor types, descriptor will not have Y_CTL.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_NEXT_PTR</name>
          <description>Active descriptor next pointer</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Copy of DESCR_NEXT_PTR of the currently active descriptor.

[31:2] ADDR
Address of next descriptor in descriptor list. When this field is '0', this is the last descriptor in the descriptor list.</description>
              <bitRange>[31:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_SRC</name>
          <description>Active source</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>SRC_ADDR</name>
              <description>Current address of source location.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DST</name>
          <description>Active destination</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DST_ADDR</name>
              <description>Current address of destination location.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFE0003FF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where an error will be injected.
- On a write transfer to this SRAM word address and when CTL.ECC_INJ_EN bit is '1', the parity (PARITY) is injected.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR.</description>
              <bitRange>[31:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_CTL</name>
          <description>CRC control</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x101</resetMask>
          <fields>
            <field>
              <name>DATA_REVERSE</name>
              <description>Specifies the bit order in which a data Byte is processed (reversal is performed after XORing):
'0': Most significant bit (bit 1) first.
'1': Least significant bit (bit 0) first.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REM_REVERSE</name>
              <description>Specifies whether the remainder is bit reversed (reversal is performed after XORing):
'0': No.
'1': Yes.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_DATA_CTL</name>
          <description>CRC data control</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA_XOR</name>
              <description>Specifies a byte mask with which each data byte is XOR'd. The XOR is performed before data reversal.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_POL_CTL</name>
          <description>CRC polynomial control</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POLYNOMIAL</name>
              <description>CRC polynomial. The polynomial is represented WITHOUT the high order bit (this bit is always assumed '1'). The polynomial should be aligned/shifted such that the more significant bits (bit 31 and down) contain the polynomial and the less significant bits (bit 0 and up) contain padding '0's. Some frequently used polynomials:
- CRC32: POLYNOMIAL is 0x04c11db7 (x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1).
- CRC16: POLYNOMIAL is 0x80050000 (x^16 + x^15 + x^2 + 1, shifted by 16 bit positions).
- CRC16 CCITT: POLYNOMIAL is 0x10210000 (x^16 + x^12 + x^5 + 1, shifted by 16 bit positions).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_LFSR_CTL</name>
          <description>CRC LFSR control</description>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LFSR32</name>
              <description>State of a 32-bit Linear Feedback Shift Registers (LFSR) that is used to implement CRC. This register needs to be initialized by SW to provide the CRC seed value.

The seed value should be aligned such that the more significant bits (bit 31 and down) contain the seed value and the less significant bits (bit 0 and up) contain padding '0's.  

Note that SW can write this field. This functionality can be used prevent information leakage (through either CRC_LFSR_CTL or CRC_REM_RESULT).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_REM_CTL</name>
          <description>CRC remainder control</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REM_XOR</name>
              <description>Specifies a mask with which the CRC_LFSR_CTL.LFSR32 register is XOR'd to produce a remainder. The XOR is performed before remainder reversal.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_REM_RESULT</name>
          <description>CRC remainder result</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REM</name>
              <description>Remainder value. The alignment of the remainder depends on CRC_REM_CTL0.REM_REVERSE: 
'0': the more significant bits (bit 31 and down) contain the remainder.
'1': the less significant bits (bit 0 and up) contain the remainder. 

Note: This field is combinatorially derived from CRC_LFSR_CTL.LFSR32, CRC_CTL.REM_REVERSE and CRC_REM_CTL.REM_XOR.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>32</dim>
          <dimIncrement>64</dimIncrement>
          <name>CH_STRUCT[%s]</name>
          <description>DW channel structure</description>
          <addressOffset>0x00008000</addressOffset>
          <register>
            <name>CH_CTL</name>
            <description>Channel control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000300</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the transaction that writes this register; i.e.  the 'write data' is ignored and instead the access control is inherited from the write transaction (note the field attributes should be HW:RW, SW:R).

All transactions for this channel use the P field for the user/privileged access control ('hprot[1]').</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>Secure/on-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the transaction that writes this register; i.e.  the 'write data' is ignored and instead the access control is inherited from the write transaction (note the field attributes should be HW:RW, SW:R).

All transactions for this channel use the NS field for the secure/non-secure access control ('hprot[4]').</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>B</name>
                <description>Non-bufferable/bufferable access control:
'0': non-bufferable.
'1': bufferable.

This field is used to indicate to an AMBA bridge that a write transaction can complete without waiting for the destination to accept the write transaction data.

All transactions for this channel uses the B field for the non-bufferable/bufferable access control ('hprot[2]').</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC</name>
                <description>Protection context.

This field is set with the protection context of the transaction that writes this register;  i.e.  the 'write data' is ignored and instead the context is inherited from the write transaction (note the field attributes should be HW:RW, SW:R).

All transactions for this channel uses the PC field for the protection context.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>Channel priority:
'0': highest priority.
'1'
'2'
'3': lowest priority.

Channels with the same priority constitute a priority group. Priority decoding determines the highest priority pending channel. This channel is determined as follows. First, the highest priority group with pending channels is identified. Second, within this priority group, round robin arbitration is applied. Round robin arbitration (within a priority group) gives the highest priority to the lower channel indices (within the priority group).</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PREEMPTABLE</name>
                <description>Specifies if the channel is preemptable.
'0': Not preemptable.
'1': Preemptable. This field allows higher priority pending channels (from a higher priority group; i.e. an active channel can NOT be preempted by a pending channel in the same priority group) to preempt the active channel in between 'single transfers' (a 1D transfer consists out of X_COUNT single transfers; a 2D transfer consists out of X_COUNT*Y_COUNT single transfers). Preemption will NOT affect the pending status of channel. As a result, after completion of a higher priority activated channel, the current channel may be reactivated.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Channel enable:
'0': Disabled. The channel's trigger is ignored and the channel cannot be made pending and therefore cannot be made active. If a pending channel is disabled, the channel is made non pending. If the activate channel is disabled, the channel is de-activated (bus transactions are completed). 
'1': Enabled.

SW sets this field to '1' to enable a specific channel.

HW sets this field to '0' on an error interrupt cause (the specific error is specified by CH_STATUS.INTR_CAUSE).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CH_STATUS</name>
            <description>Channel status</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>INTR_CAUSE</name>
                <description>Specifies the source of the interrupt cause:
'0': No interrupt generated
'1': Interrupt based on transfer complettion configuration based on INTR_TYPE
'2': Source transfer bus error
'3': Destination transfer bus error
'4': Source address misalignment
'5': Destination address misalignment
'6': Current descriptor pointer is null
'7': Active channel is disabled
'8': Descriptor bus error
'9'-'15': Not used.

For error related interrupt causes (INTR_CAUSE is '2', '3', ..., '8'), the channel is disabled (HW sets CH_CTL.ENABLED to '0').</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PENDING</name>
                <description>Specifies pending DW channels; i.e. enabled channels whose trigger got activated. This field includes all channels that are in the pending state (not scheduled) or active state (scheduled and performing data transfer(s)).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CH_IDX</name>
            <description>Channel current indices</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>X_IDX</name>
                <description>Specifies the X loop index. In the range of [0, X_COUNT], with X_COUNT taken from the current descriptor. 

Note: HW sets this field to '0' when it updates the current descriptor pointer CH_CURR_PTR with DESCR_NEXT_PTR after execution of the current descriptor. 

Note: SW should set this field to '0' when it updates CH_CURR_PTR.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>Y_IDX</name>
                <description>Specifies the Y loop index, with X_COUNT taken from the current descriptor. 

Note: HW sets this field to '0' when it updates the current descriptor pointer CH_CURR_PTR with DESCR_NEXT_PTR after execution of the current descriptor. 

Note: SW should set this field to '0' when it updates CH_CURR_PTR.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CH_CURR_PTR</name>
            <description>Channel current descriptor pointer</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Address of current descriptor. When this field is '0', there is no valid descriptor.

Note: HW updates the current descriptor pointer CH_CURR_PTR with DESCR_NEXT_PTR after execution of the current descriptor. 

Note: Typically, when SW updates the current descriptor pointer CH_CURR_PTR, it also sets CH_IDX.X_IDX and CH_IDX.Y_IDX to '0'.</description>
                <bitRange>[31:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>Set to '1', when event (as specified by CH_STATUS.INTR_CAUSE) is detected. Write INTR.CH field with '1', to clear bit. Write INTR_SET.CH field with '1', to set bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR.CH field (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SRAM_DATA0</name>
            <description>SRAM data 0</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>N/A</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SRAM_DATA1</name>
            <description>SRAM data 1</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>N/A</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CMD</name>
            <description>Channel software trigger</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>ACTIVATE</name>
                <description>Software trigger. When written with '1', a trigger is generated which sets 'trigger pending' (only if the channel is enabled). A read always returns a 0.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral derivedFrom="DW0">
      <name>DW1</name>
      <baseAddress>0x40290000</baseAddress>
    </peripheral>
    <peripheral>
      <name>DMAC</name>
      <description>DMAC</description>
      <baseAddress>0x402A0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. All non-retention registers (command and status registers) are reset to their default value when the IP is disabled. All retention registers retain their value when the IP is disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ACTIVE</name>
          <description>Active channels</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ACTIVE</name>
              <description>Specifies active channels; i.e. enabled channels whose trigger got activated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>6</dim>
          <dimIncrement>256</dimIncrement>
          <name>CH[%s]</name>
          <description>DMA controller channel</description>
          <addressOffset>0x00001000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Channel control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2</resetValue>
            <resetMask>0x800003F7</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the transaction that writes this register; i.e. the access control is inherited from the write transaction and not specified by the transaction write data.

All transactions for this channel use the P field for the user/privileged access control.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>Secure/on-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the transaction that writes this register; i.e. the access control is inherited from the write transaction and not specified by the transaction write data.

All transactions for this channel use the NS field for the secure/non-secure access control.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>B</name>
                <description>Non-bufferable/bufferable access control:
'0': non-bufferable.
'1': bufferable.

This field is used to indicate to an AMBA bridge that a write transaction can complete without waiting for the destination to accept the write transaction data.

All transactions for this channel uses the B field for the non-bufferable/bufferable access control.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC</name>
                <description>N/A</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>N/A</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>N/A</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IDX</name>
            <description>Channel current indices</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>X</name>
                <description>Specifies the X loop index. In the range of [0, X_COUNT], with X_COUNT taken from the current descriptor. 

Note: HW sets this field to '0' when it loads a descriptor.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>Y</name>
                <description>Specifies the Y loop index, with Y_COUNT taken from the current descriptor. 

Note: HW sets this field to '0' when it loads a descriptor..</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SRC</name>
            <description>Channel current source address</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Current address of source location.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DST</name>
            <description>Channel current destination address</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Current address of destination location.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CURR</name>
            <description>Channel current descriptor pointer</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>PTR</name>
                <description>Address of current descriptor. When this field is '0', there is no valid descriptor.

Note: HW updates the current descriptor pointer CH_CURR_PTR with DESCR_NEXT_PTR after execution of the current descriptor.</description>
                <bitRange>[31:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CMD</name>
            <description>Channle software trigger</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>ACTIVATE</name>
                <description>Software trigger. When written with '1', a trigger is generated which sets 'trigger pending' (only if the channel is enabled). A read always returns a 0.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_STATUS</name>
            <description>Channel descriptor status</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>VALID</name>
                <description>Indicates whether the descriptor information present in DESCR_CTL, DESCR_SRC, DESCR_DST, DESCR_X_SIZE, DESCR_X_INCR, DESCR_Y_SIZE, DESCR_Y_INCR, DESCR_NEXT status registers is valid or not.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_CTL</name>
            <description>Channel descriptor control</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>WAIT_FOR_DEACT</name>
                <description>Specifies whether the controller should wait for the input trigger to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller with the agent that generated the trigger. This field is ONLY used at the completion of the transfer as specified by TR_IN. E.g., a TX FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the controller AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW controller performance.
'0': Do not wait for trigger de-activation (for pulse sensitive triggers).
'1': Wait for up to 4 cycles.
'2': Wait for up to 16 cycles.
'3': Wait indefinitely. This option may result in controller lockup if the trigger is not de-activated.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INTR_TYPE</name>
                <description>Specifies when a completion interrupt is generated (CH_STATUS.INTR_CAUSE is set to COMPLETION):
'0': An interrupt is generated after a single transfer. 
'1': An interrupt is generated after a single 1D transfer or a memory copy transfer
- If the descriptor type is 'single', the interrupt is generated after a single transfer.
- If the descriptor type is '1D' or '2D', the interrupt is generated after the execution of a 1D transfer.
- If the descriptor type is 'memory copy', the interrupt is generated after the execution of a memory copy transfer.
- If the descriptor type is 'scatter' the interrupt is generated after the execution of a scatter transfer.
'2': An interrupt is generated after the execution of the current descriptor (independent of the value of DESCR_NEXT_PTR.ADDR of the current descriptor).
'3': An interrupt is generated after the execution of the current descriptor and the current descriptor's DESCR_NEXT_PTR.ADDR is '0'.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TR_OUT_TYPE</name>
                <description>Specifies when an output trigger is generated:
'0': An output trigger is generated after a single transfer. 
'1': An output trigger is generated after a single 1D transfer or a memory copy transfer.
- If the descriptor type is 'single', the output trigger is generated after a single transfer.
- If the descriptor type is '1D' or '2D', the output trigger is generated after the execution of a 1D transfer.
- If the descriptor type is 'memory copy', the output trigger is generated after the execution of a memory copy transfer.
- If the descriptor type is 'scatter', the output trigger is generated after the execution of a scatter transfer.
'2': An output trigger is generated after the execution of the current descriptor. 
'3': An output trigger is generated after the execution of a descriptor list: after the execution of the current descriptor AND the current descriptor's DESCR_NEXT_PTR.ADDR is '0'.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TR_IN_TYPE</name>
                <description>Specifies the input trigger type (not to be confused with the descriptor type):
'0': A trigger results in the execution of a single transfer. The descriptor type can be single, 1D or 2D.
'1': A trigger results in the execution of a single 1D transfer.
- If the descriptor type is 'single', the trigger results in the execution of a single transfer.
- If the descriptor type is '1D' or '2D', the trigger results in the execution of a 1D transfer.
- If the descriptor type is 'memory copy', the trigger results in the execution of a memory copy transfer.
- If the descriptor type is 'scatter', the trigger results in the execution of an scatter transfer.
'2': A trigger results in the execution of the current descriptor. 
'3': A trigger results in the execution of the current descriptor and continues (without requiring another input trigger) with the execution of the next descriptor using the next descriptor's information.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA_PREFETCH</name>
                <description>Source data prefetch:
'0': No source data prefetch. Source data transfers are only initiated AFTER the input trigger is activated.
'1': Source data prefetch. Source data transfers are initiated as soon as the channel is enabled, the current descriptor pointer is NOT '0' and there is space available in the channel's data FIFO. When the input trigger is activated, the trigger can initiate destination data transfers with data that is already in the channel's data FIFO. This effectively shortens the initial delay of the data transfer.

Note: data prefetch should be used with care, to ensure that data coherency is guaranteed and that prefetches do not cause undesired side effects.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA_SIZE</name>
                <description>Specifies the data element size:
'0': Byte (8 bits).
'1': Halfword (16 bits).
'2': Word (32 bits).
DATA_SIZE, SRC_TRANSFER_SIZE and DST_TRANSFER_SIZE together determine how data elements are transferred. The following are the 9 legal settings:
- DATA is 8 bit, SRC is 8 bit, DST is 8 bit.
- DATA is 8 bit, SRC is 32 bit (higher 24 bits are dropped), DST is 8 bit.
- DATA is 8 bit, SRC is 8 bit, DST is 32 bit (higher 24 bits are made '0').
- DATA is 8 bit, SRC is 32 bit (higher 24 bits are dropped), DST is 32 bit (higher 24 bits are made '0').
- DATA is 16 bit, SRC is 16 bit, DST is 16 bit.
- DATA is 16 bit, SRC is 32 bit (higher 16 bits are dropped), DST is 16 bit.
- DATA is 16 bit, SRC is 16 bit, DST is 32 bit (higher 16 bits are made '0').
- DATA is 16 bit, SRC is 32 bit (higher 16 bits are dropped), DST is 32 bit (higher 16 bits are made '0').
- DATA is 32 bit, SRC is 32 bit, DST is 32 bit.

Note: this field is not used for a 'memory copy' descriptor type. Note: this field must be set to '2' for a 'initialization' descriptor type.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CH_DISABLE</name>
                <description>Specifies whether the channel is disabled or not after completion of the current descriptor (independent of the value of the DESCR_NEXT_PTR value):
'0': Channel is not disabled.
'1': Channel is disabled.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SRC_TRANSFER_SIZE</name>
                <description>Specifies the bus transfer size to the source location:
'0': As specified by DATA_SIZE.
'1': Word (32 bits).
Distinguishing bus transfer size from data element size allows for source components with data elements that are smaller than their 32-bit bus interface width. E.g., an ADC source has a 32-bit bus transfer size, but only provides a 16-bit data element.

Note: this field is not used for a 'memory copy' descriptor type. Note: this field must be set to '1' for a 'scatter' descriptor type.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_TRANSFER_SIZE</name>
                <description>Specifies the bus transfer size to the destination location:
'0': As specified by DATA_SIZE.
'1': Word (32 bits).
Distinguishing bus transfer size from data element size allows for destination components with data elements that are smaller than their 32-bit bus interface width. E.g., a DAC destination has a 32-bit bus transfer size, but only requires a 16-bit data element.

Note: this field is not used for a 'memory copy' descriptor type. Note: this field must be set to '1' for a 'scatter' descriptor type.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DESCR_TYPE</name>
                <description>Specifies the descriptor type (not to be confused with the trigger type):
'0': Single transfer.
The DESCR_X_SIZE, DESCR_X_INCR, DESCR_Y_SIZE and DESCR_Y_INCR registers are NOT present. The DESCR_NEXT_PTR is at offset 0x0c.
'1': 1D transfer.
The DESCR_X_SIZE and DESCR_X_INCR registers are present, the DESCR_Y_SIZE and DESCR_Y_INCR are NOT present. A 1D transfer consists out of DESCR_X_SIZE.X_COUNT+1 single transfers. The DESCR_NEXT_PTR is at offset 0x14.
'2': 2D transfer.
The DESCR_X_SIZE, DESCR_X_INCR, DESCR_Y_SIZE and DESCR_Y_INCR registers are present. A 2D transfer consists of (DESCR_X_SIZE.X_COUNT+1)*(DESCR_Y_SIZE.Y_COUNT+1) single transfers. The DESCR_NEXT_PTR is at offset 0x1c.
'3': Memory copy.
The DESCR_X_SIZE register is present, the DESCR_X_INCR, DESCR_Y_SIZE and DESCR_Y_INCR are NOT present. A memory copy transfer copies DESCR_X_SIZE.X_COUNT+1 Bytes and may use Byte, halfword and word transfers. The DESCR_NEXT_PTR is at offset 0x10.
'4': Scatter transfer. The DESCR_X_SIZE register is present, the DESCR_DST, DESCR_X_INCR, DESCR_Y_SIZE and DESCR_Y_INCR are NOT present.
'5'-'7': Undefined.

After the execution of the current descriptor, the DESCR_NEXT_PTR address is copied to the channel's CH_CURR_PTR address and CH_STATUS.X_IDX and CH_STATUS.Y_IDX are set to '0'.</description>
                <bitRange>[30:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_SRC</name>
            <description>Channel descriptor source</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Base address of source location.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_DST</name>
            <description>Channel descriptor destination</description>
            <addressOffset>0x68</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Base address of destination location.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_X_SIZE</name>
            <description>Channel descriptor X size</description>
            <addressOffset>0x6C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>X_COUNT</name>
                <description>Number of iterations (minus 1) of the 'X loop' (X_COUNT+1 is the number of single transfers in a 1D transfer). This field is an unsigned number in the range [0, 65535], representing 1 through 65536 iterations.

For the 'memory copy' descriptor type, (X_COUNT + 1) is the number of transferred Bytes. For the 'scatter' descriptor type, ceiling(X_COUNT/2) is the number of (address, write data) initialization pairs processed.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_X_INCR</name>
            <description>Channel descriptor X increment</description>
            <addressOffset>0x70</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SRC_X</name>
                <description>Specifies increment of source address for each X loop iteration (in multiples of SRC_TRANSFER_SIZE). This field is a signed number (sign-magnitude format) in the range [-32768, 32767]. If this field is '0', the source address is not incremented. This is useful for reading from RX FIFO structures.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_X</name>
                <description>Specifies increment of destination address for each X loop iteration (in multiples of DST_TRANSFER_SIZE). This field is a signed number (sign-magnitude format) in the range [-32768, 32767]. If this field is '0', the destination address is not incremented. This is useful for writing to TX FIFO structures.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_Y_SIZE</name>
            <description>Channel descriptor Y size</description>
            <addressOffset>0x74</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>Y_COUNT</name>
                <description>Number of iterations (minus 1) of the 'Y loop' (X_COUNT+1)*(Y_COUNT+1) is the number of single transfers in a 2D transfer). This field is an unsigned number in the range [0, 65535], representing 1 through 65536 iterations.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_Y_INCR</name>
            <description>Channel descriptor Y increment</description>
            <addressOffset>0x78</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SRC_Y</name>
                <description>Specifies increment of source address for each Y loop iteration (in multiples of SRC_TRANSFER_SIZE). This field is a signed number in the range [-32768, 32767].</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_Y</name>
                <description>Specifies increment of destination address for each Y loop iteration (in multiples of DST_TRANSFER_SIZE). This field is a signed number in the range [-32768, 32767].</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_NEXT</name>
            <description>Channel descriptor next pointer</description>
            <addressOffset>0x7C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>PTR</name>
                <description>Address of next descriptor in descriptor list. When this field is '0', this is the last descriptor in the descriptor list.</description>
                <bitRange>[31:2]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>COMPLETION</name>
                <description>Activated (set to '1') on completion of data transfer(s) as specified by the descriptor's CH_DESCR_CTL.INTR_TYPE.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_BUS_ERROR</name>
                <description>Activated (set to '1') on a bus error for a load from the source.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_BUS_ERROR</name>
                <description>Activated (set to '1') on a bus error for a store to the destination.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_MISAL</name>
                <description>Activated (set to '1') on a misalignment of the source address.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_MISAL</name>
                <description>Activated (set to '1') on a misalignment of the destination address.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CURR_PTR_NULL</name>
                <description>Activated (set to '1') when the channel is enabled (CH_CTL.ENABLED is '1') and CH_CURR_PTR is '0'.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ACTIVE_CH_DISABLED</name>
                <description>Activated (set to '1') if the channel is disabled by SW (accidentally/incorrectly) when the data transfer engine is busy.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DESCR_BUS_ERROR</name>
                <description>Activated (set to '1') on a bus error for a load of the descriptor.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>COMPLETION</name>
                <description>Write this field with '1' to set INTR.COMPLETION field to '1' (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_BUS_ERROR</name>
                <description>Write this field with '1' to set INTR.SRC_BUS_ERROR field to '1' (a write of '0' has no effect).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_BUS_ERROR</name>
                <description>Write this field with '1' to set INTR.DST_BUS_ERROR field to '1' (a write of '0' has no effect).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_MISAL</name>
                <description>Write this field with '1' to set INTR.SRC_MISAL field to '1' (a write of '0' has no effect).</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_MISAL</name>
                <description>Write this field with '1' to set INTR.DST_MISAL field to '1' (a write of '0' has no effect).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CURR_PTR_NULL</name>
                <description>Write this field with '1' to set INTR.CURR_PTR_NULL field to '1' (a write of '0' has no effect).</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ACTIVE_CH_DISABLED</name>
                <description>Write this field with '1' to set INTR.ACT_CH_DISABLED field to '1' (a write of '0' has no effect).</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DESCR_BUS_ERROR</name>
                <description>Write this field with '1' to set INTR.DESCR_BUS_ERROR field to '1' (a write of '0' has no effect).</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0x88</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>COMPLETION</name>
                <description>Mask for INTR.COMPLETION interrupt.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_BUS_ERROR</name>
                <description>Mask for INTR.SRC_BUS_ERROR interrupt.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_BUS_ERROR</name>
                <description>Mask for INTR.DST_BUS_ERROR interrupt.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_MISAL</name>
                <description>Mask for INTR.SRC_MISAL interrupt.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_MISAL</name>
                <description>Mask for INTR.DST_MISAL interrupt.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CURR_PTR_NULL</name>
                <description>Mask for INTR.CURR_PTR_NULL interrupt.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ACTIVE_CH_DISABLED</name>
                <description>Mask for INTR.ACTIVE_CH_DISABLED interrupt.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DESCR_BUS_ERROR</name>
                <description>Mask for INTR.DESCR_BUS_ERROR interrupt.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0x8C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>COMPLETION</name>
                <description>Logical and of corresponding INTR.COMPLETION and INTR_MASK.COMPLETION fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SRC_BUS_ERROR</name>
                <description>Logical and of corresponding INTR.SRC_BUS_ERROR and INTR_MASK.SRC_BUS_ERROR fields.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_BUS_ERROR</name>
                <description>Logical and of corresponding INTR.DST_BUS_ERROR and INTR_MASK.DST_BUS_ERROR fields.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SRC_MISAL</name>
                <description>Logical and of corresponding INTR.SRC_MISAL and INTR_MASK.SRC_MISAL fields.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_MISAL</name>
                <description>Logical and of corresponding INTR.DST_MISAL and INTR_MASK.DST_MISAL fields.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CURR_PTR_NULL</name>
                <description>Logical and of corresponding INTR.CURR_PTR_NULL and INTR_MASK.CURR_PTR_NULL fields.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ACTIVE_CH_DISABLED</name>
                <description>Logical and of corresponding INTR.ACTIVE_CH_DISABLED and INTR_MASK.ACTIVE_CH_DISABLED fields.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DESCR_BUS_ERROR</name>
                <description>Logical and of corresponding INTR.DESCR_BUS_ERROR and INTR_MASK.DESCR_BUS_ERROR fields.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>EFUSE</name>
      <description>EFUSE MXS40 registers</description>
      <baseAddress>0x402C0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>128</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. All non-retention registers (command and status registers) are reset to their default value when the IP is disabled. All retention registers retain their value when the IP is disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>Command</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x800F1F71</resetMask>
          <fields>
            <field>
              <name>BIT_DATA</name>
              <description>Bit data. This field specifies the bit value that is to be programmed into the eFUSE macro array. The address of the bit is specified by the BIT_ADDR, BYTE_ADDR, and MACRO_ADDR fields. This bit is a don't care for the MXS40 Macro.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BIT_ADDR</name>
              <description>Bit address. This field specifies a bit within a Byte.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTE_ADDR</name>
              <description>Byte address. This field specifies a Byte within a eFUSE macro (each macro has 32 B).</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MACRO_ADDR</name>
              <description>Macro address. This field specifies an eFUSE macro.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>START</name>
              <description>FW sets this field to '1' to start a program operation. HW sets this field to '0' to indicate that the operation has completed.

Note: it is good practice to verify the result of a program operation by reading back a programmed eFUSE memory location. Programming can only change an eFUSE memory bit from '0' to '1'; i.e. a programming operation is a 'one-off' operation for each eFUSE memory bit: once a bit is changed to '1', it can NEVER be changed back to '0' as a hardware fuse is blown.

Programming a memory bit to '1' requires blowing a fuse and requires an eFUSE macro operation. Therefore, this programmiong operation takes time (as specified by the SEQ_PROGRAM_CTL reguisters). Programming amemory bit to '0' does not require an eFUSE macro operation (it is the default eFUSE macro state). Therefore, this programming operation is almost instantaneous.

Note: during a program operation, a read operation can not be performed. An AHB-Lite read transfer to the eFUSE memory during a program operation results in an AHB-Lite bus error.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_DEFAULT</name>
          <description>Sequencer Default value</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1D0000</resetValue>
          <resetMask>0x7F0000</resetMask>
          <fields>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_0</name>
          <description>Sequencer read control 0</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80560001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_1</name>
          <description>Sequencer read control 1</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x540004</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_2</name>
          <description>Sequencer read control 2</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x560001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_3</name>
          <description>Sequencer read control 3</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x540003</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_4</name>
          <description>Sequencer read control 4</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80150001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_5</name>
          <description>Sequencer read control 5</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x310004</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_0</name>
          <description>Sequencer program control 0</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x200001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_1</name>
          <description>Sequencer program control 1</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x220020</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_2</name>
          <description>Sequencer program control 2</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x200001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_3</name>
          <description>Sequencer program control 3</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x310005</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_4</name>
          <description>Sequencer program control 4</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80350006</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_5</name>
          <description>Sequencer program control 5</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x803D0019</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HSIOM</name>
      <description>High Speed IO Matrix (HSIOM)</description>
      <baseAddress>0x40300000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>16384</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>14</dim>
          <dimIncrement>16</dimIncrement>
          <name>PRT[%s]</name>
          <description>HSIOM port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>PORT_SEL0</name>
            <description>Port selection 0</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>IO0_SEL</name>
                <description>Selects the peripheral connections of Pin 0. Note that available connectivity options vary depending on the device, port and the pin. See the device Datasheet for a list of peripheral connections available at each pin.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <description>GPIO controls 'out'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO_DSI</name>
                    <description>GPIO controls 'out', DSI controls 'output enable'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DSI_DSI</name>
                    <description>DSI controls 'out' and 'output enable'</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DSI_GPIO</name>
                    <description>DSI controls 'out', GPIO controls 'output enable'</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXA</name>
                    <description>Analog mux bus A</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXB</name>
                    <description>Analog mux bus B</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXA_DSI</name>
                    <description>Analog mux bus A, DSI control</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXB_DSI</name>
                    <description>Analog mux bus B, DSI control</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_0</name>
                    <description>Active functionality 0</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_1</name>
                    <description>Active functionality 1</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_2</name>
                    <description>Active functionality 2</description>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_3</name>
                    <description>Active functionality 3</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_0</name>
                    <description>DeepSleep functionality 0</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_1</name>
                    <description>DeepSleep functionality 1</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_2</name>
                    <description>DeepSleep functionality 2</description>
                    <value>14</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_3</name>
                    <description>DeepSleep functionality 3</description>
                    <value>15</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_4</name>
                    <description>Active functionality 4</description>
                    <value>16</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_5</name>
                    <description>Active functionality 5</description>
                    <value>17</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_6</name>
                    <description>Active functionality 6</description>
                    <value>18</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_7</name>
                    <description>Active functionality 7</description>
                    <value>19</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_8</name>
                    <description>Active functionality 8</description>
                    <value>20</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_9</name>
                    <description>Active functionality 9</description>
                    <value>21</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_10</name>
                    <description>Active functionality 10</description>
                    <value>22</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_11</name>
                    <description>Active functionality 11</description>
                    <value>23</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_12</name>
                    <description>Active functionality 12</description>
                    <value>24</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_13</name>
                    <description>Active functionality 13</description>
                    <value>25</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_14</name>
                    <description>Active functionality 14</description>
                    <value>26</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_15</name>
                    <description>Active functionality 15</description>
                    <value>27</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_4</name>
                    <description>DeepSleep functionality 4</description>
                    <value>28</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_5</name>
                    <description>DeepSleep functionality 5</description>
                    <value>29</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_6</name>
                    <description>DeepSleep functionality 6</description>
                    <value>30</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_7</name>
                    <description>DeepSleep functionality 7</description>
                    <value>31</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IO1_SEL</name>
                <description>Selects the peripheral connections of Pin 1.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO2_SEL</name>
                <description>Selects the peripheral connections of Pin 2.</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO3_SEL</name>
                <description>Selects the peripheral connections of Pin 3.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PORT_SEL1</name>
            <description>Port selection 1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>IO4_SEL</name>
                <description>Selects the peripheral connections of Pin 4. See PORT_SEL0 for connection details.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO5_SEL</name>
                <description>Selects the peripheral connections of Pin 4.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO6_SEL</name>
                <description>Selects the peripheral connections of Pin 5.</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO7_SEL</name>
                <description>Selects the peripheral connections of Pin 6.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>AMUX_SPLIT_CTL[%s]</name>
          <description>AMUX splitter cell control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x77</resetMask>
          <fields>
            <field>
              <name>SWITCH_AA_SL</name>
              <description>T-switch control for Left AMUXBUSA switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_AA_SR</name>
              <description>T-switch control for Right AMUXBUSA switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_AA_S0</name>
              <description>T-switch control for AMUXBUSA vssa/ground switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_SL</name>
              <description>T-switch control for Left AMUXBUSB switch.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_SR</name>
              <description>T-switch control for Right AMUXBUSB switch.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_S0</name>
              <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_0</name>
          <description>Power/Ground Monitor cell control 0</description>
          <addressOffset>0x2200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_1</name>
          <description>Power/Ground Monitor cell control 1</description>
          <addressOffset>0x2204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_2</name>
          <description>Power/Ground Monitor cell control 2</description>
          <addressOffset>0x2208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_3</name>
          <description>Power/Ground Monitor cell control 3</description>
          <addressOffset>0x220C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALT_JTAG_EN</name>
          <description>Alternate JTAG IF selection register</description>
          <addressOffset>0x2240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Provides the selection for alternate JTAG IF connectivity.
0: Primary JTAG interface is selected
1: Secondary (alternate) JTAG interface is selected.

This connectivity works ONLY in ACTIVE mode.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIO</name>
      <description>GPIO port control/configuration</description>
      <baseAddress>0x40310000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>14</dim>
          <dimIncrement>128</dimIncrement>
          <name>PRT[%s]</name>
          <description>GPIO port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>OUT</name>
            <description>Port output data register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO output data for pin 0
'0': Output state set to '0'
'1': Output state set to '1'</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO output data for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO output data for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO output data for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO output data for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO output data for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO output data for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO output data for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OUT_CLR</name>
            <description>Port output data clear register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO clear output for pin 0:
'0': Output state not affected.
'1': Output state set to '0'.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO clear output for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO clear output for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO clear output for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO clear output for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO clear output for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO clear output for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO clear output for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OUT_SET</name>
            <description>Port output data set register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO set output for pin 0:
'0': Output state not affected.
'1': Output state set to '1'.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO set output for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO set output for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO set output for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO set output for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO set output for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO set output for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO set output for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OUT_INV</name>
            <description>Port output data invert register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO invert output for pin 0:
'0': Output state not affected.
'1': Output state inverted ('0' =&gt; '1', '1' =&gt; '0').</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO invert output for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO invert output for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO invert output for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO invert output for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO invert output for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO invert output for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO invert output for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IN</name>
            <description>Port input state register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>IN0</name>
                <description>IO pin state for pin 0
'0': Low logic level present on pin.
'1': High logic level present on pin.
On reset assertion , IN register will get reset. The Pad value takes 2 clock cycles to be reflected into IN Register.  It's value then depends on the external pin value.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN1</name>
                <description>IO pin state for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN2</name>
                <description>IO pin state for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN3</name>
                <description>IO pin state for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN4</name>
                <description>IO pin state for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN5</name>
                <description>IO pin state for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN6</name>
                <description>IO pin state for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN7</name>
                <description>IO pin state for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_IN</name>
                <description>Reads of this register return the logical state of the filtered pin as selected in the INTR_CFG.FLT_SEL register.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Port interrupt status register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Edge detect for IO pin 0
'0': No edge was detected on pin.
'1': An edge was detected on pin.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Edge detect for IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Edge detect for IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Edge detect for IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Edge detect for IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Edge detect for IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Edge detect for IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Edge detect for IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Edge detected on filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_IN0</name>
                <description>IO pin state for pin 0</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN1</name>
                <description>IO pin state for pin 1</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN2</name>
                <description>IO pin state for pin 2</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN3</name>
                <description>IO pin state for pin 3</description>
                <bitRange>[19:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN4</name>
                <description>IO pin state for pin 4</description>
                <bitRange>[20:20]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN5</name>
                <description>IO pin state for pin 5</description>
                <bitRange>[21:21]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN6</name>
                <description>IO pin state for pin 6</description>
                <bitRange>[22:22]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN7</name>
                <description>IO pin state for pin 7</description>
                <bitRange>[23:23]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_IN_IN</name>
                <description>Filtered pin state for pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Port interrupt mask register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Masks edge interrupt on IO pin 0
'0': Pin interrupt forwarding disabled
'1': Pin interrupt forwarding enabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Masks edge interrupt on IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Masks edge interrupt on IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Masks edge interrupt on IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Masks edge interrupt on IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Masks edge interrupt on IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Masks edge interrupt on IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Masks edge interrupt on IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Masks edge interrupt on filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Port interrupt masked status register</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Edge detected AND masked on IO pin 0
'0': Interrupt was not forwarded to CPU
'1': Interrupt occurred and was forwarded to CPU</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Edge detected and masked on IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Edge detected and masked on IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Edge detected and masked on IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Edge detected and masked on IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Edge detected and masked on IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Edge detected and masked on IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Edge detected and masked on IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Edge detected and masked on filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Port interrupt set register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Sets edge detect interrupt for IO pin 0
'0': Interrupt state not affected
'1': Interrupt set</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Sets edge detect interrupt for IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Sets edge detect interrupt for IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Sets edge detect interrupt for IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Sets edge detect interrupt for IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Sets edge detect interrupt for IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Sets edge detect interrupt for IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Sets edge detect interrupt for IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Sets edge detect interrupt for filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_CFG</name>
            <description>Port interrupt configuration register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FFFFF</resetMask>
            <fields>
              <field>
                <name>EDGE0_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 0</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Disabled</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <description>Rising edge</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <description>Falling edge</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <description>Both rising and falling edges</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EDGE1_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 1</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 2</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 3</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 4</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 5</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 6</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 7</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE_SEL</name>
                <description>Sets which edge will trigger an IRQ for the glitch filtered pin (selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Disabled</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <description>Rising edge</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <description>Falling edge</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <description>Both rising and falling edges</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FLT_SEL</name>
                <description>Selects which pin is routed through the 50ns glitch filter to provide a glitch-safe interrupt.</description>
                <bitRange>[20:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG</name>
            <description>Port configuration register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DRIVE_MODE0</name>
                <description>The GPIO drive mode for IO pin 0. Resistive pull-up and pull-down is selected in the drive mode.
Note: when initializing IO's that are connected to a live bus (such as I2C), make sure the peripheral and HSIOM (HSIOM_PRT_SELx) is properly configured  before turning the IO on here to avoid producing glitches on the bus.
Note: that peripherals other than GPIO &amp; UDB/DSI directly control both the output and output-enable of the output buffer (peripherals can drive strong 0 or strong 1 in any mode except OFF='0').  
Note: D_OUT, D_OUT_EN are pins of GPIO cell.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>HIGHZ</name>
                    <description>Output buffer is off creating a high impedance input
D_OUT = '0': High Impedance
D_OUT = '1': High Impedance</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP</name>
                    <description>Resistive pull up</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLDOWN</name>
                    <description>Resistive pull down</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESLOW</name>
                    <description>Open drain, drives low</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESHIGH</name>
                    <description>Open drain, drives high</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STRONG</name>
                    <description>Strong D_OUTput buffer</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP_DOWN</name>
                    <description>Pull up or pull down</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IN_EN0</name>
                <description>Enables the input buffer for IO pin 0.  This bit should be cleared when analog signals are present on the pin to avoid crowbar currents.  The output buffer can be used to drive analog signals high or low without issue.
'0': Input buffer disabled
'1': Input buffer enabled</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE1</name>
                <description>The GPIO drive mode for IO pin 1</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN1</name>
                <description>Enables the input buffer for IO pin 1</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE2</name>
                <description>The GPIO drive mode for IO pin 2</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN2</name>
                <description>Enables the input buffer for IO pin 2</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE3</name>
                <description>The GPIO drive mode for IO pin 3</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN3</name>
                <description>Enables the input buffer for IO pin 3</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE4</name>
                <description>The GPIO drive mode for IO pin4</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN4</name>
                <description>Enables the input buffer for IO pin 4</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE5</name>
                <description>The GPIO drive mode for IO pin 5</description>
                <bitRange>[22:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN5</name>
                <description>Enables the input buffer for IO pin 5</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE6</name>
                <description>The GPIO drive mode for IO pin 6</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN6</name>
                <description>Enables the input buffer for IO pin 6</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE7</name>
                <description>The GPIO drive mode for IO pin 7</description>
                <bitRange>[30:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN7</name>
                <description>Enables the input buffer for IO pin 7</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_IN</name>
            <description>Port input buffer configuration register</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>VTRIP_SEL0_0</name>
                <description>N/A</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CMOS</name>
                    <description>S40S: Input buffer compatible with CMOS and I2C interfaces</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TTL</name>
                    <description>S40S: Input buffer compatible with TTL and MediaLB interfaces</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>VTRIP_SEL1_0</name>
                <description>N/A</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL2_0</name>
                <description>N/A</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL3_0</name>
                <description>N/A</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL4_0</name>
                <description>N/A</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL5_0</name>
                <description>N/A</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL6_0</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL7_0</name>
                <description>N/A</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_OUT</name>
            <description>Port output buffer configuration register</description>
            <addressOffset>0x4C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF00FF</resetMask>
            <fields>
              <field>
                <name>SLOW0</name>
                <description>Enables slow slew rate for IO pin 0
'0': Fast slew rate
'1': Slow slew rate</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW1</name>
                <description>Enables slow slew rate for IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW2</name>
                <description>Enables slow slew rate for IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW3</name>
                <description>Enables slow slew rate for IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW4</name>
                <description>Enables slow slew rate for IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW5</name>
                <description>Enables slow slew rate for IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW6</name>
                <description>Enables slow slew rate for IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW7</name>
                <description>Enables slow slew rate for IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL0</name>
                <description>Sets the GPIO drive strength for IO pin 0</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DRIVE_SEL_ZERO</name>
                    <description>Please refer to architecture TRM section I/O System</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DRIVE_SEL_ONE</name>
                    <description>Please refer to architecture TRM section I/O System</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DRIVE_SEL_TWO</name>
                    <description>Please refer to architecture TRM section I/O System</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DRIVE_SEL_THREE</name>
                    <description>Please refer to architecture TRM section I/O System</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DRIVE_SEL1</name>
                <description>Sets the GPIO drive strength for IO pin 1</description>
                <bitRange>[19:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL2</name>
                <description>Sets the GPIO drive strength for IO pin 2</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL3</name>
                <description>Sets the GPIO drive strength for IO pin 3</description>
                <bitRange>[23:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL4</name>
                <description>Sets the GPIO drive strength for IO pin 4</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL5</name>
                <description>Sets the GPIO drive strength for IO pin 5</description>
                <bitRange>[27:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL6</name>
                <description>Sets the GPIO drive strength for IO pin 6</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL7</name>
                <description>Sets the GPIO drive strength for IO pin 7</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_SIO</name>
            <description>Port SIO configuration register</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VREG_EN01</name>
                <description>The regulated output mode is selected ONLY if the CFG.DRIVE_MODE bits are set to the strong pull up (Z_1 = '5') mode If the CFG.DRIVE_MODE bits are set to any other mode the regulated output buffer will be disabled and the standard CMOS output buffer is used.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL01</name>
                <description>N/A</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL01</name>
                <description>N/A</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL01</name>
                <description>N/A</description>
                <bitRange>[4:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL01</name>
                <description>Selects trip-point of input buffer. In single ended input buffer mode (IBUF01_SEL = '0'):
0: input buffer functions as a CMOS input buffer.
1: input buffer functions as a LVTTL input buffer.
In differential input buffer mode (IBUF01_SEL = '1'):                                                                  VTRIP_SEL=0:                                                                                                                                a) VREF_SEL=00, VOH_SEL=X -&gt; Trip point=50 percent of vddio
b) VREF_SEL=01, VOH_SEL=000 -&gt; Trip point=Vohref (buffered)
c) VREF_SEL=01, VOH_SEL=[1-7] -&gt; Input buffer functions as CMOS input buffer.                                                                                                                                             
d) VREF_SEL=10/11, VOH_SEL=000 -&gt; Trip point=Amuxbus_a/b (buffered)
e) VREF_SEL=10/11, VOH_SEL=[1-7]  -&gt;  Input buffer functions as CMOS input buffer.                                                                                                                                             VTRIP_SEL=1:                                                                                                                                a) VREF_SEL=00, VOH_SEL=X -&gt; Trip point=40 percent of vddio
b) VREF_SEL=01, VOH_SEL=000 -&gt; Trip point=0.5*Vohref
c) VREF_SEL=01, VOH_SEL=[1-7] -&gt; Input buffer functions as LVTTL input buffer.                                                                                                                                            d) VREF_SEL=10/11, VOH_SEL=000 -&gt; Trip point=0.5*Amuxbus_a/b (buffered)
e) VREF_SEL=10/11, VOH_SEL=[1-7]  -&gt; Input buffer functions as LVTTL input buffer.</description>
                <bitRange>[7:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREG_EN23</name>
                <description>N/A</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL23</name>
                <description>N/A</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL23</name>
                <description>N/A</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL23</name>
                <description>N/A</description>
                <bitRange>[12:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL23</name>
                <description>N/A</description>
                <bitRange>[15:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREG_EN45</name>
                <description>N/A</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL45</name>
                <description>N/A</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL45</name>
                <description>N/A</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL45</name>
                <description>N/A</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL45</name>
                <description>N/A</description>
                <bitRange>[23:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREG_EN67</name>
                <description>N/A</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL67</name>
                <description>N/A</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL67</name>
                <description>N/A</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL67</name>
                <description>N/A</description>
                <bitRange>[28:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL67</name>
                <description>N/A</description>
                <bitRange>[31:29]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_IN_AUTOLVL</name>
            <description>Port input buffer AUTOLVL configuration register</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>VTRIP_SEL0_1</name>
                <description>Configures the input buffer mode (trip points and hysteresis) for GPIO upper bit.  Lower bit is still selected by CFG_IN.VTRIP_SEL0_0 field.  This field is used along with CFG_IN.VTRIP_SEL0_0 field as below:
{CFG_IN_AUTOLVL.VTRIP_SEL0_1,CFG_IN.VTRIP_SEL0_0}:
0,0: CMOS
0,1: TTL
1,0: input buffer is compatible with automotive.
1,1: input buffer is compatible with automotive.

For GPIO OVT 1.2V variant, the encoding values of concatenation of CFG_IN_AUTOLVL.VTRIP_SEL0_1 and CFG_IN.VTRIP_SEL0_0 i.e. {CFG_IN_AUTOLVL.VTRIP_SEL0_1, CFG_IN.VTRIP_SEL0_0}are as below:
2'b00: CMOS 1.8V VIH/VIL = 65 percent/53 percent of VDDIO
2'b01: I2C 1.8V VIH/VIL = 70 percent/30 percent of VDDIO
2'b10: CMOS 1.2V VIH/VIL = 65 percent/35 percent of VDDIO
2'b11: I2C 1.2V VIH/VIL = 70 percent/30 percent of VDDIO</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CMOS_OR_TTL</name>
                    <description>Input buffer compatible with CMOS/TTL interfaces as described in CFG_IN.VTRIP_SEL0_0.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AUTO</name>
                    <description>Input buffer compatible with AUTO (elevated Vil) interfaces when used along with CFG_IN.VTRIP_SEL0_0.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>VTRIP_SEL1_1</name>
                <description>N/A</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL2_1</name>
                <description>N/A</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL3_1</name>
                <description>N/A</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL4_1</name>
                <description>N/A</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL5_1</name>
                <description>N/A</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL6_1</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL7_1</name>
                <description>N/A</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_OUT2</name>
            <description>Port output buffer configuration register 2</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFF</resetMask>
            <fields>
              <field>
                <name>DS_TRIM0</name>
                <description>Sets the Drive Select Trim for  IO pin 0
0 - Default (50ohms)
1 - 120ohms
2 - 90ohms
3 - 60ohms
4 - 50ohms
5 - 30ohms
6 - 20ohms
7 - 15ohms</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DEFAULT</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_120OHM</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_90OHM</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_60OHM</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_50OHM</name>
                    <description>N/A</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_30OHM</name>
                    <description>N/A</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_20OHM</name>
                    <description>N/A</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_15OHM</name>
                    <description>N/A</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DS_TRIM1</name>
                <description>Sets the Drive Select Trim for IO pin 1</description>
                <bitRange>[5:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS_TRIM2</name>
                <description>Sets the Drive Select Trim for IO pin 2</description>
                <bitRange>[8:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS_TRIM3</name>
                <description>Sets the Drive Select Trim for IO pin 3</description>
                <bitRange>[11:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS_TRIM4</name>
                <description>Sets the Drive Select Trim for IO pin 4</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS_TRIM5</name>
                <description>Sets the Drive Select Trim for IO pin 5</description>
                <bitRange>[17:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS_TRIM6</name>
                <description>Sets the Drive Select Trim for IO pin 6</description>
                <bitRange>[20:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS_TRIM7</name>
                <description>Sets the Drive Select Trim for IO pin 7</description>
                <bitRange>[23:21]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_SLEW_EXT</name>
            <description>Port output buffer slew extension configuration register</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x77777777</resetMask>
            <fields>
              <field>
                <name>SLEW0</name>
                <description>Enables slow slew rate for IO pin 0
HSIO_STDLN:
slew_ctl[SLEW_WIDTH] = All 0s: Fastest slew rate
slew_ctl[SLEW_WIDTH] = All 1s: Slowest slew rate
HSIO_ENH:
slew_sel[SLEW_WIDTH] = All 0s: Fastest slew rate
slew_sel[SLEW_WIDTH] = All 1s: Slowest slew rate</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEW1</name>
                <description>Slew rate for IO pin 1</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEW2</name>
                <description>Slew rate for IO pin 2</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEW3</name>
                <description>Slew rate for IO pin 3</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEW4</name>
                <description>Slew rate for IO pin 4</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEW5</name>
                <description>Slew rate for IO pin 5</description>
                <bitRange>[22:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEW6</name>
                <description>Slew rate for IO pin 6</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEW7</name>
                <description>Slew rate for IO pin 7</description>
                <bitRange>[30:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_DRIVE_EXT0</name>
            <description>Port output buffer drive sel extension configuration register</description>
            <addressOffset>0x68</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>DRIVE_SEL_EXT0</name>
                <description>Sets the GPIO drive strength for IO pin 0. See description of CFG_OUT.DRIVE_SEL0 for options.

For GPIO OVT 1.2V variant: Below are the encoding values:
3'b000 : 4mA drive strength, 1.8V
3'b001 : 3mA drive strength, 1.8V
3'b010 : 2mA drive strength, 1.8V
3'b011 : 1mA drive strength, 1.8V
3'b100 : 4mA drive strength, 1.2V
3'b101 : 3mA drive strength, 1.2V
3'b110 : 2mA drive strength, 1.2V
3'b111 : 1mA drive strength, 1.2V</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL_EXT1</name>
                <description>N/A</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL_EXT2</name>
                <description>N/A</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL_EXT3</name>
                <description>N/A</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_DRIVE_EXT1</name>
            <description>Port output buffer drive sel extension configuration register</description>
            <addressOffset>0x6C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>DRIVE_SEL_EXT4</name>
                <description>Sets the GPIO drive strength for IO pin 4. See description of CFG_OUT.DRIVE_SEL0 for options.

For GPIO OVT 1.2V variant only: Below are the encoding values:
3'b000 : 4mA drive strength, 1.8V
3'b001 : 3mA drive strength, 1.8V
3'b010 : 2mA drive strength, 1.8V
3'b011 : 1mA drive strength, 1.8V
3'b100 : 4mA drive strength, 1.2V
3'b101 : 3mA drive strength, 1.2V
3'b110 : 2mA drive strength, 1.2V
3'b111 : 1mA drive strength, 1.2V</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL_EXT5</name>
                <description>N/A</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL_EXT6</name>
                <description>N/A</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL_EXT7</name>
                <description>N/A</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>INTR_CAUSE0</name>
          <description>Interrupt port cause register 0</description>
          <addressOffset>0x4000</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to determine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PRT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE1</name>
          <description>Interrupt port cause register 1</description>
          <addressOffset>0x4004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to determine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PORT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE2</name>
          <description>Interrupt port cause register 2</description>
          <addressOffset>0x4008</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to determine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PORT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE3</name>
          <description>Interrupt port cause register 3</description>
          <addressOffset>0x400C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to determine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PORT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_ACTIVE</name>
          <description>Extern power supply detection register</description>
          <addressOffset>0x4010</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Indicates presence or absence of VDDIO supplies (i.e. other than VDDD, VDDA) on the device (supplies are numbered 0..n-1).  Note that VDDIO supplies have basic (crude) supply detectors only.  If separate, robust, brown-out detection is desired on IO supplies, on-chip or off-chip analog resources need to provide it.  For these bits to work reliable, the supply must be within valid spec range (per datasheet) or held at ground.  Any in-between voltage has an undefined result.
'0': Supply is not present
'1': Supply is present

When multiple VDDIO supplies are present, they will be assigned in alphanumeric ascending order to these bits during implementation.
For example 'vddusb, vddio_0, vddio_a, vbackup, vddio_r, vddio_1' are present then they will be assigned to these bits as below:
0: vbackup, 
1: vddio_0, 
2: vddio_1,
3: vddio_a,
4: vddio_r,
5: vddusb'</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>This bit indicates presence of the VDDD supply.  This bit will always read-back 1.  The VDDD supply has robust brown-out protection monitoring and it is not possible to read back this register without a valid supply. (This bit is used in certain test-modes to observe the brown-out detector status.)</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR</name>
          <description>Supply detection interrupt register</description>
          <addressOffset>0x4014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Supply state change detected.
'0': No change to supply detected
'1': Change to supply detected</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>The VDDD supply is always present during operation so a supply transition can not occur. This bit will always read back '1'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR_MASK</name>
          <description>Supply detection interrupt mask register</description>
          <addressOffset>0x4018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Masks supply interrupt on VDDIO.
'0': VDDIO interrupt forwarding disabled
'1': VDDIO interrupt forwarding enabled</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the digital supply VDDD.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR_MASKED</name>
          <description>Supply detection interrupt masked register</description>
          <addressOffset>0x401C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Supply transition detected AND masked
'0': Interrupt was not forwarded to CPU
'1': Interrupt occurred and was forwarded to CPU</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the digital supply VDDD.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR_SET</name>
          <description>Supply detection interrupt set register</description>
          <addressOffset>0x4020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Sets supply interrupt.
'0': Interrupt state not affected
'1': Interrupt set</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the digital supply VDDD.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_LVL</name>
          <description>External power supply level register</description>
          <addressOffset>0x4024</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_LVL</name>
              <description>The VDD_LVL circuit detects the VDDIO supply level and writes the detected value in this register. '0' indicates the VDDIO supply is at 1.2V and '1' indicates VDDIO supply is at 1.8V.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDM0</name>
      <description>PDM</description>
      <headerStructName>PDM</headerStructName>
      <baseAddress>0x40320000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ACTIVE</name>
              <description>Activate functionality (1 bit for each channel):
'0': Reception disabled. The FIFO_OVERFLOW interrupt cause will not be activated.
'1': Reception enabled. The FIFO_OVERFLOW interrupt may be activated (when an overflow event occurs).

Note: This functionality is intended for startup purposes. Typically, the startup sequence is as follows:
- global registers CLOCK_CTL, ROUTE_CTL, TEST_CTL, FIR*_COEFF* are initialized
- One or more structures are enabled (structure specific CTL.ENABLED register field is set to '1').
- The structures are initialized (structure specific MMIO registers are written).
- The structures are activated. This last step is performed by writing the CTL or CTL_SET MMIO registers, or on a rising edge ('0' to '1' transition) of a receiver's 'tr_activate' input trigger.

Note: on a rising edge ('0' to '1' transition) of a receiver's 'tr_activate' input trigger, its associated CTL.ACTIVE field is set to '1'. This allows HW based synchronization of PDM receiver activation based on system triggers. Implementation note: the trigger is synchronized on the receiver clock with the receiver reset (this requires the receiver to be enabled; i.e. CTL.ENABLED is '1').

Note: if CTL_CLR.ACTIVE[i] is written to '1' at the same time a rising edge of 'tr_activate[i]' occurs, CTL.ACTIVE[i] is set to '1' (i.e. trigger takes precedence).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTL_CLR</name>
          <description>Control clear</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ACTIVE</name>
              <description>Activate functionality:
'0': No effect.
'1': Bit is set to '0'.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTL_SET</name>
          <description>Control set</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ACTIVE</name>
              <description>Activate functionality:
'0': No effect.
'1': Bit is set to '1'.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLOCK_CTL</name>
          <description>Clock control</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x307</resetValue>
          <resetMask>0x103FF</resetMask>
          <fields>
            <field>
              <name>CLOCK_DIV</name>
              <description>PDM interface clock divider (legal range [3, 255]). The PDM interface clock clk_pdm ('pdm_clk[]' output signals) is defined as pdm_clk = clk_if / (CLOCK_DIV + 1); i.e. each PDM interface clock cycle equals CLOCK_DIV + 1 clk_if clock cycles. CLOCK_DIV should be set to an odd value ([3, 5, ..., 255]), to ensure a 50/50 percent duty cycle PDM interface clock pdm_clk.
'0-2': Illegal value.
'3': pdm_clk frequency is 1/4 clk_if frequency (1 pdm_clk cycle consists of 4 clk_if cycles).
'4': pdm_clk frequency is 1/5 clk_if frequency. Note: results in a non 50/50 percent duty cycle pdm_clk).
...
'255': pdm_clk frequency is 1/256 clk_if frequency.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLOCK_SEL</name>
              <description>Interface clock clk_if selection:
'0': SRSS clock clk_if_srss.
'1': IOSS data input signal 'pdm_data[0]'.
'2': IOSS data input signal 'pdm_data[1]'.
'3': undefined.

Note: when a data input signal is used as a clock source, it cannot be used as a data line.

Note: the application is always required to program this field to a value different from the default.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SEL_SRSS_CLOCK</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_PDM_DATA0</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_PDM_DATA1</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_OR</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HALVE</name>
              <description>Halve rate sampling:
'0': Full rate sampling. The PDM interface clock pdm_clk is as specified by CLOCK_DIV[]. Each captured PDM value is provided once to the CIC filter.
'1': Halve rate sampling. The PDM interface clock clk_pdm is as specified by CLOCK_DIV[] divided by two (halve the frequency). Each PDM value is captured twice and provided twice to the CIC filter; i.e. the PDM value is repeated.

Note: this field is provided to dynamically change the digital microphone's clock (pdm_clk) without affecting the PDM sample frequency towards the CIC filter. Halving the microphone clock results in lower system power consumption, but does lower audio quality.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FULL</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALVE</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ROUTE_CTL</name>
          <description>Route control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA_SEL</name>
              <description>Specifies what IOSS data input signal 'pdm_data[]' is routed to a specific PDM receiver. Each PDM receiver j has a dedicated 1-bit control field: PDM receiver j uses DATA_SEL[j]. The 1-bit field DATA_SEL[j] specification is as follows:
'0': PDM receiver j uses data input signal 'pdm_data[j]'.
'1': PDM receiver j uses data input signal 'pdm_data[j ^ 1]' (the lower bit of the index is inverted).

Routing the same data input signal to two PDM receivers allows for:
- A single stereo digital microphone.
- Two (mono) digital microphones that share a data line. 

E.g., if DATA_SEL is 0b00000010, PDM receivers 0 and 1 BOTH use 'pdm_data[0]'.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TEST_CTL</name>
          <description>Test control</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x7F0400</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DRIVE_DELAY_HI</name>
              <description>Interface drive delay on the high phase of the PDM interface clock. This field specifies when a PDM value is driven expressed in clk_if clock cycles. DRIVE_DELAY should be set in the range [0, IF_CTL.CLOCK_DIV]:
'0': Drive PDM value 1 clk_if cycle after the rising edge of clk_pdm.
'1': Drive PDM value 2 clk_if cycles after the rising edge of clk_pdm.
...
'255': Drive PDM value 256 clk_if cycles after the rising edge of clk_pdm.

Note: To drive on the falling edge of the PDM interface clock clk_pdm, DRIVE_DELAY should be set to IF_CTL.CLOCK_DIV/2. To drive on the rising edge of clk_pdm, DRIVE_DELAY should be set to IF_CTL.CLOCK_DIV.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRIVE_DELAY_LO</name>
              <description>Interface drive delay on the low phase of the PDM interface clock. This field specifies when a PDM value is driven expressed in clk_if clock cycles. DRIVE_DELAY should be set in the range [0, IF_CTL.CLOCK_DIV]:
'0': Drive PDM value 1 clk_if cycle after the rising edge of clk_pdm.
'1': Drive PDM value 2 clk_if cycles after the rising edge of clk_pdm.
...
'255': Drive PDM value 256 clk_if cycles after the rising edge of clk_pdm.

Note: To drive on the falling edge of the PDM interface clock clk_pdm, DRIVE_DELAY should be set to IF_CTL.CLOCK_DIV/2. To drive on the rising edge of clk_pdm, DRIVE_DELAY should be set to IF_CTL.CLOCK_DIV.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_HI</name>
              <description>Pattern generator mode on the high phase of the PDM interface clock. This field specifies the type of PDM pattern driven by the generator:
'0': constant 0's
'1': constant 1's
'2': alternating 0's and 1's (clock pattern)
'3': sinusoid</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CONSTANT_0</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CONSTANT_1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTERNATING</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SINUSOID</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE_LO</name>
              <description>Pattern generator mode on the low phase of the PDM interface clock. This field specifies the type of pattern driven by the generator:
'0': constant 0's
'1': constant 1's
'2': alternating 0's and 1's (clock pattern)
'3': sine wave</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CONSTANT_0</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CONSTANT_1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTERNATING</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SINUSOID</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUDIO_FREQ_DIV</name>
              <description>Frequency division factor (legal range [3, 13]) to obtain audio frequency from the PDM clock frequency. This field determines the frequency of the sine wave generated by the pattern generator when MODE=3. The formula is below:

Sine wave Frequency = PDM clock frequency / 2p*2^(AUDIO_FREQ_DIV)

Example: when PDM clock frequency = 3.072 MHz the audio frequencies obtained for the various values of AUDIO_FREQ_DIV are shown below:

'3' : 61.115 kHz
'4' : 30.558 kHz
'5' : 15.279 kHz
'6' : 7.639 kHz
'7' : 3.820 kHz
'8' : 1.910 kHz
'9' : 955 Hz
'10' : 477 Hz
'11' : 239 Hz
'12' : 119 Hz
'13' : 60 Hz</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIV_PDM_FREQ_BY_2PI_x_8</name>
                  <description>Example: 3.072 MHz/(2p*8) = 61.115 kHz</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_PDM_FREQ_BY_2PI_x_16</name>
                  <description>Example: 3.072 MHz/(2p*16) = 30.558 kHz</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_PDM_FREQ_BY_2PI_x_8192</name>
                  <description>Example: 3.072 MHz/(2p*8192) = 60 Hz</description>
                  <value>13</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH_ENABLED</name>
              <description>Pattern generator enable (1 bit for each channel):
'0' : disabled, the channel input is taken as normal from external pin pdm_data_in
'1' : enabled, the channel input is taken from the pattern generator

Note: the pattern generator output is routed to pdm_data_out for testing purposes

Note: when all channels are disabled the pattern generator is switched off</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR0_COEFF0</name>
          <description>FIR 0 coefficients 0</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 0 and 29 coefficient.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 1 and 28 coefficient.</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR0_COEFF1</name>
          <description>FIR 0 coefficients 1</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 2 and 27 coefficient.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 3 and 26 coefficient.</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR0_COEFF2</name>
          <description>FIR 0 coefficients 2</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 4 and 25 coefficient.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 5 and 24 coefficient.</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR0_COEFF3</name>
          <description>FIR 0 coefficients 3</description>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 6 and 23 coefficient.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 7 and 22 coefficient.</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR0_COEFF4</name>
          <description>FIR 0 coefficients 4</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 8 and 21 coefficient.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 9 and 20 coefficient.</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR0_COEFF5</name>
          <description>FIR 0 coefficients 5</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 10 and 19 coefficient.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 11 and 18 coefficient.</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR0_COEFF6</name>
          <description>FIR 0 coefficients 6</description>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 12 and 17 coefficient.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 13 and 16 coefficient.</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR0_COEFF7</name>
          <description>FIR 0 coefficients 7</description>
          <addressOffset>0x11C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter tap 14 coefficient.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter tap 15 coefficient.</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF0</name>
          <description>FIR 1 coefficients 0</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x153FFE</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 0 and 54 coefficient (default value -2).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 1 and 53 coefficient (default value 21).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF1</name>
          <description>FIR 1 coefficients 1</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FEF001A</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 2 and 52 coefficient (default value 26).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 3 and 51 coefficient (default value -17).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF2</name>
          <description>FIR 1 coefficients 2</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x193FD7</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 4 and 50 coefficient (default value -41).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 5 and 49 coefficient (default value 25).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF3</name>
          <description>FIR 1 coefficients 3</description>
          <addressOffset>0x14C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FDF0044</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 6 and 48 coefficient (default value 68).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 7 and 47 coefficient (default value -33).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF4</name>
          <description>FIR 1 coefficients 4</description>
          <addressOffset>0x150</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x293F95</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 8 and 46 coefficient (default value -107).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 9 and 45 coefficient (default value 41).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF5</name>
          <description>FIR 1 coefficients 5</description>
          <addressOffset>0x154</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FD000A0</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 10 and 44 coefficient (default value 160).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 11 and 43 coefficient (default value -48).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF6</name>
          <description>FIR 1 coefficients 6</description>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x363F1A</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 12 and 42 coefficient (default value -230).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 13 and 41 coefficient (default value 54).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF7</name>
          <description>FIR 1 coefficients 7</description>
          <addressOffset>0x15C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FC80145</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 14 and 40 coefficient (default value 325).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 15 and 39 coefficient (default value -56).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF8</name>
          <description>FIR 1 coefficients 8</description>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x333E3B</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 16 and 38 coefficient (default value -453).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 17 and 37 coefficient (default value 51).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF9</name>
          <description>FIR 1 coefficients 9</description>
          <addressOffset>0x164</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FE10277</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 18 and 36 coefficient (default value 631).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 19 and 35 coefficient (default value -31).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF10</name>
          <description>FIR 1 coefficients 10</description>
          <addressOffset>0x168</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FEB3C82</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 20 and 34 coefficient (default value -894).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 21 and 33 coefficient (default value -21).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF11</name>
          <description>FIR 1 coefficients 11</description>
          <addressOffset>0x16C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xAC052E</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 22 and 32 coefficient (default value 1326).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 23 and 31 coefficient (default value 172).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF12</name>
          <description>FIR 1 coefficients 12</description>
          <addressOffset>0x170</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3CFE3771</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 24 and 30 coefficient (default value -2191).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 25 and 29 coefficient (default value -770).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIR1_COEFF13</name>
          <description>FIR 1 coefficients 13</description>
          <addressOffset>0x174</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1FFF12FB</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>Filter taps 26 and 28 coefficient (default value 4859).</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>Filter taps 27 (center tap) coefficient (default value 8191).</description>
              <bitRange>[29:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>2</dim>
          <dimIncrement>256</dimIncrement>
          <name>CH[%s]</name>
          <description>PDM RX structure</description>
          <addressOffset>0x00008000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x100</resetValue>
            <resetMask>0x8000010F</resetMask>
            <fields>
              <field>
                <name>WORD_SIZE</name>
                <description>PCM word size:
'0': 8 bit.
'1': 10 bit.
'2': 12 bit.
'3': 14 bit.
'4': 16 bit.
'5': 18 bit.
'6': 20 bit.
'7': 24 bit.
'8': 32 bit.
'9'-'15': Undefined.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SIZE_8</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SIZE_10</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SIZE_12</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SIZE_14</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SIZE_16</name>
                    <description>N/A</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SIZE_18</name>
                    <description>N/A</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SIZE_20</name>
                    <description>N/A</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SIZE_24</name>
                    <description>N/A</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SIZE_32</name>
                    <description>N/A</description>
                    <value>8</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WORD_SIGN_EXTEND</name>
                <description>Word extension:
'0': zero extension.
'1': sign extension.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ZERO_EXTEND</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SIGN_EXTEND</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Receiver enable:
'0': Disabled. If a receiver is disabled, all non-retained MMIO registers (e.g. the RX_FIFO_STATUS and INTR_RX registers) have their fields reset to their default value.

'1': Enabled.

Note: when all receivers are disabled, the SRAMs are driven into low power mode, if supported by the SRAM. When exiting such low power mode software needs to allow for a certain power up time before SRAM can be used, i.e. before ACTIVE can be asserted. The power up time is equivalent to the system SRAM power up time specified in the CPUSS.RAM_PWR_DELAY_CTL register.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IF_CTL</name>
            <description>Interface control</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>SAMPLE_DELAY</name>
                <description>Interface sample delay. This field specifies when a PDM value is captured, expressed in clk_if clock cycles. 

When CLOCK_CTL.HALVE=0:
'0': Capture PDM value 1 clk_if cycle after the rising edge of clk_pdm.
'1': Capture PDM value 2 clk_if cycles after the rising edge of clk_pdm.
...
'255': Capture PDM value 256 clk_if cycles after the rising edge of clk_pdm.

When CLOCK_CTL.HALVE=1:
'0': Capture PDM value 1 and 2 clk_if cycles after the rising edge of clk_pdm.
'1': Capture PDM value 3 and 4 clk_if cycles after the rising edge of clk_pdm.
...
'255': Capture PDM value 511 and 512 clk_if cycles after the rising edge of clk_pdm.

SAMPLE_DELAY should be set such that the clk_if capture edge is at the middle point between pdm_clk_out edges. Under ideal conditions the middle point is 1/4 of the PDM interface period for the first/even/left channel, and 3/4 of the PDM interface period for the second/odd/right channel, which corresponds to the following programmings:

SAMPLE_DELAY(left)=((CLOCK_DIV+1)/4) - 1
SAMPLE_DELAY(right)=(3*(CLOCK_DIV+1)/4) - 1

In practice, due to the roundtrip delay, SAMPLE_DELAY may be set to a later point with respect to the ideal middle point. 

Note: in all cases a SAMPLE_DELAY value that brings the capture edge close to the pdm_clk_out edges should be avoided.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CIC_CTL</name>
            <description>CIC control</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x4</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>DECIM_CODE</name>
                <description>CIC filter decimation. The CIC filter PCM frequency is a fraction of the PDM frequency:
'0': CIC filter PCM frequency is 1/2 * PDM frequency. CIC PCM values are in the range [-0x10, 0x10].
'1': CIC filter PCM frequency is 1/4 * PDM frequency. CIC PCM values are in the range [-0x200, 0x200].
'2': CIC filter PCM frequency is 1/8 * PDM frequency. CIC PCM values are in the range [-0x4000, 0x4000].
'3': CIC filter PCM frequency is 1/16 * PDM frequency. CIC PCM values are in the range [-0x8:0000, 0x8:0000].
'4': CIC filter PCM frequency is 1/32 * PDM frequency. CIC PCM values are in the range [-0x100:0000, 0x100:0000].
'5'-'7': Illegal values.

Note: The CIC filter functionality includes offsetting logic to ensure that 'digital silence' on the PDM interface (an alternating pattern of '0', '1', '0', '1' ... PDM  values) results in CIC filter PCM values of '0'. Similarly, a pattern of '0', '0', '0', ... PDM values results in minimum CIC PCM value (-0x100:0000 when DECIMATION is '4') and a pattern of '1', '1', '1', ... PDM values results in maximum CIC PCM value (0x100:0000 when DECIMATION is '4').

Note: The IP's desired 'clk_sys' frequency is a function of the PDM interface clock, the CIC filter decimation (CIC_CTL.DECIM_CODE[]) and the FIR filter decimation (FIR_CTL.DECIM_CODE[]).</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DECIM_2</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DECIM_4</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DECIM_8</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DECIM_16</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DECIM_32</name>
                    <description>This is the default value and the most realistic value (together with the value '3'). Typically, an overall decimation (or oversample rate (OSR)) of 64 is used, and this is achieved with the default CIC and FIR decimation values.</description>
                    <value>4</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FIR0_CTL</name>
            <description>FIR 0 control</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80001F07</resetMask>
            <fields>
              <field>
                <name>DECIM3</name>
                <description>FIR filter decimation. The FIR filter PCM frequency is a fraction of the CIC filter PCM frequency:
'0': FIR 0 filter PCM frequency is 1 * CIC filter PCM frequency. The FIR 0 filter is performed for every CIC filter PCM sample.
'1': FIR 0 filter PCM frequency is 1/2 * CIC filter PCM frequency. The FIR 0 filter is performed for every second CIC filter PCM sample.
'2': FIR 0 filter PCM frequency is 1/3 * CIC filter PCM frequency. The FIR 0 filter is performed for every third CIC filter PCM sample.
'3': FIR 0 filter PCM frequency is 1/4 * CIC filter PCM frequency. The FIR 0 filter is performed for every fourth CIC filter PCM sample.
'4': FIR 0 filter PCM frequency is 1/5 * CIC filter PCM frequency. The FIR 0 filter is performed for every fifth CIC filter PCM sample.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DECIM_1</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DECIM_2</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DECIM_3</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DECIM_4</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DECIM_5</name>
                    <description>N/A</description>
                    <value>4</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SCALE</name>
                <description>FIR 0 filter PCM scaling. FIR 0 filter PCM values (fir0_pcm[44:0]) are scaled (right shifted, rounded and clipped) to 26-bit signed PCM values (fir0_scaled_pcm[25:0]). These 26-bit PCM values are input to the FIR 1 filter. SCALE specifies the right shift amount (and performs a rounding):
'0': fir0_scaled_pcm = CLIP26 (fir0_pcm[44:0]).
'1': fir0_scaled_pcm = CLIP26 (fir0_pcm[44:1] + fir0_pcm[0]).
...
'31': fir0_scaled_pcm = CLIP26 (fir0_pcm[44:31] + fir0_pcm[30]).

With CLIP26(a) defined as:
   if      (a &gt;= 0x1ff:ffff) result =  0x1ff:ffff;
   else if (a &lt; -0x200:0000) result = -0x200:0000;
   else                      result = a;

Note: Clipping is not necessary for larger SCALE values, as the scaled value is guarneteed to be within the 26-bit signed integer range.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SCALE_0</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCALE_1</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCALE_31</name>
                    <description>N/A</description>
                    <value>31</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ENABLED</name>
                <description>FIR 0 filter coefficient enable (does NOT effect FIR filter scaling and FIR filter decimation):
'0': Disabled. The middle FIR filter coefficient (16th coefficient, or tap 15 in [0:29] range) is '1' and all other FIR filter coefficients are '0'; i.e. the FIR filter is a pass through filter and the filter gain is '1'.
   fir0_pcm[44:0] = cic_pcm[25:0] (with sign extension)
'1': Enabled.

Note: This filter is disabled by default, and typically only used for sample frequencies (Fs) of 8 and 16 kHz.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FIR1_CTL</name>
            <description>FIR 1 control</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x80000F01</resetValue>
            <resetMask>0x80001F03</resetMask>
            <fields>
              <field>
                <name>DECIM2</name>
                <description>FIR 1 filter decimation. The FIR filter PCM frequency is a fraction of the FIR0 filter PCM frequency:
'0': FIR 1 filter PCM frequency is 1 * FIR 0 filter PCM frequency. The FIR filter is performed for every FIR 0 filter PCM sample.
'1': FIR 1 filter PCM frequency is 1/2 * FIR 0 filter PCM frequency. The FIR filter is performed for every second FIR 0 filter PCM sample.
'2': FIR 1 filter PCM frequency is 1/3 * FIR 0 filter PCM frequency. The FIR filter is performed for every third FIR 0 filter PCM sample.
'3': FIR 1 filter PCM frequency is 1/4 * FIR 0 filter PCM frequency. The FIR filter is performed for every fourth FIR 0 filter PCM sample.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DECIM_1</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DECIM_2</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DECIM_3</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DECIM_4</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SCALE</name>
                <description>FIR 1 filter PCM scaling. FIR filter PCM values (fir1_pcm[43:0]) are scaled (right shifted, rounded and clipped) to 24-bit signed PCM values (fir1_scaled_pcm[23:0]). These 24-bit PCM values are input to the DC blocker. SCALE specifies the right shift amount (and performs a rounding):
'0': fir1_scaled_pcm = CLIP24 (fir1_pcm[43:0]).
'1': fir1_scaled_pcm = CLIP24 (fir1_pcm[43:1] + fir1_pcm[0]).
...
'31': fir1_scaled_pcm = CLIP24 (fir1_pcm[43:31] + fir1_pcm[30]).

With CLIP24(a) defined as:
   if      (a &gt;= 0x7f:ffff) result =  0x7f:ffff;
   else if (a &lt; -0x80:0000) result = -0x80:0000;
   else                     result = a;

Note: Clipping is not necessary for larger SCALE values, as the scaled value is guarneteed to be within the 24-bit signed integer range.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SCALE_0</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCALE_1</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCALE_31</name>
                    <description>N/A</description>
                    <value>31</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ENABLED</name>
                <description>FIR 1 filter coefficient enable (does NOT effect FIR filter scaling and FIR filter decimation):
'0': Disabled. The middle FIR filter coefficient (28th coefficient, or tap 27 in [0:54] range) is '1' and all other FIR filter coefficients are '0'; i.e. the FIR filter is a pass through filter and the filter gain is '1'.
   fir1_pcm[43:0] = fir0_scaled_pcm[25:0] (with sign extension)
'1': Enabled.

Note: Disabling of the filter functionality is provided for debug purposes.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DC_BLOCK_CTL</name>
            <description>DC block control</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x80000001</resetValue>
            <resetMask>0x80000007</resetMask>
            <fields>
              <field>
                <name>CODE</name>
                <description>DC blocker coefficient. The DC blocker is defined as:

dc_block_state_scaled(n-1) = 
       dc_block_state(n-1) 
     - (dc_block_state(n-1) &gt;&gt; (12-CODE))
dc_block_state(n)          = CLIP37 (
       2^13 * (fir1_scaled_pcm(n) - fir1_scaled_pcm(n-1))
     + dc_block_state_scaled(n-1))
dc_block_pcm(n)            = dc_block_state(n) &gt;&gt; 13

This first step is a scaling step of the DC block state. It effectively multiplies the DC block state with a variable 'alpha' that is close to '1': 
'0': alpha = 1 - (1/2^(12-0)) = 0.999755859.
'1': alpha = 1 - (1/2^(12-1)) = 0.999511719.
'2': alpha = 1 - (1/2^(12-2)) = 0.999023438.
'3': alpha = 1 - (1/2^(12-3)) = 0.998046875.
'4': alpha = 1 - (1/2^(12-4)) = 0.99609375.
'5': alpha = 1 - (1/2^(12-5)) = 0.9921875.
'6': alpha = 1 - (1/2^(12-6)) = 0.984375.
'7': alpha = 1 - (1/2^(12-7)) = 0.96875.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CODE_1</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CODE_2</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CODE_4</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CODE_8</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CODE_16</name>
                    <description>N/A</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CODE_32</name>
                    <description>N/A</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CODE_64</name>
                    <description>N/A</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CODE_128</name>
                    <description>N/A</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ENABLED</name>
                <description>DC blocker enable:
'0': Disabled. The functionality is defined as:
dc_block_pcm(n) = fir1_scaled_pcm(n)
'1': Enabled. The functionality is as specified by the CODE field.

Note: disabling of the DC blocker filter functionality is provided for debug purposes.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RX_FIFO_CTL</name>
            <description>RX FIFO control</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2003F</resetMask>
            <fields>
              <field>
                <name>TRIGGER_LEVEL</name>
                <description>Trigger level. When the RX FIFO has more entries than the number of this field, a receiver trigger event is generated:
- INTR_RX.FIFO_TRIGGER = (# FIFO entries &gt; TRIGGER_LEVEL)</description>
                <bitRange>[5:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EMPTY</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>USED_1</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>USED_63</name>
                    <description>N/A</description>
                    <value>63</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FREEZE</name>
                <description>Freeze functionality:
'0': HW writes to the RX FIFO and advances the FIFO write pointer.
'1': HW writes from the RX FIFO have no effect: freeze will not advance the FIFO write pointer.

Note: This functionality is intended for debugging purposes.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RX_FIFO_STATUS</name>
            <description>RX FIFO status</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F3F007F</resetMask>
            <fields>
              <field>
                <name>USED</name>
                <description>Number of used/occupied entries in the RX FIFO. The field value is in the range [0, 64]. When '0', the FIFO is empty. When '64', the FIFO is full.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RD_PTR</name>
                <description>RX FIFO read pointer: FIFO location from which a data is read.

Note: This functionality is intended for debugging purposes.</description>
                <bitRange>[21:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WR_PTR</name>
                <description>RX FIFO write pointer: FIFO location at which a new data is written by the hardware.

Note: This functionality is intended for debugging purposes.</description>
                <bitRange>[29:24]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RX_FIFO_RD</name>
            <description>RX FIFO read</description>
            <addressOffset>0x88</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Data (PCM sample) read from the RX FIFO. Reading removes the data from the RX FIFO; i.e. behavior is similar to that of a POP operation (RX_FIFO_STATUS.RD_PTR is incremented and RX_FIFO_STATUS.USED is decremented). The read data (DATA) is right aligned (unused bit positions follow the specified sign extension per CTL.WORD_SIGN_EXTEND) when it is read from the FIFO entry (data[23:0]):
- 8 bit, DATA[7:0] = data[23:16].
- 10 bit, DATA[9:0] = data[23:14].
- 12 bit, DATA[11:0] = data[23:12].
- 14 bit, DATA[13:0] = data[23:10].
- 16 bit, DATA[15:0] = data[23:8].
- 18 bit, DATA[17:0] = data[23:6].
- 20 bit, DATA[19:0] = data[23:4].
- 24 bit, DATA[23:0] = data[23:0].
- 32 bit, DATA[31:0] = data[23:0] &lt;&lt; 8.

Note: Reading from an empty RX FIFO activates INTR_RX.FIFO_UNDERFLOW.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RX_FIFO_RD_SILENT</name>
            <description>RX FIFO silent read</description>
            <addressOffset>0x8C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Data (PCM sample) read from the RX FIFO. Reading will NOT remove the data  from the RX FIFO; i.e. behavior is similar to that of a PEEK operation. See RX_FIFO_RD for data alignment.

Note: Reading from an empty RX FIFO activates INTR.RX_FIFO_UNDERFLOW (the read returns 0xffff:ffff).

Note: This functionality is intended for debugging purposes.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_RX</name>
            <description>Interrupt</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x117</resetMask>
            <fields>
              <field>
                <name>FIFO_TRIGGER</name>
                <description>HW sets this field to '1', when a RX trigger is generated.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFO_OVERFLOW</name>
                <description>HW sets this field to '1', when writing to a full RX FIFO (RX_FIFO_STATUS.USED is '64').</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFO_UNDERFLOW</name>
                <description>HW sets this field to '1', when reading from an empty RX FIFO (RX_FIFO_STATUS.USED is '0').</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIR_OVERFLOW</name>
                <description>HW sets this field to '1', when CIC filter PCM samples are produced at a faster rate than the FIR filter can process them. This is an indication that the IP system frequency is too low.

Note: This functionality is intended for debugging purposes.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IF_OVERFLOW</name>
                <description>HW sets this field to '1', when PDM samples are generated too fast by the interface logic (interface overflow). This may be an indication that the IP system frequency is too low wrt. the interface frequency (a SW configuration error). The interface overflow is a non-recoverable error and requires SW disabling (CTL.ENABLED) of the receiver clearing INTR_RX.IF_OVERFLOW to '0' does not resolve the interface underflow).

Note: This functionality is intended for debug purposes.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_RX_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x117</resetMask>
            <fields>
              <field>
                <name>FIFO_TRIGGER</name>
                <description>Write this field with '1' to set corresponding INTR_RX field (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFO_OVERFLOW</name>
                <description>Write this field with '1' to set corresponding INTR_RX field (a write of '0' has no effect).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFO_UNDERFLOW</name>
                <description>Write this field with '1' to set corresponding INTR_RX field (a write of '0' has no effect).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIR_OVERFLOW</name>
                <description>Write this field with '1' to set corresponding INTR_RX field (a write of '0' has no effect).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IF_OVERFLOW</name>
                <description>Write this field with '1' to set corresponding INTR_RX field (a write of '0' has no effect).</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_RX_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0xC8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x117</resetMask>
            <fields>
              <field>
                <name>FIFO_TRIGGER</name>
                <description>Mask for corresponding field in INTR_RX register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFO_OVERFLOW</name>
                <description>Mask for corresponding field in INTR_RX register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFO_UNDERFLOW</name>
                <description>Mask for corresponding field in INTR_RX register.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIR_OVERFLOW</name>
                <description>Mask for corresponding field in INTR_RX register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IF_OVERFLOW</name>
                <description>Mask for corresponding field in INTR_RX register.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_RX_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0xCC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x117</resetMask>
            <fields>
              <field>
                <name>FIFO_TRIGGER</name>
                <description>Logical AND of corresponding INTR_RX and INTR_RX_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FIFO_OVERFLOW</name>
                <description>Logical AND of corresponding INTR_RX and INTR_RX_MASK fields.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FIFO_UNDERFLOW</name>
                <description>Logical AND of corresponding INTR_RX and INTR_RX_MASK fields.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FIR_OVERFLOW</name>
                <description>Logical AND of corresponding INTR_RX and INTR_RX_MASK fields.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IF_OVERFLOW</name>
                <description>Logical AND of corresponding INTR_RX and INTR_RX_MASK fields.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>TCPWM0</name>
      <description>Timer/Counter/PWM</description>
      <headerStructName>TCPWM</headerStructName>
      <baseAddress>0x40400000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>TCPWM control register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_ENABLED</name>
              <description>Counter enables for counters 0 up to CNT_NR-1.
'0': counter disabled.
'1': counter enabled.
Counter static configuration information (e.g. CTRL.MODE, all TR_CTRL0, TR_CTRL1, and TR_CTRL2 register fields) should only be modified when the counter is disabled. When a counter is disabled, command and status information associated to the counter is cleared by HW, this includes:
- the associated counter triggers in the CMD register are set to '0'.
- the counter's interrupt cause fields in counter's INTR register.
- the counter's status fields in counter's STATUS register..
- the counter's trigger outputs ('tr_overflow', 'tr_underflow' and 'tr_compare_match').
- the counter's line outputs ('line_out' and 'line_compl_out').
In multi-core environments, use the CTRL_SET/CTRL_CLR registers to avoid race-conditions on read-modify-write attempts to this register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL_CLR</name>
          <description>TCPWM control clear register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_ENABLED</name>
              <description>Alias of CTRL that only allows disabling of counters. A write access:
'0': Does nothing.
'1': Clears respective COUNTER_ENABLED field.

A read access returns CTRL.COUNTER_ENABLED.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL_SET</name>
          <description>TCPWM control set register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_ENABLED</name>
              <description>Alias of CTRL that only allows enabling of counters. A write access:
'0': Does nothing.
'1': Sets respective COUNTER_ENABLED field.

A read access returns CTRL.COUNTER_ENABLED.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_CAPTURE</name>
          <description>TCPWM capture command register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_CAPTURE</name>
              <description>Counters SW capture trigger. When written with '1', a capture trigger is generated and the HW sets the field to '0' when the SW trigger has taken effect. It should be noted that the HW operates on the counter frequency. If the counter is disabled through CTRL.COUNTER_ENABLED, the field is immediately set to '0'.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RELOAD</name>
          <description>TCPWM reload command register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_RELOAD</name>
              <description>Counters SW reload trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_STOP</name>
          <description>TCPWM stop command register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_STOP</name>
              <description>Counters SW stop trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_START</name>
          <description>TCPWM start command register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_START</name>
              <description>Counters SW start trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>TCPWM Counter interrupt cause register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_INT</name>
              <description>Counters interrupt signal active. If the counter is disabled through CTRL.COUNTER_ENABLED, the associated interrupt field is immediately set to '0'.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>8</dim>
          <dimIncrement>64</dimIncrement>
          <name>CNT[%s]</name>
          <description>Timer/Counter/PWM Counter Module</description>
          <addressOffset>0x00000100</addressOffset>
          <register>
            <name>CTRL</name>
            <description>Counter control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x737FF0F</resetMask>
            <fields>
              <field>
                <name>AUTO_RELOAD_CC</name>
                <description>Specifies switching of the CC and buffered CC values. This field has a function in TIMER, PWM, PWM_DT and PWM_PR modes.
Timer mode:
'0': never switch.
'1': switch on a compare match event.
PWM, PWM_DT, PWM_PR modes: 
'0: never switch.
'1': switch on a terminal count event with an actively pending switch event.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_RELOAD_PERIOD</name>
                <description>Specifies switching of the PERIOD and buffered PERIOD values. This field has a function in PWM, PWM_DT and PWM_PR modes.
'0': never switch.
'1': switch on a terminal count event with and actively pending switch event.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_SYNC_KILL</name>
                <description>Specifies asynchronous/synchronous kill behavior:
'1': synchronous kill mode: the kill event disables the 'dt_line_out' and 'dt_line_compl_out' signals till the next terminal count event (synchronous kill). In synchronous kill mode, STOP_EDGE should  be RISING_EDGE.
'0': asynchronous kill mode: the kill event only disables the 'dt_line_out' and 'dt_line_compl_out' signals when present. In asynchronous kill mode, STOP_EDGE should be NO_EDGE_DET. 

This field has a function in PWM and PWM_DT modes only. This field is only used when PWM_STOP_ON_KILL is '0'.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_STOP_ON_KILL</name>
                <description>Specifies whether the counter stops on a kill events:
'0': kill event does NOT stop counter.
'1': kill event stops counter.

This field has a function in PWM, PWM_DT and PWM_PR modes only.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit control field. In PWM_DT mode, this field is used to determine the dead time: amount of dead time cycles in the counter clock domain. In all other modes, the lower 3 bits of this field determine pre-scaling of the selected counter clock.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>UP_DOWN_MODE</name>
                <description>Determines counter direction.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>COUNT_UP</name>
                    <description>Count up (to PERIOD). An overflow event is generated when the counter changes from a state in which COUNTER equals PERIOD. A terminal count event is generated when the counter changes from a state in which COUNTER equals PERIOD.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_DOWN</name>
                    <description>Count down (to '0'). An underflow event is generated when  the counter changes from a state in which COUNTER equals '0'. A terminal count event is generated when the counter changes from a state in which COUNTER equals '0'.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN1</name>
                    <description>Count up (to PERIOD), then count down (to '0'). An overflow event is generated when the counter changes from a state in which COUNTER equals PERIOD. An underflow event is generated when the counter changes from a state in which COUNTER equals '0'. A terminal count event is generated when the counter changes from a state in which COUNTER equals '0'.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN2</name>
                    <description>Count up (to PERIOD), then count down (to '0'). An overflow event is generated when the counter changes from a state in which COUNTER equals PERIOD. An underflow event is generated when the counter changes from a state in which COUNTER equals '0'. A terminal count event is generated when the counter changes from a state in which COUNTER equals '0' AND when the counter changes from a state in which COUNTER equals PERIOD (this counter direction can be used for PWM functionality with asymmetrical updates).</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ONE_SHOT</name>
                <description>When '0', counter runs continuous. When '1', counter is turned off by hardware when a terminal count event is generated.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>QUADRATURE_MODE</name>
                <description>In QUAD mode selects quadrature encoding mode (X1/X2/X4).
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to invert 'dt_line_out' and 'dt_line_compl_out'.  Inversion is the last step in generation of 'dt_line_out' and 'dt_line_compl_out'; i.e. a disabled output line 'dt_line_out' has the value QUADRATURE_MODE[0] and a disabled output line 'dt_line_compl_out' has the value QUADRATURE_MODE[1].</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>X1</name>
                    <description>X1 encoding (QUAD mode)</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X2</name>
                    <description>X2 encoding (QUAD mode)</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X4</name>
                    <description>X4 encoding (QUAD mode)</description>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE</name>
                <description>Counter mode.</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>TIMER</name>
                    <description>Timer mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CAPTURE</name>
                    <description>Capture mode</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>QUAD</name>
                    <description>Quadrature encoding mode</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM</name>
                    <description>Pulse width modulation (PWM) mode</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_DT</name>
                    <description>PWM with deadtime insertion mode</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_PR</name>
                    <description>Pseudo random pulse width modulation</description>
                    <value>6</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Counter status register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x8000FF01</resetMask>
            <fields>
              <field>
                <name>DOWN</name>
                <description>When '0', counter is counting up. When '1', counter is counting down. In QUAD mode, this field indicates the direction of the latest counter change: '0' when last incremented and '1' when last decremented.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit counter field. In PWM_DT mode, this counter is used for dead time insertion. In all other modes, this counter is used for pre-scaling the selected counter clock. PWM_DT mode can NOT use prescaled clock functionality.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RUNNING</name>
                <description>When '0', the counter is NOT running. When '1', the counter is running.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>COUNTER</name>
            <description>Counter count register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COUNTER</name>
                <description>16-bit / 32-bit counter value. It is advised to not write to this field when the counter is running.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC</name>
            <description>Counter compare/capture register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>In CAPTURE mode, captures the counter value. In other modes, compared to counter value.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC_BUFF</name>
            <description>Counter buffered compare/capture register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>Additional buffer for counter CC register.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD</name>
            <description>Counter period register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Period value: upper value of the counter. When the counter should count for n cycles, this field should be set to n-1.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD_BUFF</name>
            <description>Counter buffered period register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Additional buffer for counter PERIOD register.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL0</name>
            <description>Counter trigger control register 0</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x10</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_SEL</name>
                <description>Selects one of the 16 input triggers as a capture trigger. Input trigger 0 is always '0' and input trigger is always '1'. In the PWM, PWM_DT and PWM_PR modes this trigger is used to switch the values if the compare and period registers with their buffer counterparts.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COUNT_SEL</name>
                <description>Selects one of the 16 input triggers as a count trigger. In QUAD mode, this is the first phase (phi A). Default setting selects input trigger 1, which is always '1'.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RELOAD_SEL</name>
                <description>Selects one of the 16 input triggers as a reload trigger. In QUAD mode, this is the index or revolution pulse. In this mode, it will update the counter with 0x8000 (counter midpoint).</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STOP_SEL</name>
                <description>Selects one of the 16 input triggers as a stop trigger. In PWM, PWM_DT and PWM_PR modes, this is the kill trigger. In these modes, the kill trigger is used to either temporarily block the PWM outputs (PWM_STOP_ON_KILL is '0') or stop the functionality (PWM_STOP_ON_KILL is '1'). For the PWM and PWM_DT modes, the blocking of the output signals can be  asynchronous (STOP_EDGE should be NO_EDGE_DET) in which case the blocking is as long as the trigger is '1' or synchronous (STOP_EDGE should be RISING_EDGE) in which case it extends till the next terminal count event.</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>START_SEL</name>
                <description>Selects one of the 16 input triggers as a start trigger. In QUAD mode, this is the second phase (phi B).</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL1</name>
            <description>Counter trigger control register 1</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3FF</resetValue>
            <resetMask>0x3FF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_EDGE</name>
                <description>A capture event will copy the counter value into the CC register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COUNT_EDGE</name>
                <description>A counter event will increase or decrease the counter by '1'.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RELOAD_EDGE</name>
                <description>A reload event will initialize the counter. When counting up, the counter is initialized to '0'. When counting down, the counter is initialized with PERIOD.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOP_EDGE</name>
                <description>A stop event, will stop the counter; i.e. it will no longer be running. Stopping will NOT disable the counter.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>START_EDGE</name>
                <description>A start event will start the counter; i.e. the counter will become running. Starting does NOT enable the counter. A start event will not initialize the counter whereas the reload event does.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL2</name>
            <description>Counter trigger control register 2</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3F</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>CC_MATCH_MODE</name>
                <description>Determines the effect of a compare match event (COUNTER equals CC register) on the 'line_out' output signals.  Note that INVERT is especially useful for center aligned pulse width modulation.
To generate a duty cycle of 0 percent, the counter CC register should be set to '0'. For a 100 percent duty cycle, the counter CC register should be set to larger than the counter PERIOD register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <description>Set to '1'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <description>Set to '0'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <description>Invert</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <description>No Change</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVERFLOW_MODE</name>
                <description>Determines the effect of a counter overflow event (COUNTER reaches PERIOD) on the 'line_out' output signals.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <description>Set to '1'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <description>Set to '0'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <description>Invert</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <description>No Change</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UNDERFLOW_MODE</name>
                <description>Determines the effect of a counter underflow event (COUNTER reaches '0') on the 'line_out' output signals.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <description>Set to '1'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <description>Set to '0'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <description>Invert</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <description>No Change</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt request register</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Terminal count event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Counter matches CC register event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set request register</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask register</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked request register</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>SMIF0</name>
      <description>Serial Memory Interface</description>
      <headerStructName>SMIF</headerStructName>
      <baseAddress>0x40410000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000</resetValue>
          <resetMask>0x81073001</resetMask>
          <fields>
            <field>
              <name>XIP_MODE</name>
              <description>Mode of operation.

Note: this field should only be changed when the IP is disabled or when STATUS.BUSY is '0' and SW should not be executing from the XIP interface or MMIO interface.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MMIO_MODE</name>
                  <description>'0': MMIO mode. Individual MMIO accesses to TX and RX FIFOs are used to generate a sequence of SPI transfers. This mode of operation allows for large flexibility in terms of the SPI transfers that can be generated.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>XIP_MODE</name>
                  <description>1': XIP mode. eXecute-In-Place mode: incoming read and write transfers over the AHB-Lite bus infrastructure are automatically translated in SPI transfers to read data from and write data to a device. This mode of operation allow for efficient device read and write operations. This mode is only supported in SPI_MODE.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLOCK_IF_RX_SEL</name>
              <description>Specifies device interface receiver clock 'clk_if_rx' source. MISO data is captured on the rising edge of 'clk_if_rx'.
'0': 'spi_clk_out' (internal clock)
'1': !'spi_clk_out' (internal clock)
'2': 'spi_clk_in' (feedback clock)
'3': !'spi_clk_in' (feedback clock)

Note: the device interface transmitter clock 'clk_if_tx' is fixed and is 'spi_clk_out' MOSI data is driven on the falling edge of 'clk_if_tx'.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DESELECT_DELAY</name>
              <description>Specifies the minimum duration of SPI deselection ('spi_select_out[]' is high/'1') in between SPI transfers:
'0': 1 interface clock cycle.
'1': 2 interface clock cycles.
'2': 3 interface clock cycles.
'3': 4 interface clock cycles.
'4': 5 interface clock cycles.
'5': 6 interface clock cycles.
'6': 7 interface clock cycles.
'7': 8 interface clock cycles.

During SPI deselection, 'spi_select_out[]' are '1'/inactive, 'spi_data_out[]' are '1' and 'spi_clk_out' is '0'/inactive.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK</name>
              <description>Specifies what happens for MMIO interface read accesses to an empty RX data FIFO or to a full TX format/data FIFO. Note: the FIFOs can only be accessed in MMIO_MODE.

This field is not used for test controller accesses.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BUS_ERROR</name>
                  <description>0': Generate an AHB-Lite bus error. This option is useful when SW decides to use polling on STATUS.TR_BUSY to determine if a interface transfer is no longer busy (transfer is completed). This option adds SW complexity, but limits the number of AHB-Lite wait states (and limits ISR latency).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WAIT_STATES</name>
                  <description>1': Introduce wait states. This setting potentially locks up the AHB-Lite infrastructure and may increase the CPU interrupt latency.This option is useful when SW performs TX/RX data FIFO accesses immediately after a command is setup using the TX format FIFO. This option has low SW complexity, but may result in a significant number of AHB-Lite wait states (and may increase ISR latency).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. All non-retention registers are reset to their default value when the IP is disabled. When the IP is disabled, the XIP accesses produce AHB-Lite bus errors.
'1': Enabled.

Note: Before disabling the IP, SW should ensure that the IP is NOT busy (STATUS.BUSY is '0'), otherwise illegal interface transfers may occur.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>BUSY</name>
              <description>Cache, cryptography, XIP, device interface or any other logic busy in the IP:
'0': not busy
'1': busy
When BUSY is '0', the IP can be safely disabled without:
- the potential loss of transient write data.
- the potential risk of aborting an inflight SPI device interface transfer.
When BUSY is '0', the mode of operation (XIP_MODE or MMIO_MODE) can be safely changed.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CMD_FIFO_STATUS</name>
          <description>Transmitter command FIFO status</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>USED3</name>
              <description>Number of entries that are used in the TX command FIFO (available in both XIP_MODE and MMIO_MODE). Legal range: [0, 4].</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CMD_FIFO_WR</name>
          <description>Transmitter command FIFO write</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA20</name>
              <description>Command data. The higher two bits DATA[19:18] specify the specific command
'0'/TX: A SPI transfer always start with a TX command FIFO entry of the 'TX' format.
- DATA[17:16] specifies the width of the data transfer:
   - '0': 1 bit/cycle (single data transfer).
   - '1': 2 bits/cycle (dual data transfer).
   - '2': 4 bits/cycle (quad data transfer).
   - '3': 8 bits/cycle (octal data transfer).
- DATA[15]: specifies whether this is the last TX Byte; i.e. whether the 'spi_select_out[3:0]' IO output signals are de-activated after the transfer.
- DATA[11:8] specifies which of the four devices are selected. DATA[11:8] are directly mapped to 'spi_select_out[3:0]'. Two devices can be selected at the same time in dual-quad mode.
  - '0': device deselected
  - '1': device selected 
- DATA[7:0] specifies the transmitted Byte.

'1'/TX_COUNT: The 'TX_COUNT' command relies on the TX data FIFO to provide the transmitted bytes. The 'TX_COUNT' command is ALWAYS considered to be the last command of a SPI data transfers.
- DATA[17:16] specifies the width of the transfer.
- DATA[15:0] specifies the number of to be transmitted Bytes (minus 1) from the TX data FIFO.

'2'/RX_COUNT: The 'RX_COUNT' command relies on the RX data FIFO to accept the received bytes. The 'RX_COUNT' command is ALWAYS considered to be the last command of a SPI data transfers.
- DATA[17:16] specifies the width of the transfer.
- DATA[15:0] specifies the number of to be transmitted Bytes (minus 1) to the RX data FIFO.

'3'/DUMMY_COUNT: The 'DUMMY_COUNT' command conveys dummy cycles. Dummy cycles are used to implement a Turn-Around time in which the SPI master changes from a transmitter driving the data lines to a receiver receiving on the same data lines. The 'DUMMY_COUNT' command is ALWAYS considered to be NOT the last command of a SPI data transfers; i.e. it needs to be followed by another command.
- DATA[15:0] specifies the number of dummy cycles (minus 1). In dummy cycles, the data lines are not driven.</description>
              <bitRange>[19:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_FIFO_CTL</name>
          <description>Transmitter data FIFO control</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Determines when the TX data FIFO 'tr_tx_req' trigger is activated  (trigger activation requires MMIO_MODE, the trigger is NOT activated in XIP_MODE):
- Trigger is active when TX_DATA_FIFO_STATUS.USED &lt;= TRIGGER_LEVEL.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_FIFO_STATUS</name>
          <description>Transmitter data FIFO status</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>USED4</name>
              <description>Number of entries that are used in the TX data FIFO (available in both XIP_MODE and MMIO_MODE). Legal range: [0, 8].</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_FIFO_WR1</name>
          <description>Transmitter data FIFO write</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>TX data (written to TX data FIFO).</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_FIFO_WR2</name>
          <description>Transmitter data FIFO write</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>TX data (written to TX data FIFO, first byte).</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>TX data (written to TX data FIFO, second byte).</description>
              <bitRange>[15:8]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_FIFO_WR4</name>
          <description>Transmitter data FIFO write</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>TX data (written to TX data FIFO, first byte).</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>TX data (written to TX data FIFO, second byte).</description>
              <bitRange>[15:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DATA2</name>
              <description>TX data (written to TX data FIFO, third byte).</description>
              <bitRange>[23:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DATA3</name>
              <description>TX data (written to TX data FIFO, fourth byte).</description>
              <bitRange>[31:24]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_FIFO_CTL</name>
          <description>Receiver data FIFO control</description>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Determines when RX data FIFO 'tr_rx_req' trigger is activated (trigger activation requires MMIO_MODE, the trigger is NOT activated in XIP_MODE):
- Trigger is active when RX_DATA_FIFO_STATUS.USED &gt; TRIGGER_LEVEL.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_FIFO_STATUS</name>
          <description>Receiver data FIFO status</description>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>USED4</name>
              <description>Number of entries that are used in the RX data FIFO (available in both XIP_MODE and MMIO_MODE). Legal range: [0, 8].</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_FIFO_RD1</name>
          <description>Receiver data FIFO read</description>
          <addressOffset>0xD0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>RX data (read from RX data FIFO).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_FIFO_RD2</name>
          <description>Receiver data FIFO read</description>
          <addressOffset>0xD4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>RX data (read from RX data FIFO, first byte).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>RX data (read from RX data FIFO, second byte).</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_FIFO_RD4</name>
          <description>Receiver data FIFO read</description>
          <addressOffset>0xD8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>RX data (read from RX data FIFO, first byte).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>RX data (read from RX data FIFO, second byte).</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA2</name>
              <description>RX data (read from RX data FIFO, third byte).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA3</name>
              <description>RX data (read from RX data FIFO, fourth byte).</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_FIFO_RD1_SILENT</name>
          <description>Receiver data FIFO silent read</description>
          <addressOffset>0xE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>RX data (read from RX data FIFO).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SLOW_CA_CTL</name>
          <description>Slow cache control</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0000000</resetValue>
          <resetMask>0xC3030000</resetMask>
          <fields>
            <field>
              <name>WAY</name>
              <description>this is for debug purpose only, and should be hidden to customers in technical document</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_ADDR</name>
              <description>this is for debug purpose only, and should be hidden to customers in technical document</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>N/A</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SLOW_CA_CMD</name>
          <description>Slow cache command</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>INV</name>
              <description>Cache and prefetch buffer invalidation. 
SW writes a '1' to clear the cache and prefetch buffer. The cache's LRU structure is also reset to its default state.
Note, 
A write access will invalidate the prefetch buffer automatically in hardware.
A write access should invalidate both fast and slow caches, by firmware.
Note, firmware should invalidate the cache and prefetch buffer only when STATUS.BUSY is '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FAST_CA_CTL</name>
          <description>Fast cache control</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0000000</resetValue>
          <resetMask>0xC3030000</resetMask>
          <fields>
            <field>
              <name>WAY</name>
              <description>this is for debug purpose only, and should be hidden to customers in technical document</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_ADDR</name>
              <description>this is for debug purpose only, and should be hidden to customers in technical document</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>N/A</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FAST_CA_CMD</name>
          <description>Fast cache command</description>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>INV</name>
              <description>See SLOW_CA_CMD.INV.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_CMD</name>
          <description>Cryptography Command</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>START</name>
              <description>SW sets this field to '1' to start a AES-128 forward block cipher operation (on the address in CRYPTO_ADDR). HW sets this field to '0' to indicate that the operation has completed. Once completed, the result of the operation can be read from CRYPTO_RESULT0, ..., CRYPTO_RESULT3.

The operation takes roughly 13 clk_hf clock cycles.

Note: An operation can only be started in MMIO_MODE.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_INPUT0</name>
          <description>Cryptography input 0</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>INPUT</name>
              <description>Four Bytes of the plaintext PT[31:0] = CRYPTO_INPUT0.INPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_INPUT1</name>
          <description>Cryptography input 1</description>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>INPUT</name>
              <description>Four Bytes of the plaintext PT[63:32] = CRYPTO_INPUT1.INPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_INPUT2</name>
          <description>Cryptography input 2</description>
          <addressOffset>0x228</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>INPUT</name>
              <description>Four Bytes of the plaintext PT[95:64] = CRYPTO_INPUT2.INPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_INPUT3</name>
          <description>Cryptography input 3</description>
          <addressOffset>0x22C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>INPUT</name>
              <description>Four Bytes of the plaintext PT[127:96] = CRYPTO_INPUT3.INPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_KEY0</name>
          <description>Cryptography key 0</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Four Bytes of the key KEY[31:0] = CRYPTO_KEY0.KEY[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_KEY1</name>
          <description>Cryptography key 1</description>
          <addressOffset>0x244</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Four Bytes of the key KEY[63:32] = CRYPTO_KEY1.KEY[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_KEY2</name>
          <description>Cryptography key 2</description>
          <addressOffset>0x248</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Four Bytes of the key KEY[95:64] = CRYPTO_KEY2.KEY[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_KEY3</name>
          <description>Cryptography key 3</description>
          <addressOffset>0x24C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Four Bytes of the key KEY[127:96] = CRYPTO_KEY3.KEY[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_OUTPUT0</name>
          <description>Cryptography output 0</description>
          <addressOffset>0x260</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>OUTPUT</name>
              <description>Four Bytes of the ciphertext CT[31:0] = CRYPTO_OUTPUT0.OUTPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_OUTPUT1</name>
          <description>Cryptography output 1</description>
          <addressOffset>0x264</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>OUTPUT</name>
              <description>Four Bytes of the ciphertext CT[63:32] = CRYPTO_OUTPUT1.OUTPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_OUTPUT2</name>
          <description>Cryptography output 2</description>
          <addressOffset>0x268</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>OUTPUT</name>
              <description>Four Bytes of the ciphertext CT[95:64] = CRYPTO_OUTPUT2.OUTPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_OUTPUT3</name>
          <description>Cryptography output 3</description>
          <addressOffset>0x26C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>OUTPUT</name>
              <description>Four Bytes of the ciphertext CT[127:96] = CRYPTO_OUTPUT3.OUTPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt register</description>
          <addressOffset>0x7C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>TR_TX_REQ</name>
              <description>Activated in MMIO mode, when a TX data FIFO trigger 'tr_tx_req' is activated.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_RX_REQ</name>
              <description>Activated in MMIO mode, when a RX data FIFO trigger 'tr_rx_req' is activated.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIP_ALIGNMENT_ERROR</name>
              <description>Activated in XIP mode, if:
- The selected device's ADDR_CTL.DIV2 is '1' and the AHB-Lite bus transfer address is not a multiple of 2.
- The selected device's ADDR_CTL.DIV2 is '1' and the XIP transfer request is NOT for a multiple of 2 Bytes. 

Note: In dual-quad SPI mode (ADDR_CTL.DIV is '1'), each memory device contributes a 4-bit nibble for read data or write data. This is only possible if the request address is a multiple of 2 and the number of requested Bytes is a multiple of 2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CMD_FIFO_OVERFLOW</name>
              <description>Activated in MMIO mode, on an AHB-Lite write transfer to the TX command FIFO (TX_CMD_FIFO_WR) with not enough free entries available.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DATA_FIFO_OVERFLOW</name>
              <description>Activated in MMIO mode, on an AHB-Lite write transfer to the TX data FIFO (TX_DATA_FIFO_WR1, TX_DATA_FIFO_WR2, TX_DATA_FIFO_WR4) with not enough free entries available.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DATA_FIFO_UNDERFLOW</name>
              <description>Activated in MMIO mode, on an AHB-Lite read transfer from the RX data FIFO (RX_DATA_FIFO_RD1, RX_DATA_FIFO_RD2, RX_DATA_FIFO_RD4) with not enough entries available. Only activated for NON test bus controller transfers.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set register</description>
          <addressOffset>0x7C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>TR_TX_REQ</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_RX_REQ</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIP_ALIGNMENT_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CMD_FIFO_OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DATA_FIFO_OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DATA_FIFO_UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0x7C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>TR_TX_REQ</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_RX_REQ</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIP_ALIGNMENT_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CMD_FIFO_OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DATA_FIFO_OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DATA_FIFO_UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked register</description>
          <addressOffset>0x7CC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>TR_TX_REQ</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TR_RX_REQ</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>XIP_ALIGNMENT_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_CMD_FIFO_OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_DATA_FIFO_OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_DATA_FIFO_UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>4</dim>
          <dimIncrement>128</dimIncrement>
          <name>DEVICE[%s]</name>
          <description>Device (only used in XIP mode)</description>
          <addressOffset>0x00000800</addressOffset>
          <register>
            <name>CTL</name>
            <description>Control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80030101</resetMask>
            <fields>
              <field>
                <name>WR_EN</name>
                <description>Write enable:
'0': write transfers are not allowed to this device. An attempt to write to this device results in an AHB-Lite bus error.
'1': write transfers are allowed to this device.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRYPTO_EN</name>
                <description>Cryptography on read/write accesses:
'0': disabled.
'1': enabled.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_SEL</name>
                <description>Specifies the connection of the IP's data lines (spi_data[0], ..., spi_data[7]) to the device's data lines (SI/IO0, SO/IO1, IO2, IO3, IO4, IO5, IO6, IO7):
'0': spi_data[0] = IO0, spi_data[1] = IO1, ..., spi_data[7] = IO7. This value is allowed for single, dual, quad, dual quad and octal SPI modes. This value must be used for the first device in dual quad SPI mode. This value must be used for octal SPI mode.
'1': spi_data[2] = IO0, spi_data[3] = IO1. This value is only allowed for single and dual SPI modes.
'2': spi_data[4] = IO0, spi_data[5] = IO1, ..., spi_data[7] = IO3. This value is only allowed for single, dual, quad and dual quad  SPI modes. In dual quad SPI mode, this value must be used for the second device. 
'3': spi_data[6] = IO0, spi_data[7] = IO1. This value is only allowed for single and dual SPI modes.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Device enable:
'0': Disabled.
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADDR</name>
            <description>Device region base address</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Specifies the base address of the device region. If the device region is 2^m Bytes, ADDR MUST be a multiple of 2^m.

In dual quad SPI data transfer, the two devices should have the same ADDR and MASK register settings. The device control information (ADDR_CTL, RD_CMD_CTL, etc.) are provided by the MMIO control registers of the device with the lowest index.

The most significant bit fields are constants and set based on the SMIF_XIP_ADDR parameter. The most significant bits are identified on the SMIF_XIP_MASK parameter. E.g., if SMIF_XIP_MASK is 0xff00:0000 (16 MB XIP memory region), ADDR[31:24] = SMIF_XIP_ADDR[31:24].</description>
                <bitRange>[31:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MASK</name>
            <description>Device region mask</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>MASK</name>
                <description>Specifies the size of the device region. All '1' bits are used to compare the incoming transfer request address A[31:0] with the address as specified in ADDR.ADDR: Address A is in the device when (A[31:8] &amp; MASK[31:8]) == ADDR.ADDR[31:8].

The most significant bit fields are constants and set to'1'. The most significant bits are identified on the SMIF_XIP_MASK parameter. E.g., if SMIF_XIP_MASK  is 0xff00:0000 (16 MB XIP memory region), MASK[31:24] = 0xff.

Note: a transfer request that is not in any device region results in an AHB-Lite bus error.</description>
                <bitRange>[31:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADDR_CTL</name>
            <description>Address control</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x103</resetMask>
            <fields>
              <field>
                <name>SIZE2</name>
                <description>Specifies the size of the XIP device address in Bytes:
'0': 1 Byte address.
'1': 2 Byte address.
'2': 3 Byte address.
'3': 4 Byte address.
The lower significant address Bytes of the transfer request are used as XIP address to the external device. Note that for dual quad SPI data transfer, the transfer request address is divided by 2. Therefore, the transfer request address needs to be a multiple of 2. If the trasnfer requestaddress is NOT a multiple of 2, the XIP_ALIGNMENT_ERROR interrupt cause is activated.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIV2</name>
                <description>Specifies if the AHB-Lite bus transfer address is divided by 2 or not:
'0': No divide by 2.
'1': Divide by 2.  

This functionality is used for read and write operation in XIP, dual quad SPI mode; i.e. this DIV2 must be set to '1' in dual quad SPI mode. If the transfer request address is NOT a multiple of 2 or the requested number of Bytes is not a multiple of 2, the XIP_ALIGNMENT_ERROR interrupt cause is activated.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_CMD_CTL</name>
            <description>Read command control</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x800300FF</resetMask>
            <fields>
              <field>
                <name>CODE</name>
                <description>Command byte code.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WIDTH</name>
                <description>Width of data transfer:
'0': 1 bit/cycle (single data transfer).
'1': 2 bits/cycle (dual data transfer).
'2': 4 bits/cycle (quad data transfer).
'3': 8 bits/cycle (octal data transfer).</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT</name>
                <description>Presence of command field:
'0': not present
'1': present</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_ADDR_CTL</name>
            <description>Read address control</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x30000</resetMask>
            <fields>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_MODE_CTL</name>
            <description>Read mode control</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x800300FF</resetMask>
            <fields>
              <field>
                <name>CODE</name>
                <description>Mode byte code.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT</name>
                <description>Presence of mode field:
'0': not present
'1': present</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_DUMMY_CTL</name>
            <description>Read dummy control</description>
            <addressOffset>0x4C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x8000001F</resetMask>
            <fields>
              <field>
                <name>SIZE5</name>
                <description>Number of dummy cycles (minus 1):
'0': 1 cycles
...
'31': 32 cycles.

Note: this field specifies dummy cycles, not dummy Bytes!</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT</name>
                <description>Presence of dummy cycles:
'0': not present
'1': present</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_DATA_CTL</name>
            <description>Read data control</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x30000</resetMask>
            <fields>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_CMD_CTL</name>
            <description>Write command control</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x800300FF</resetMask>
            <fields>
              <field>
                <name>CODE</name>
                <description>Command byte code.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT</name>
                <description>Presence of command field:
'0': not present
'1': present</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_ADDR_CTL</name>
            <description>Write address control</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x30000</resetMask>
            <fields>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_MODE_CTL</name>
            <description>Write mode control</description>
            <addressOffset>0x68</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x800300FF</resetMask>
            <fields>
              <field>
                <name>CODE</name>
                <description>Mode byte code.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT</name>
                <description>Presence of mode field:
'0': not present
'1': present</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_DUMMY_CTL</name>
            <description>Write dummy control</description>
            <addressOffset>0x6C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x8000001F</resetMask>
            <fields>
              <field>
                <name>SIZE5</name>
                <description>Number of dummy cycles (minus 1):
'0': 1 cycles
...
'31': 32 cycles.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT</name>
                <description>Presence of dummy cycles:
'0': not present
'1': present</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_DATA_CTL</name>
            <description>Write data control</description>
            <addressOffset>0x70</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x30000</resetMask>
            <fields>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>USBFS0</name>
      <description>USB Host and Device Controller</description>
      <headerStructName>USBFS</headerStructName>
      <baseAddress>0x40420000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <name>USBDEV</name>
          <description>USB Device</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>EP0_DR[%s]</name>
            <description>Control End point EP0 Data Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_BYTE</name>
                <description>This register is shared for both transmit and receive. The count in the EP0_CNT register determines the number of bytes received or to be transferred.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CR0</name>
            <description>USB control 0 Register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DEVICE_ADDRESS</name>
                <description>These bits specify the USB device address to which the SIE will respond. This address must be set by firmware and is specified by the USB Host with a SET ADDRESS command during USB enumeration. This value must be programmed by firmware when assigned during enumeration. It is not set automatically by the hardware.
If USB bus reset is detected, these bits are initialized.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>USB_ENABLE</name>
                <description>This bit enables the device to respond to USB traffic.
If USB bus reset is detected, this bit is cleared.
Note:
When USB PHY is GPIO mode(USBIO_CR1.IOMODE=0), USB bus reset is detected. Therefore, when USB PHY is GPIO mode, this bit is cleared even if this bit is set to 1. If this bit is set to 1, write this bit upon USB bus reset interrupt, and do not write to this bit during initialization steps.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CR1</name>
            <description>USB control 1 Register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>REG_ENABLE</name>
                <description>This bit controls the operation of the internal USB regulator. For applications with supply voltages in the 5V range this bit is set high to enable the internal regulator. For device supply voltage in the 3.3V range this bit is cleared to connect the transceiver directly to the supply.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE_LOCK</name>
                <description>This bit is set to turn on the automatic frequency locking of the internal oscillator to USB traffic.  Unless an external clock is being provided this bit should remain set for proper USB operation.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUS_ACTIVITY</name>
                <description>The Bus Activity bit is a stickybit that detects any non-idle USB event that has occurred on the USB bus. Once set to High by the SIE to indicate the bus activity this bit retains its logical High
value until firmware clears it.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_3</name>
                <description>N/A</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP_INT_EN</name>
            <description>USB SIE Data Endpoints Interrupt Enable Register</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>EP1_INTR_EN</name>
                <description>Enables interrupt for EP1</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2_INTR_EN</name>
                <description>Enables interrupt for EP2</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP3_INTR_EN</name>
                <description>Enables interrupt for EP3</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP4_INTR_EN</name>
                <description>Enables interrupt for EP4</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP5_INTR_EN</name>
                <description>Enables interrupt for EP5</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP6_INTR_EN</name>
                <description>Enables interrupt for EP6</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP7_INTR_EN</name>
                <description>Enables interrupt for EP7</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP8_INTR_EN</name>
                <description>Enables interrupt for EP8</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP_INT_SR</name>
            <description>USB SIE Data Endpoint Interrupt Status</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>EP1_INTR</name>
                <description>Interrupt status for EP1</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2_INTR</name>
                <description>Interrupt status for EP2</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP3_INTR</name>
                <description>Interrupt status for EP3</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP4_INTR</name>
                <description>Interrupt status for EP4</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP5_INTR</name>
                <description>Interrupt status for EP5</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP6_INTR</name>
                <description>Interrupt status for EP6</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP7_INTR</name>
                <description>Interrupt status for EP7</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP8_INTR</name>
                <description>Interrupt status for EP8</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP1_CNT0</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC7</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT_MSB</name>
                <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP1_CNT1</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT</name>
                <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP1_CR0</name>
            <description>Non-control endpoint's control Register</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  ...</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NAK_INT_EN</name>
                <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_IN_TXN</name>
                <description>The Error in transaction bit is set whenever an error is detected. For an IN transaction, this indicates a no response from HOST scenario. For an OUT transaction, this represents an RxErr (PID
error/ CRC error/ bit-stuff error scenario). This bit is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USBIO_CR0</name>
            <description>USBIO Control 0 Register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xE0</resetMask>
            <fields>
              <field>
                <name>RD</name>
                <description>Received Data. This read only bit gives the state of the USB differential receiver when IOMODE bit is '0'  and USB doesn't transmit. This bit is valid if USB Device.
If D+=D- (SE0), this value is undefined.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DIFF_LOW</name>
                    <description>D+ &lt; D- (K state)</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIFF_HIGH</name>
                    <description>D+ &gt; D- (J state)</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TD</name>
                <description>Transmit Data. Transmit a USB J or K state on the USB bus. No effect if TEN=0 or TSE0=1.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DIFF_K</name>
                    <description>Force USB K state (D+ is low D- is high).</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIFF_J</name>
                    <description>Force USB J state (D+ is high D- is low).</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TSE0</name>
                <description>Transmit Single-Ended Zero. SE0: both D+ and D- low. No effect if TEN=0.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEN</name>
                <description>USB Transmit Enable. This is used to manually transmit on the D+ and D- pins. Normally this bit should be cleared to allow the internal SIE to drive the pins. The most common reason for manually
transmitting is to force a resume state on the bus.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USBIO_CR2</name>
            <description>USBIO control 2 Register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RSVD_5_0</name>
                <description>N/A</description>
                <bitRange>[5:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TEST_PKT</name>
                <description>This bit enables the device to transmit a packet in response to an internally generated IN packet.  When set, one packet will be generated.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_7</name>
                <description>N/A</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USBIO_CR1</name>
            <description>USBIO control 1 Register</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x20</resetValue>
            <resetMask>0x20</resetMask>
            <fields>
              <field>
                <name>DMO</name>
                <description>This read only bit gives the state of the D- pin when IOMODE bit is '0'  and USB doesn't transmit.
This bit is '0' when USB transmits SE0, and this bit is '1' when USB transmits other than SE0.
This bit is valid if USB Device.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DPO</name>
                <description>This read only bit gives the state of the D+ pin when IOMODE bit is '0' and USB doesn't transmit.
This bit displays the output value of D+ pin when USB transmits SE0 or data.
This bit is valid if USB Device.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RSVD_2</name>
                <description>N/A</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IOMODE</name>
                <description>This bit allows the D+ and D- pins to be configured for either USB mode or bit-banged modes. If this bit is set the DMI and DPI bits are used to drive the D- and D+ pins.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DYN_RECONFIG</name>
            <description>USB Dynamic reconfiguration register</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>DYN_CONFIG_EN</name>
                <description>This bit is used to enable the dynamic re-configuration for the selected EP. If set to 1, indicates the reconfiguration required for selected EP.
Use 0 for EP1, 1 for EP2, etc.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DYN_RECONFIG_EPNO</name>
                <description>These bits indicates the EP number for which reconfiguration is required when dyn_config_en bit is set to 1.</description>
                <bitRange>[3:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DYN_RECONFIG_RDY_STS</name>
                <description>This bit indicates the ready status for the dynamic reconfiguration, when set to 1, indicates the block is ready for reconfiguration.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SOF0</name>
            <description>Start Of Frame Register</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>FRAME_NUMBER</name>
                <description>It has the lower 8 bits [7:0] of the SOF frame number.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SOF1</name>
            <description>Start Of Frame Register</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>FRAME_NUMBER_MSB</name>
                <description>It has the upper 3 bits [10:8] of the SOF frame number.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP2_CNT0</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x70</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC7</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT_MSB</name>
                <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP2_CNT1</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x74</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT</name>
                <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP2_CR0</name>
            <description>Non-control endpoint's control Register</description>
            <addressOffset>0x78</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  ...</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NAK_INT_EN</name>
                <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_IN_TXN</name>
                <description>The Error in transaction bit is set whenever an error is detected. For an IN transaction, this indicates a no response from HOST scenario. For an OUT transaction, this represents an RxErr (PID
error/ CRC error/ bit-stuff error scenario). This bit is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OSCLK_DR0</name>
            <description>Oscillator lock data register 0</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDER</name>
                <description>These bits return the lower 8 bits of the oscillator locking circuits adder output.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OSCLK_DR1</name>
            <description>Oscillator lock data register 1</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDER_MSB</name>
                <description>These bits return the upper 7 bits of the oscillator locking circuits adder output.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>EP0_CR</name>
            <description>Endpoint0 control Register</description>
            <addressOffset>0xA0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  ...</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OUT_RCVD</name>
                <description>When set this bit indicates a valid OUT packet has been received and ACKed. This bit is updated to '1' after the last received packet in an OUT transaction. When clear this bit indicates no OUT received. It is cleared by any writes to the register.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_RCVD</name>
                <description>When set this bit indicates a valid IN packet has been received. This bit is updated to '1' after the host acknowledges an IN data packet. When clear this bit indicates either no IN has been received or that the host did not acknowledge the IN data by sending ACK handshake. It is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SETUP_RCVD</name>
                <description>When set this bit indicates a valid SETUP packet was received and ACKed. This bit is forced HIGH from the start of the data packet phase of the SETUP transaction until the start of the ACK packet returned by the SIE. The CPU is prevented from clearing this bit during this interval. After this interval the bit will remain set until cleared by firmware. While this bit is set to '1' the CPU cannot write to the EP0_DRx registers. This prevents firmware from overwriting an incoming SETUP transaction before firmware has a chance to read the SETUP data. This bit is cleared by any non-locked writes to the register.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>EP0_CNT</name>
            <description>Endpoint0 count Register</description>
            <addressOffset>0xA4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xCF</resetMask>
            <fields>
              <field>
                <name>BYTE_COUNT</name>
                <description>These bits indicate the number of data bytes in a transaction. For IN transactions firmware loads the count with the number of bytes to be transmitted to the host from the endpoint FIFO. Valid values are 0 to 8. For OUT or SETUP transactions the count is updated by hardware to the number of data bytes received plus two for the CRC bytes. Valid values are 2 to 10.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT/SETUP transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP3_CNT0</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0xB0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC7</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT_MSB</name>
                <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP3_CNT1</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0xB4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT</name>
                <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP3_CR0</name>
            <description>Non-control endpoint's control Register</description>
            <addressOffset>0xB8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  ...</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NAK_INT_EN</name>
                <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_IN_TXN</name>
                <description>The Error in transaction bit is set whenever an error is detected. For an IN transaction, this indicates a no response from HOST scenario. For an OUT transaction, this represents an RxErr (PID
error/ CRC error/ bit-stuff error scenario). This bit is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP4_CNT0</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0xF0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC7</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT_MSB</name>
                <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP4_CNT1</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0xF4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT</name>
                <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP4_CR0</name>
            <description>Non-control endpoint's control Register</description>
            <addressOffset>0xF8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  ...</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NAK_INT_EN</name>
                <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_IN_TXN</name>
                <description>The Error in transaction bit is set whenever an error is detected. For an IN transaction, this indicates a no response from HOST scenario. For an OUT transaction, this represents an RxErr (PID
error/ CRC error/ bit-stuff error scenario). This bit is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP5_CNT0</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x130</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC7</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT_MSB</name>
                <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP5_CNT1</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x134</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT</name>
                <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP5_CR0</name>
            <description>Non-control endpoint's control Register</description>
            <addressOffset>0x138</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  ...</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NAK_INT_EN</name>
                <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_IN_TXN</name>
                <description>The Error in transaction bit is set whenever an error is detected. For an IN transaction, this indicates a no response from HOST scenario. For an OUT transaction, this represents an RxErr (PID
error/ CRC error/ bit-stuff error scenario). This bit is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP6_CNT0</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x170</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC7</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT_MSB</name>
                <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP6_CNT1</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x174</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT</name>
                <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP6_CR0</name>
            <description>Non-control endpoint's control Register</description>
            <addressOffset>0x178</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  ...</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NAK_INT_EN</name>
                <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_IN_TXN</name>
                <description>The Error in transaction bit is set whenever an error is detected. For an IN transaction, this indicates a no response from HOST scenario. For an OUT transaction, this represents an RxErr (PID
error/ CRC error/ bit-stuff error scenario). This bit is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP7_CNT0</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x1B0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC7</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT_MSB</name>
                <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP7_CNT1</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x1B4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT</name>
                <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP7_CR0</name>
            <description>Non-control endpoint's control Register</description>
            <addressOffset>0x1B8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  ...</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NAK_INT_EN</name>
                <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_IN_TXN</name>
                <description>The Error in transaction bit is set whenever an error is detected. For an IN transaction, this indicates a no response from HOST scenario. For an OUT transaction, this represents an RxErr (PID
error/ CRC error/ bit-stuff error scenario). This bit is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP8_CNT0</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x1F0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC7</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT_MSB</name>
                <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP8_CNT1</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x1F4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT</name>
                <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP8_CR0</name>
            <description>Non-control endpoint's control Register</description>
            <addressOffset>0x1F8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  ...</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NAK_INT_EN</name>
                <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_IN_TXN</name>
                <description>The Error in transaction bit is set whenever an error is detected. For an IN transaction, this indicates a no response from HOST scenario. For an OUT transaction, this represents an RxErr (PID
error/ CRC error/ bit-stuff error scenario). This bit is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP1_CFG</name>
            <description>Endpoint Configuration Register  *1</description>
            <addressOffset>0x200</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>IN_DATA_RDY</name>
                <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_REQ</name>
                <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_BYPASS</name>
                <description>Configuration Setting to prevent CRC bytes from being written to memory and being read by firmware</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CRC_NORMAL</name>
                    <description>No CRC bypass; CRC bytes will be written to memory and Termin will be generated for the CRC byte/s</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRC_BYPASS</name>
                    <description>CRC Bypass Set; CRC bytes will not be written into memory and Termin will be generated for the last data byte/s</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET_PTR</name>
                <description>Configuration Setting to Reset the RA and WA Pointers to their start values at the End of Packet transaction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RESET_KRYPTON</name>
                    <description>Do not Reset Pointer; Krypton Backward compatibility mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET_NORMAL</name>
                    <description>Reset Pointer; recommended value for reduction of CPU Configuration Writes.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP1_INT_EN</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x204</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL_EN</name>
                <description>IN Endpoint Local Buffer Full Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT_EN</name>
                <description>Endpoint DMA Grant Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER_EN</name>
                <description>Endpoint Buffer Overflow Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER_EN</name>
                <description>Endpoint Buffer Underflow Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INT_EN</name>
                <description>Endpoint Error in Transaction Interrupt Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN_EN</name>
                <description>Endpoint DMA Terminated Enable</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP1_SR</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x208</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL</name>
                <description>IN Endpoint Local Buffer Full Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT</name>
                <description>Endpoint DMA Grant Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER</name>
                <description>Endpoint Buffer Overflow Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER</name>
                <description>Endpoint Buffer Underflow Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN</name>
                <description>Endpoint DMA Terminated Interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW1_WA</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x210</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WA</name>
                <description>Write Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW1_WA_MSB</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x214</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WA_MSB</name>
                <description>Write Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW1_RA</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x218</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Read Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW1_RA_MSB</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x21C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RA_MSB</name>
                <description>Read Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW1_DR</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x220</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BUF_SIZE</name>
            <description>Dedicated Endpoint Buffer Size Register  *1</description>
            <addressOffset>0x230</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>IN_BUF</name>
                <description>Buffer size for IN Endpoints.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT_BUF</name>
                <description>Buffer size for OUT Endpoints.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>EP_ACTIVE</name>
            <description>Endpoint Active Indication Register  *1</description>
            <addressOffset>0x238</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>EP1_ACT</name>
                <description>Indicates that Endpoint is currently active.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2_ACT</name>
                <description>Indicates that Endpoint is currently active.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP3_ACT</name>
                <description>Indicates that Endpoint is currently active.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP4_ACT</name>
                <description>Indicates that Endpoint is currently active.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP5_ACT</name>
                <description>Indicates that Endpoint is currently active.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP6_ACT</name>
                <description>Indicates that Endpoint is currently active.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP7_ACT</name>
                <description>Indicates that Endpoint is currently active.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP8_ACT</name>
                <description>Indicates that Endpoint is currently active.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>EP_TYPE</name>
            <description>Endpoint Type (IN/OUT) Indication  *1</description>
            <addressOffset>0x23C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>EP1_TYP</name>
                <description>Endpoint Type Indication.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EP_IN</name>
                    <description>IN outpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EP_OUT</name>
                    <description>OUT outpoint</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP2_TYP</name>
                <description>Endpoint Type Indication.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EP_IN</name>
                    <description>IN outpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EP_OUT</name>
                    <description>OUT outpoint</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP3_TYP</name>
                <description>Endpoint Type Indication.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EP_IN</name>
                    <description>IN outpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EP_OUT</name>
                    <description>OUT outpoint</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP4_TYP</name>
                <description>Endpoint Type Indication.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EP_IN</name>
                    <description>IN outpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EP_OUT</name>
                    <description>OUT outpoint</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP5_TYP</name>
                <description>Endpoint Type Indication.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EP_IN</name>
                    <description>IN outpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EP_OUT</name>
                    <description>OUT outpoint</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP6_TYP</name>
                <description>Endpoint Type Indication.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EP_IN</name>
                    <description>IN outpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EP_OUT</name>
                    <description>OUT outpoint</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP7_TYP</name>
                <description>Endpoint Type Indication.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EP_IN</name>
                    <description>IN outpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EP_OUT</name>
                    <description>OUT outpoint</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP8_TYP</name>
                <description>Endpoint Type Indication.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EP_IN</name>
                    <description>IN outpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EP_OUT</name>
                    <description>OUT outpoint</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP2_CFG</name>
            <description>Endpoint Configuration Register  *1</description>
            <addressOffset>0x240</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>IN_DATA_RDY</name>
                <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_REQ</name>
                <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_BYPASS</name>
                <description>Configuration Setting to prevent CRC bytes from being written to memory and being read by firmware</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CRC_NORMAL</name>
                    <description>No CRC bypass; CRC bytes will be written to memory and Termin will be generated for the CRC byte/s</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRC_BYPASS</name>
                    <description>CRC Bypass Set; CRC bytes will not be written into memory and Termin will be generated for the last data byte/s</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET_PTR</name>
                <description>Configuration Setting to Reset the RA and WA Pointers to their start values at the End of Packet transaction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RESET_KRYPTON</name>
                    <description>Do not Reset Pointer; Krypton Backward compatibility mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET_NORMAL</name>
                    <description>Reset Pointer; recommended value for reduction of CPU Configuration Writes.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP2_INT_EN</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x244</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL_EN</name>
                <description>IN Endpoint Local Buffer Full Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT_EN</name>
                <description>Endpoint DMA Grant Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER_EN</name>
                <description>Endpoint Buffer Overflow Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER_EN</name>
                <description>Endpoint Buffer Underflow Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INT_EN</name>
                <description>Endpoint Error in Transaction Interrupt Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN_EN</name>
                <description>Endpoint DMA Terminated Enable</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP2_SR</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x248</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL</name>
                <description>IN Endpoint Local Buffer Full Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT</name>
                <description>Endpoint DMA Grant Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER</name>
                <description>Endpoint Buffer Overflow Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER</name>
                <description>Endpoint Buffer Underflow Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN</name>
                <description>Endpoint DMA Terminated Interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW2_WA</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x250</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WA</name>
                <description>Write Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW2_WA_MSB</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x254</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WA_MSB</name>
                <description>Write Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW2_RA</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x258</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Read Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW2_RA_MSB</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x25C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RA_MSB</name>
                <description>Read Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW2_DR</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x260</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_CFG</name>
            <description>Arbiter Configuration Register  *1</description>
            <addressOffset>0x270</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF0</resetMask>
            <fields>
              <field>
                <name>AUTO_MEM</name>
                <description>Enables Auto Memory Configuration.  Manual memory configuration by default.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_CFG</name>
                <description>DMA Access Configuration.</description>
                <bitRange>[6:5]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DMA_NONE</name>
                    <description>No DMA</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DMA_MANUAL</name>
                    <description>Manual DMA</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DMA_AUTO</name>
                    <description>Auto DMA</description>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CFG_CMP</name>
                <description>Register Configuration Complete Indication. Posedge is detected on this bit. Hence a 0 to 1 transition is required.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USB_CLK_EN</name>
            <description>USB Block Clock Enable Register</description>
            <addressOffset>0x274</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CSR_CLK_EN</name>
                <description>Clock Enable for Core Logic clocked by AHB bus clock</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_INT_EN</name>
            <description>Arbiter Interrupt Enable  *1</description>
            <addressOffset>0x278</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>EP1_INTR_EN</name>
                <description>Enables interrupt for EP1</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2_INTR_EN</name>
                <description>Enables interrupt for EP2</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP3_INTR_EN</name>
                <description>Enables interrupt for EP3</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP4_INTR_EN</name>
                <description>Enables interrupt for EP4</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP5_INTR_EN</name>
                <description>Enables interrupt for EP5</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP6_INTR_EN</name>
                <description>Enables interrupt for EP6</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP7_INTR_EN</name>
                <description>Enables interrupt for EP7</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP8_INTR_EN</name>
                <description>Enables interrupt for EP8</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_INT_SR</name>
            <description>Arbiter Interrupt Status  *1</description>
            <addressOffset>0x27C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>EP1_INTR</name>
                <description>Interrupt status for EP1</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2_INTR</name>
                <description>Interrupt status for EP2</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP3_INTR</name>
                <description>Interrupt status for EP3</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP4_INTR</name>
                <description>Interrupt status for EP4</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP5_INTR</name>
                <description>Interrupt status for EP5</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP6_INTR</name>
                <description>Interrupt status for EP6</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP7_INTR</name>
                <description>Interrupt status for EP7</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP8_INTR</name>
                <description>Interrupt status for EP8</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP3_CFG</name>
            <description>Endpoint Configuration Register  *1</description>
            <addressOffset>0x280</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>IN_DATA_RDY</name>
                <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_REQ</name>
                <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_BYPASS</name>
                <description>Configuration Setting to prevent CRC bytes from being written to memory and being read by firmware</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CRC_NORMAL</name>
                    <description>No CRC bypass; CRC bytes will be written to memory and Termin will be generated for the CRC byte/s</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRC_BYPASS</name>
                    <description>CRC Bypass Set; CRC bytes will not be written into memory and Termin will be generated for the last data byte/s</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET_PTR</name>
                <description>Configuration Setting to Reset the RA and WA Pointers to their start values at the End of Packet transaction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RESET_KRYPTON</name>
                    <description>Do not Reset Pointer; Krypton Backward compatibility mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET_NORMAL</name>
                    <description>Reset Pointer; recommended value for reduction of CPU Configuration Writes.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP3_INT_EN</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x284</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL_EN</name>
                <description>IN Endpoint Local Buffer Full Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT_EN</name>
                <description>Endpoint DMA Grant Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER_EN</name>
                <description>Endpoint Buffer Overflow Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER_EN</name>
                <description>Endpoint Buffer Underflow Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INT_EN</name>
                <description>Endpoint Error in Transaction Interrupt Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN_EN</name>
                <description>Endpoint DMA Terminated Enable</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP3_SR</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x288</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL</name>
                <description>IN Endpoint Local Buffer Full Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT</name>
                <description>Endpoint DMA Grant Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER</name>
                <description>Endpoint Buffer Overflow Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER</name>
                <description>Endpoint Buffer Underflow Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN</name>
                <description>Endpoint DMA Terminated Interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW3_WA</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x290</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WA</name>
                <description>Write Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW3_WA_MSB</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x294</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WA_MSB</name>
                <description>Write Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW3_RA</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x298</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Read Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW3_RA_MSB</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x29C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RA_MSB</name>
                <description>Read Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW3_DR</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x2A0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CWA</name>
            <description>Common Area Write Address  *1</description>
            <addressOffset>0x2B0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>CWA</name>
                <description>Write Address for Common Area</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CWA_MSB</name>
            <description>Endpoint Read Address value  *1</description>
            <addressOffset>0x2B4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CWA_MSB</name>
                <description>Write Address for Common Area</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP4_CFG</name>
            <description>Endpoint Configuration Register  *1</description>
            <addressOffset>0x2C0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>IN_DATA_RDY</name>
                <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_REQ</name>
                <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_BYPASS</name>
                <description>Configuration Setting to prevent CRC bytes from being written to memory and being read by firmware</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CRC_NORMAL</name>
                    <description>No CRC bypass; CRC bytes will be written to memory and Termin will be generated for the CRC byte/s</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRC_BYPASS</name>
                    <description>CRC Bypass Set; CRC bytes will not be written into memory and Termin will be generated for the last data byte/s</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET_PTR</name>
                <description>Configuration Setting to Reset the RA and WA Pointers to their start values at the End of Packet transaction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RESET_KRYPTON</name>
                    <description>Do not Reset Pointer; Krypton Backward compatibility mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET_NORMAL</name>
                    <description>Reset Pointer; recommended value for reduction of CPU Configuration Writes.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP4_INT_EN</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x2C4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL_EN</name>
                <description>IN Endpoint Local Buffer Full Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT_EN</name>
                <description>Endpoint DMA Grant Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER_EN</name>
                <description>Endpoint Buffer Overflow Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER_EN</name>
                <description>Endpoint Buffer Underflow Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INT_EN</name>
                <description>Endpoint Error in Transaction Interrupt Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN_EN</name>
                <description>Endpoint DMA Terminated Enable</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP4_SR</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x2C8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL</name>
                <description>IN Endpoint Local Buffer Full Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT</name>
                <description>Endpoint DMA Grant Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER</name>
                <description>Endpoint Buffer Overflow Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER</name>
                <description>Endpoint Buffer Underflow Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN</name>
                <description>Endpoint DMA Terminated Interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW4_WA</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x2D0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WA</name>
                <description>Write Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW4_WA_MSB</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x2D4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WA_MSB</name>
                <description>Write Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW4_RA</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x2D8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Read Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW4_RA_MSB</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x2DC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RA_MSB</name>
                <description>Read Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW4_DR</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x2E0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_THRES</name>
            <description>DMA Burst / Threshold Configuration</description>
            <addressOffset>0x2F0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DMA_THS</name>
                <description>DMA Threshold count</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_THRES_MSB</name>
            <description>DMA Burst / Threshold Configuration</description>
            <addressOffset>0x2F4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>DMA_THS_MSB</name>
                <description>DMA Threshold count</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP5_CFG</name>
            <description>Endpoint Configuration Register  *1</description>
            <addressOffset>0x300</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>IN_DATA_RDY</name>
                <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_REQ</name>
                <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_BYPASS</name>
                <description>Configuration Setting to prevent CRC bytes from being written to memory and being read by firmware</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CRC_NORMAL</name>
                    <description>No CRC bypass; CRC bytes will be written to memory and Termin will be generated for the CRC byte/s</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRC_BYPASS</name>
                    <description>CRC Bypass Set; CRC bytes will not be written into memory and Termin will be generated for the last data byte/s</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET_PTR</name>
                <description>Configuration Setting to Reset the RA and WA Pointers to their start values at the End of Packet transaction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RESET_KRYPTON</name>
                    <description>Do not Reset Pointer; Krypton Backward compatibility mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET_NORMAL</name>
                    <description>Reset Pointer; recommended value for reduction of CPU Configuration Writes.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP5_INT_EN</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x304</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL_EN</name>
                <description>IN Endpoint Local Buffer Full Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT_EN</name>
                <description>Endpoint DMA Grant Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER_EN</name>
                <description>Endpoint Buffer Overflow Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER_EN</name>
                <description>Endpoint Buffer Underflow Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INT_EN</name>
                <description>Endpoint Error in Transaction Interrupt Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN_EN</name>
                <description>Endpoint DMA Terminated Enable</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP5_SR</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x308</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL</name>
                <description>IN Endpoint Local Buffer Full Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT</name>
                <description>Endpoint DMA Grant Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER</name>
                <description>Endpoint Buffer Overflow Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER</name>
                <description>Endpoint Buffer Underflow Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN</name>
                <description>Endpoint DMA Terminated Interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW5_WA</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x310</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WA</name>
                <description>Write Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW5_WA_MSB</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x314</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WA_MSB</name>
                <description>Write Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW5_RA</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x318</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Read Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW5_RA_MSB</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x31C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RA_MSB</name>
                <description>Read Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW5_DR</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x320</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BUS_RST_CNT</name>
            <description>Bus Reset Count Register</description>
            <addressOffset>0x330</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xA</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>BUS_RST_CNT</name>
                <description>Bus Reset Count Length</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP6_CFG</name>
            <description>Endpoint Configuration Register  *1</description>
            <addressOffset>0x340</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>IN_DATA_RDY</name>
                <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_REQ</name>
                <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_BYPASS</name>
                <description>Configuration Setting to prevent CRC bytes from being written to memory and being read by firmware</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CRC_NORMAL</name>
                    <description>No CRC bypass; CRC bytes will be written to memory and Termin will be generated for the CRC byte/s</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRC_BYPASS</name>
                    <description>CRC Bypass Set; CRC bytes will not be written into memory and Termin will be generated for the last data byte/s</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET_PTR</name>
                <description>Configuration Setting to Reset the RA and WA Pointers to their start values at the End of Packet transaction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RESET_KRYPTON</name>
                    <description>Do not Reset Pointer; Krypton Backward compatibility mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET_NORMAL</name>
                    <description>Reset Pointer; recommended value for reduction of CPU Configuration Writes.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP6_INT_EN</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x344</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL_EN</name>
                <description>IN Endpoint Local Buffer Full Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT_EN</name>
                <description>Endpoint DMA Grant Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER_EN</name>
                <description>Endpoint Buffer Overflow Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER_EN</name>
                <description>Endpoint Buffer Underflow Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INT_EN</name>
                <description>Endpoint Error in Transaction Interrupt Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN_EN</name>
                <description>Endpoint DMA Terminated Enable</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP6_SR</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x348</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL</name>
                <description>IN Endpoint Local Buffer Full Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT</name>
                <description>Endpoint DMA Grant Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER</name>
                <description>Endpoint Buffer Overflow Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER</name>
                <description>Endpoint Buffer Underflow Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN</name>
                <description>Endpoint DMA Terminated Interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW6_WA</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x350</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WA</name>
                <description>Write Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW6_WA_MSB</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x354</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WA_MSB</name>
                <description>Write Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW6_RA</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x358</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Read Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW6_RA_MSB</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x35C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RA_MSB</name>
                <description>Read Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW6_DR</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x360</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP7_CFG</name>
            <description>Endpoint Configuration Register  *1</description>
            <addressOffset>0x380</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>IN_DATA_RDY</name>
                <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_REQ</name>
                <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_BYPASS</name>
                <description>Configuration Setting to prevent CRC bytes from being written to memory and being read by firmware</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CRC_NORMAL</name>
                    <description>No CRC bypass; CRC bytes will be written to memory and Termin will be generated for the CRC byte/s</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRC_BYPASS</name>
                    <description>CRC Bypass Set; CRC bytes will not be written into memory and Termin will be generated for the last data byte/s</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET_PTR</name>
                <description>Configuration Setting to Reset the RA and WA Pointers to their start values at the End of Packet transaction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RESET_KRYPTON</name>
                    <description>Do not Reset Pointer; Krypton Backward compatibility mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET_NORMAL</name>
                    <description>Reset Pointer; recommended value for reduction of CPU Configuration Writes.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP7_INT_EN</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x384</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL_EN</name>
                <description>IN Endpoint Local Buffer Full Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT_EN</name>
                <description>Endpoint DMA Grant Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER_EN</name>
                <description>Endpoint Buffer Overflow Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER_EN</name>
                <description>Endpoint Buffer Underflow Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INT_EN</name>
                <description>Endpoint Error in Transaction Interrupt Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN_EN</name>
                <description>Endpoint DMA Terminated Enable</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP7_SR</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x388</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL</name>
                <description>IN Endpoint Local Buffer Full Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT</name>
                <description>Endpoint DMA Grant Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER</name>
                <description>Endpoint Buffer Overflow Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER</name>
                <description>Endpoint Buffer Underflow Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN</name>
                <description>Endpoint DMA Terminated Interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW7_WA</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x390</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WA</name>
                <description>Write Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW7_WA_MSB</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x394</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WA_MSB</name>
                <description>Write Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW7_RA</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x398</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Read Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW7_RA_MSB</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x39C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RA_MSB</name>
                <description>Read Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW7_DR</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x3A0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP8_CFG</name>
            <description>Endpoint Configuration Register  *1</description>
            <addressOffset>0x3C0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>IN_DATA_RDY</name>
                <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_REQ</name>
                <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_BYPASS</name>
                <description>Configuration Setting to prevent CRC bytes from being written to memory and being read by firmware</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CRC_NORMAL</name>
                    <description>No CRC bypass; CRC bytes will be written to memory and Termin will be generated for the CRC byte/s</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRC_BYPASS</name>
                    <description>CRC Bypass Set; CRC bytes will not be written into memory and Termin will be generated for the last data byte/s</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET_PTR</name>
                <description>Configuration Setting to Reset the RA and WA Pointers to their start values at the End of Packet transaction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RESET_KRYPTON</name>
                    <description>Do not Reset Pointer; Krypton Backward compatibility mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET_NORMAL</name>
                    <description>Reset Pointer; recommended value for reduction of CPU Configuration Writes.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP8_INT_EN</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x3C4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL_EN</name>
                <description>IN Endpoint Local Buffer Full Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT_EN</name>
                <description>Endpoint DMA Grant Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER_EN</name>
                <description>Endpoint Buffer Overflow Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER_EN</name>
                <description>Endpoint Buffer Underflow Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INT_EN</name>
                <description>Endpoint Error in Transaction Interrupt Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN_EN</name>
                <description>Endpoint DMA Terminated Enable</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP8_SR</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x3C8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL</name>
                <description>IN Endpoint Local Buffer Full Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT</name>
                <description>Endpoint DMA Grant Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER</name>
                <description>Endpoint Buffer Overflow Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER</name>
                <description>Endpoint Buffer Underflow Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN</name>
                <description>Endpoint DMA Terminated Interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW8_WA</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x3D0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WA</name>
                <description>Write Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW8_WA_MSB</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x3D4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WA_MSB</name>
                <description>Write Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW8_RA</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x3D8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Read Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW8_RA_MSB</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x3DC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RA_MSB</name>
                <description>Read Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW8_DR</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x3E0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>512</dim>
            <dimIncrement>4</dimIncrement>
            <name>MEM_DATA[%s]</name>
            <description>DATA</description>
            <addressOffset>0x400</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SOF16</name>
            <description>Start Of Frame Register</description>
            <addressOffset>0x1060</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FF</resetMask>
            <fields>
              <field>
                <name>FRAME_NUMBER16</name>
                <description>The frame number (11b)</description>
                <bitRange>[10:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OSCLK_DR16</name>
            <description>Oscillator lock data register</description>
            <addressOffset>0x1080</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDER16</name>
                <description>These bits return the oscillator locking circuits adder output.</description>
                <bitRange>[14:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW1_WA16</name>
            <description>Endpoint Write Address value  *3</description>
            <addressOffset>0x1210</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>WA16</name>
                <description>Write Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW1_RA16</name>
            <description>Endpoint Read Address value  *3</description>
            <addressOffset>0x1218</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>RA16</name>
                <description>Read Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW1_DR16</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x1220</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR16</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW2_WA16</name>
            <description>Endpoint Write Address value  *3</description>
            <addressOffset>0x1250</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>WA16</name>
                <description>Write Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW2_RA16</name>
            <description>Endpoint Read Address value  *3</description>
            <addressOffset>0x1258</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>RA16</name>
                <description>Read Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW2_DR16</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x1260</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR16</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW3_WA16</name>
            <description>Endpoint Write Address value  *3</description>
            <addressOffset>0x1290</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>WA16</name>
                <description>Write Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW3_RA16</name>
            <description>Endpoint Read Address value  *3</description>
            <addressOffset>0x1298</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>RA16</name>
                <description>Read Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW3_DR16</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x12A0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR16</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CWA16</name>
            <description>Common Area Write Address</description>
            <addressOffset>0x12B0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>CWA16</name>
                <description>Write Address for Common Area</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW4_WA16</name>
            <description>Endpoint Write Address value  *3</description>
            <addressOffset>0x12D0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>WA16</name>
                <description>Write Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW4_RA16</name>
            <description>Endpoint Read Address value  *3</description>
            <addressOffset>0x12D8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>RA16</name>
                <description>Read Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW4_DR16</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x12E0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR16</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_THRES16</name>
            <description>DMA Burst / Threshold Configuration</description>
            <addressOffset>0x12F0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>DMA_THS16</name>
                <description>DMA Threshold count</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW5_WA16</name>
            <description>Endpoint Write Address value  *3</description>
            <addressOffset>0x1310</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>WA16</name>
                <description>Write Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW5_RA16</name>
            <description>Endpoint Read Address value  *3</description>
            <addressOffset>0x1318</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>RA16</name>
                <description>Read Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW5_DR16</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x1320</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR16</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW6_WA16</name>
            <description>Endpoint Write Address value  *3</description>
            <addressOffset>0x1350</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>WA16</name>
                <description>Write Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW6_RA16</name>
            <description>Endpoint Read Address value  *3</description>
            <addressOffset>0x1358</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>RA16</name>
                <description>Read Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW6_DR16</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x1360</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR16</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW7_WA16</name>
            <description>Endpoint Write Address value  *3</description>
            <addressOffset>0x1390</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>WA16</name>
                <description>Write Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW7_RA16</name>
            <description>Endpoint Read Address value  *3</description>
            <addressOffset>0x1398</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>RA16</name>
                <description>Read Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW7_DR16</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x13A0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR16</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW8_WA16</name>
            <description>Endpoint Write Address value  *3</description>
            <addressOffset>0x13D0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>WA16</name>
                <description>Write Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW8_RA16</name>
            <description>Endpoint Read Address value  *3</description>
            <addressOffset>0x13D8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>RA16</name>
                <description>Read Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW8_DR16</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x13E0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR16</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>USBLPM</name>
          <description>USB Device LPM and PHY Test</description>
          <addressOffset>0x00002000</addressOffset>
          <register>
            <name>POWER_CTL</name>
            <description>Power Control Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x303F0004</resetMask>
            <fields>
              <field>
                <name>SUSPEND</name>
                <description>Put PHY into Suspend mode.  If the PHY is enabled, this bit MUST be set before entering a low power mode (DeepSleep).
Note:
- This bit is invalid if the HOST bit of the Host Control 0 Register (HOST_CTL0) is '1'.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DP_UP_EN</name>
                <description>Enables the pull up on the DP.
'0' : Disable.
'1' : Enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DP_BIG</name>
                <description>Select the resister value if POWER_CTL.DP_EN='1'. This bit is valid in GPIO.
'0' : The resister value is from 900 to1575Ohmpull up on the DP.
'1' : The resister value is from 1425 to 3090Ohmpull up on the DP</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DP_DOWN_EN</name>
                <description>Enables the ~15k pull down on the DP.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM_UP_EN</name>
                <description>Enables the pull up on the DM. The bit is valid in GPIO. The pull up resistor is disabled in not GPIO.
'0' : Disable.
'1' : Enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM_BIG</name>
                <description>Select the resister value if POWER_CTL.DM_EN='1'. This bit is valid in GPIO.
'0' : The resister value is from 900 to1575Ohmpull up on the DM.
'1' : The resister value is from 1425 to 3090Ohmpull up on the DM</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM_DOWN_EN</name>
                <description>Enables the ~15k pull down on the DP.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE_DPO</name>
                <description>Enables the single ended receiver on D+.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE_DMO</name>
                <description>Enables the signle ended receiver on D-.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USBIO_CTL</name>
            <description>USB IO Control Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>DM_P</name>
                <description>The GPIO Drive Mode for DP IO pad. This field only applies if USBIO_CR1.IOMODE =1. Data comes from the corresponding GPIO.DR register.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OFF</name>
                    <description>Mode 0: Output buffer off (high Z). Input buffer off.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INPUT</name>
                    <description>Mode 1: Output buffer off (high Z). Input buffer on.

Other values, not supported.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DM_M</name>
                <description>The GPIO Drive Mode for DM IO pad.</description>
                <bitRange>[5:3]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FLOW_CTL</name>
            <description>Flow Control Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>EP1_ERR_RESP</name>
                <description>End Point 1 error response
0: do nothing (backward compatibility mode)
1: if this is an IN EP and an underflow occurs then cause a CRC error, if this is an OUT EP and an overflow occurs then send a NAK</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2_ERR_RESP</name>
                <description>End Point 2 error response</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP3_ERR_RESP</name>
                <description>End Point 3 error response</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP4_ERR_RESP</name>
                <description>End Point 4 error response</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP5_ERR_RESP</name>
                <description>End Point 5 error response</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP6_ERR_RESP</name>
                <description>End Point 6 error response</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP7_ERR_RESP</name>
                <description>End Point 7 error response</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP8_ERR_RESP</name>
                <description>End Point 8 error response</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LPM_CTL</name>
            <description>LPM Control Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x17</resetMask>
            <fields>
              <field>
                <name>LPM_EN</name>
                <description>LPM enable
0: Disabled, LPM token will not get a response (backward compatibility mode) 
1: Enable, LPM token will get a handshake response (ACK, STALL, NYET or NAK)
       A STALL will be sent if the bLinkState is not 0001b
       A NYET, NAK or ACK response will be sent depending on the NYET_EN and LPM_ACK_RESP bits below</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LPM_ACK_RESP</name>
                <description>LPM ACK response enable (if LPM_EN=1), to allow firmware to refuse a low power request 
0: a LPM token will get a NYET or NAK (depending on NYET_EN bit below) response and the device will NOT go to a low power mode  
1: a LPM token will get an ACK response and the device will go to the requested low power mode</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NYET_EN</name>
                <description>Allow firmware to choose which response to use for an LPM token (LPM_EN=1) when the device is NOT ready to go to the requested low power mode (LPM_ACK_RESP=0).
0: a LPM token will get an NAK response (indicating a CRC error),  the host is expected to repeat the LPM token.
1: a LPM token will get a NYET response</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SUB_RESP</name>
                <description>Enable a STALL response for all undefined SubPIDs, i.e. other than LPM (0011b). If not enabled then there will be no response (Error) for the undefined SubPIDs.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LPM_STAT</name>
            <description>LPM Status register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>LPM_BESL</name>
                <description>Best Effort Service Latency
This value should match either the Baseline (DeepSleep) or Deep (Hibernate) BESL in the BOS descriptor.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LPM_REMOTEWAKE</name>
                <description>0: Device is prohibited from initiating a remote wake
1: Device is allow to wake the host</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SIE</name>
            <description>USB SOF, BUS RESET and EP0 Interrupt Status</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>SOF_INTR</name>
                <description>Interrupt status for USB SOF</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUS_RESET_INTR</name>
                <description>Interrupt status for BUS RESET</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP0_INTR</name>
                <description>Interrupt status for EP0</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LPM_INTR</name>
                <description>Interrupt status for LPM  (Link Power Management, L1 entry)</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESUME_INTR</name>
                <description>Interrupt status for Resume</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SIE_SET</name>
            <description>USB SOF, BUS RESET and EP0 Interrupt Set</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>SOF_INTR_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUS_RESET_INTR_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP0_INTR_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LPM_INTR_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESUME_INTR_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SIE_MASK</name>
            <description>USB SOF, BUS RESET and EP0 Interrupt Mask</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>SOF_INTR_MASK</name>
                <description>Set to 1 to enable interrupt corresponding to interrupt request register</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUS_RESET_INTR_MASK</name>
                <description>Set to 1 to enable interrupt corresponding to interrupt request register</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP0_INTR_MASK</name>
                <description>Set to 1 to enable interrupt corresponding to interrupt request register</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LPM_INTR_MASK</name>
                <description>Set to 1 to enable interrupt corresponding to interrupt request register</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESUME_INTR_MASK</name>
                <description>Set to 1 to enable interrupt corresponding to interrupt request register</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SIE_MASKED</name>
            <description>USB SOF, BUS RESET and EP0 Interrupt Masked</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>SOF_INTR_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BUS_RESET_INTR_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP0_INTR_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LPM_INTR_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RESUME_INTR_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_LVL_SEL</name>
            <description>Select interrupt level for each interrupt source</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFC3FF</resetMask>
            <fields>
              <field>
                <name>SOF_LVL_SEL</name>
                <description>USB SOF Interrupt level select</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>HI</name>
                    <description>High priority interrupt</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MED</name>
                    <description>Medium priority interrupt</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LO</name>
                    <description>Low priority interrupt</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD</name>
                    <description>illegal</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BUS_RESET_LVL_SEL</name>
                <description>BUS RESET Interrupt level select</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP0_LVL_SEL</name>
                <description>EP0 Interrupt level select</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LPM_LVL_SEL</name>
                <description>LPM Interrupt level select</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESUME_LVL_SEL</name>
                <description>Resume Interrupt level select</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ARB_EP_LVL_SEL</name>
                <description>Arbiter Endpoint Interrupt level select</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP1_LVL_SEL</name>
                <description>EP1 Interrupt level select</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2_LVL_SEL</name>
                <description>EP2 Interrupt level select</description>
                <bitRange>[19:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP3_LVL_SEL</name>
                <description>EP3 Interrupt level select</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP4_LVL_SEL</name>
                <description>EP4 Interrupt level select</description>
                <bitRange>[23:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP5_LVL_SEL</name>
                <description>EP5 Interrupt level select</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP6_LVL_SEL</name>
                <description>EP6 Interrupt level select</description>
                <bitRange>[27:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP7_LVL_SEL</name>
                <description>EP7 Interrupt level select</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP8_LVL_SEL</name>
                <description>EP8 Interrupt level select</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_CAUSE_HI</name>
            <description>High priority interrupt Cause register</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF9F</resetMask>
            <fields>
              <field>
                <name>SOF_INTR</name>
                <description>USB SOF Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BUS_RESET_INTR</name>
                <description>BUS RESET Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP0_INTR</name>
                <description>EP0 Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LPM_INTR</name>
                <description>LPM Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RESUME_INTR</name>
                <description>Resume Interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ARB_EP_INTR</name>
                <description>Arbiter Endpoint Interrupt</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP1_INTR</name>
                <description>EP1 Interrupt</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2_INTR</name>
                <description>EP2 Interrupt</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP3_INTR</name>
                <description>EP3 Interrupt</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP4_INTR</name>
                <description>EP4 Interrupt</description>
                <bitRange>[11:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP5_INTR</name>
                <description>EP5 Interrupt</description>
                <bitRange>[12:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP6_INTR</name>
                <description>EP6 Interrupt</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP7_INTR</name>
                <description>EP7 Interrupt</description>
                <bitRange>[14:14]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP8_INTR</name>
                <description>EP8 Interrupt</description>
                <bitRange>[15:15]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_CAUSE_MED</name>
            <description>Medium priority interrupt Cause register</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF9F</resetMask>
            <fields>
              <field>
                <name>SOF_INTR</name>
                <description>USB SOF Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BUS_RESET_INTR</name>
                <description>BUS RESET Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP0_INTR</name>
                <description>EP0 Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LPM_INTR</name>
                <description>LPM Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RESUME_INTR</name>
                <description>Resume Interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ARB_EP_INTR</name>
                <description>Arbiter Endpoint Interrupt</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP1_INTR</name>
                <description>EP1 Interrupt</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2_INTR</name>
                <description>EP2 Interrupt</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP3_INTR</name>
                <description>EP3 Interrupt</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP4_INTR</name>
                <description>EP4 Interrupt</description>
                <bitRange>[11:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP5_INTR</name>
                <description>EP5 Interrupt</description>
                <bitRange>[12:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP6_INTR</name>
                <description>EP6 Interrupt</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP7_INTR</name>
                <description>EP7 Interrupt</description>
                <bitRange>[14:14]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP8_INTR</name>
                <description>EP8 Interrupt</description>
                <bitRange>[15:15]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_CAUSE_LO</name>
            <description>Low priority interrupt Cause register</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF9F</resetMask>
            <fields>
              <field>
                <name>SOF_INTR</name>
                <description>USB SOF Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BUS_RESET_INTR</name>
                <description>BUS RESET Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP0_INTR</name>
                <description>EP0 Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LPM_INTR</name>
                <description>LPM Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RESUME_INTR</name>
                <description>Resume Interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ARB_EP_INTR</name>
                <description>Arbiter Endpoint Interrupt</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP1_INTR</name>
                <description>EP1 Interrupt</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2_INTR</name>
                <description>EP2 Interrupt</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP3_INTR</name>
                <description>EP3 Interrupt</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP4_INTR</name>
                <description>EP4 Interrupt</description>
                <bitRange>[11:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP5_INTR</name>
                <description>EP5 Interrupt</description>
                <bitRange>[12:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP6_INTR</name>
                <description>EP6 Interrupt</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP7_INTR</name>
                <description>EP7 Interrupt</description>
                <bitRange>[14:14]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP8_INTR</name>
                <description>EP8 Interrupt</description>
                <bitRange>[15:15]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DFT_CTL</name>
            <description>DFT control</description>
            <addressOffset>0x70</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>DDFT_OUT_SEL</name>
                <description>DDFT output select signal</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OFF</name>
                    <description>Nothing connected, output 0</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DP_SE</name>
                    <description>Single Ended output of DP</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DM_SE</name>
                    <description>Single Ended output of DM</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TXOE</name>
                    <description>Output Enable</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RCV_DF</name>
                    <description>Differential Receiver output</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO_DP_OUT</name>
                    <description>GPIO output of DP</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO_DM_OUT</name>
                    <description>GPIO output of DM</description>
                    <value>6</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DDFT_IN_SEL</name>
                <description>DDFT input select signal</description>
                <bitRange>[4:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OFF</name>
                    <description>Nothing connected, output 0</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO_DP_IN</name>
                    <description>GPIO input of DP</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO_DM_IN</name>
                    <description>GPIO input of DM</description>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>USBHOST</name>
          <description>USB Host Controller</description>
          <addressOffset>0x00004000</addressOffset>
          <register>
            <name>HOST_CTL0</name>
            <description>Host Control 0 Register.</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000001</resetMask>
            <fields>
              <field>
                <name>HOST</name>
                <description>This bit selects an operating mode of this IP.
'0' : USB Device
'1' : USB Host
Notes:
- The mode of operation mode does not transition immediately after setting this bit.  Read this bit to confirm that the operation mode has changed.
- This bit is reset to '0' if the ENABLE bit in this register changes from '1' to '0'.
- Before changing from the USB Host to the USB Device, check that the following conditions are satisfied and also set the RST bit of the Host Control 1 Register (HOST_CTL1). to '1'.
     * The SOFBUSY bit of the Host Status Register (HOST_STATUS) is set to '0'.
     * The TKNEN bits of the Host Token Endpoint Register (HOST_TOKEN) is set to '000'.
     * The SUSP bit of the Host Status Register (HOST_STATUS) is set to '0'.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>This bit enables the operation of this IP.
'0' : Disable USB Host
'1' : Enable USB Host
Note:
- This bit doesn't affect the USB Device.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_CTL1</name>
            <description>Host Control 1 Register.</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x83</resetValue>
            <resetMask>0x83</resetMask>
            <fields>
              <field>
                <name>CLKSEL</name>
                <description>This bit selects the operating clock of USB Host.
'0' : Low-speed clock
'1' : Full-speed clock
Notes:
- This bit is set to it's default vaulue '1' if the ENABLE bit of the Host Control 0 Register (HOST_CTL0) changes from '1' to '0'.
- This bit must always be set to '1' in the USB Device mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>USTP</name>
                <description>This bit stops the clock for the USB Host operating unit. When this bit is '1', power consumption can be reduced by configuring this bit.
'0' : Normal operating mode.
'1' : Stops the clock for the USB Host operating unit.
Notes:
- If this bit is set to '1', the function of USB Host can't be used because internal clock is stopped.
- This bit is initialized if ENABLE bit of the Host Control 0 Register (HOST_CTL0) changes from '1' to '0'.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RST</name>
                <description>This bit resets the USB Host.
'0' : Normal operating mode.
'1' : USB Host is reset.
Notes:
- This bit is to it's default value '1' if  the ENABLE bit of the Host Control 0 Register (HOST_CTL0) changes from '1' to '0'.
- If this bit is set to '1', both the BFINI bits of the Host Endpoint 1 Control Register (HOST_EP1_CTL) and Host Endpoint 2 Control Register (HOST_EP2_CTL) are set to '1'.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_CTL2</name>
            <description>Host Control 2 Register.</description>
            <addressOffset>0x100</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RETRY</name>
                <description>If this bit is set to '1', the target token is retried if a NAK or error* occurs. Retry processing is performed after the time that is specified in the Host Retry Timer Setup Register (HOST_RTIMER).
* : HOST_ERR.RERR='1', HOST_ERR.TOUT='1', HOST_ERR.CRC='1', HOST_ERR.TGERR='1', HOST_ERR.STUFF='1'
'0' : Doesn't retry token sending.
'1' : Retries token sending
Note:
- This bit isn't initialized even if the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CANCEL</name>
                <description>When this bit is set to '1', if the target token is written to the Host Token Endpoint Register (HOST_TOKEN) in the EOF area (specified in the Host EOF Setup Register), its sending is canceled. When this bit is set to '0', token sending is not canceled even if the target token is written to the register. The cancellation of token sending is detected by reading the TCAN bit of the Interrupt USB Host Register (INTR_USBHOST).
'0' : Continues a token.
'1' : Cancels a token.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SOFSTEP</name>
                <description>If this bit is set to '1', the SOF interrupt flag (INTR_USBHOST.SOFIRQ) is set to '1' each time SOF is sent.
If this bit is set to '0', the set value of the Host SOF Interrupt Frame Compare Register (HOST_FCOMP) is compared with the low-order eight bits of the SOF frame number. If they match, the SOF interrupt flag (INTR_USBHOST.SOFIRQ) is set to '1'.
'0' : An interrupt occurred due to the HOST_HFCOMP setting.
'1' : An interrupt occurred.
Notes:
- If a SOF token (TKNEN='001') is sent by the setting of the Host Token Endpoint Register (HOST_TOKEN), the SOF interrupt flag (INTR_USBHOST.SOFIRQ) is not set to '1' regardless of the setting of this bit.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ALIVE</name>
                <description>This bit is used to specify the keep-alive function in the low-speed mode. If this bit it set to '1' while the CLKSEL bit of the Host Control 1 Register (HOST_CTL1) is '0', SE0 is output instead of SOF. This bit is only effective when the CLKSEL bit is '0'. If the CLKSEL bit is '1' (Full-Speed mode), SOF is output regardless of the setting of the ALIVE bit. 
'0' : SOF output.
'1' : SE0 output (Keep alive)</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_4</name>
                <description>N/A</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_5</name>
                <description>N/A</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TTEST</name>
                <description>N/A</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_ERR</name>
            <description>Host Error Status Register.</description>
            <addressOffset>0x104</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>HS</name>
                <description>These flags indicate the status of a handshake packet to be sent or received.
These flags are set to 'NULL' when no handshake occurs due to an error or when a SOF token has been ended with the TKNEN bit of the Host Token Endpoint Register (HOST_TOKEN).
These bits are updated when sending or receiving has been ended. 
Write '11' to set the status back to 'NULL', all other write values are ignored. 
Note:
This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACK</name>
                    <description>Acknowledge Packet</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK</name>
                    <description>Non-Acknowledge Packet</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL</name>
                    <description>Stall Packet</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NULL</name>
                    <description>Null Packet</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STUFF</name>
                <description>If this bit is set to '1', it means that a bit stuffing error has been detected. When this bit is '0', it means that no error is detected. If a stuffing error is detected, bit5 (TOUT) of this register is also set to '1'.  Write '1' to clear, a write of '0' is ignored.
'0' : No stuffing error.
'1' : Stuffing error detected.
Note:
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TGERR</name>
                <description>If this bit is set to '1', it means that the data does not match the TGGL data. When this bit is '0', it means that no error is detected. Write '1' to clear, a write of '0' is ignored.
'0' : No toggle error.
'1' : Toggle error detected.
Note:
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC</name>
                <description>If this bit is set to '1', it means that a CRC error is detected in the USB Host. When this bit is '0', it means that no error is detected. If a CRC error is detected, bit5 (TOUT) of this register is also set to '1'.  Write '1' to clear, a write of '0' is ignored.
'0' : No CRC error.
'1' : CRC error detected.
Note:
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TOUT</name>
                <description>If this bit is set to '1', it means that no response is returned from the device within the specified time after a token has been sent in the USB Host. When this bit is '0', it means that no timeout is detected.  Write '1' to clear, a write of '0' is ignored.
'0' : No timeout.
'1' : Timeout has detected.
Note:
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RERR</name>
                <description>When this bit is set to '1', it means that the received data exceeds the specified maximum number of packets in the USB Host. If a receive error is detected, bit5 (TOUT) of this register is also set to '1'. When this bit is '0', it means that no error is detected. Write '1' to clear, a write of '0' is ignored.
'0' : No receive error.
'1' : Maximum packet receive error detected.
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LSTSOF</name>
                <description>If this bit is set to '1', it means that the SOF token can't be sent in the USB Host because other token is in process. When this bit is '0', it means that SOF token was sent with no error. Write '1' to clear, a write of '0' is ignored.
'0' : SOF sent without error.
'1' : SOF error detected.
Note:
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_STATUS</name>
            <description>Host Status Register.</description>
            <addressOffset>0x108</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xC2</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>CSTAT</name>
                <description>When this bit is '1', it means that the device is connected. When this bit is '0', it means that the device is disconnected.
'0' : Device is disconnected.
'1' : Device is connected.
Notes:
- This bit is set to the default value if the RST bit of the Host Control 1 Register (Host_CTL1) is set to '1'.
- The transition to disconnected on RST isn't immediate.  Read this bit to confirm the transition is complete.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TMODE</name>
                <description>If this bit is '1', it means that the device is connected in the full-speed mode. When this bit is '0', it means that the device is connected in the low-speed mode. This bit is valid when the CSTAT bit of the Host Status Register (HOST_STATUS) is '1'.
'0' : Low-speed.
'1' : Full-speed.
Notes:
- This bit is set to the default value if the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'. 
- The transition to disconnected on RST isn't immediate.  Read this bit to confirm the transition is complete.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SUSP</name>
                <description>If this bit is set to '1', the USB Host is placed into the suspend state. If this bit is set to '0' while it is '1' or the USB bus is placed into the k-state mode, then suspend state is released, and the RWIRQ bit of the Interrupt USB Host Register (INTR_USBHOST) is set to '1'.
Set to '1' : Suspend.
Set '0' when this bit is '1' : Resume.
Other conditions : Holds the status.
Notes:
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.
- The transition to disconnected on RST isn't immediate.  Read this bit to confirm the transition is complete.
- If this bit is set to '1', this bit must not be set to '1' until the RWIRQ bit of the Interrupt USB Host Register (INTR_USBHOST) is set to '1'.
- Do not set this bit to '1' while the USB is active (during USB bus resetting, data transfer, or SOF timer running).
- If the value of this bit is changed, it is not immediately reflected on the state of the USB bus. To check whether or not the state is updated, read this bit.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SOFBUSY</name>
                <description>When a SOF token is sent using the Host Token Endpoint Register (HOST_TOKEN), this bit is set to '1', which means that the SOF timer is active. When this bit is '0', it means that the SOF timer is under suspension. To stop the active SOF timer, write '0' to this bit. However, if this bit is written with '1', its value is ignored. 
'0' : The SOF timer is stopped.
'1' : The SOF timer is active.
Notes:
- This bit is set to the initial value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.
- This bit takes time to be initialized by the RST bit of the Host Control 1 Resgiter (HOST_CTL1).
- The SOF timer does not stop immediately after this bit has been set to '0' to stop the SOF timer. To check whether or not the SOF timer is stopped, read this bit.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>URST</name>
                <description>When this bit is set to '1', the USB bus is reset. This bit remains a '1' during USB bus resetting, and changes to '0' when USB bus resetting is ended. If this bit is set to '0', the USB bus reset is complete</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_5</name>
                <description>N/A</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RSTBUSY</name>
                <description>This bit shows that USB Host is being reset internally. If the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1', this bit is set to '1'.
If the RST bit of Host Control 1 Register (HOST_CTL1) is set to '0', this bit is set to '0'.
'0' : USB Host isn't being reset.
'1' : USB Host is being reset.
Notes:
- If this bit is '1', the a token must not be executed.
- This bit isn't set to '0' or '1' immediately even if the RST bit of Host Control 1 Register (HOST_CTL1) is set to '0' or '1'. Read this bit to confirm the operation is complete.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CLKSEL_ST</name>
                <description>This bit shows whether it is full-speed or not. If the CLKSEL bit of the Host Control 1 Register (HOST_CTL1) is set to '1', this bit is set to '1'.
'0' : Low speed
'1' : Full speed
Note:
- If this bit is different from the CLKSEL bit, The execution of the token and bus reset must wait these bits match.
- This bit takes time to be initialized by the RST bit of the Host Control 1 Resgiter (HOST_CTL1). Read this bit to confirm the operation is complete.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HOST_ST</name>
                <description>This bit shows whether the device is in USB Host mode. If the HOST bit of the Host Control Register (HOST_CTL0) is set to '1', this bit is set to '1'.
'0' : USB Device
'1' : USB Host
Notes:
- If this bit is different from the HOST bit, The execution of a token must wait these bits match.
- This bit takes time to be initialized by the RST bit of the Host Control 1 Resgiter (HOST_CTL1). Read this bit to confirm the operation is complete.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_FCOMP</name>
            <description>Host SOF Interrupt Frame Compare Register</description>
            <addressOffset>0x10C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>FRAMECOMP</name>
                <description>These bits are used to specify the data to be compared with the low-order eight bits of a frame number when sending a SOF token.
If the SOFSTEP bit of Host Control 2 Register (HOST_CTL2) is '0', the frame number of SOF is compared with the value of this register when sending a SOF token. If they match, the SOFIRQ bit of the Interrupt USB Host Register (INTR_USBHOST) is set to '1'.
The setting of this register is invalid when the SOFSTEP bit of Host Control 2 Register (HOST_CTL2) is '1'.
Note:
- This bit is not reset to default even if the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_RTIMER</name>
            <description>Host Retry Timer Setup Register</description>
            <addressOffset>0x110</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3FFFF</resetMask>
            <fields>
              <field>
                <name>RTIMER</name>
                <description>These bits are used to specify the retry time in this register. The retry timer is activated when token sending starts while the RETRY bit of Host Control 2 Register (HOST_CTL2) is '1'. The retry time is then decremented by one when a 1-bit transfer clock (12 MHz in the full-speed mode) is output. When the retry timer reaches 0, the target token is sent, and processing ends.
If a token retry occurs in the EOF area, the retry timer is stopped until SOF sending is ended. After SOF sending has been completed, the retry timer restarts with the value that is set when the timer stopped.</description>
                <bitRange>[17:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_ADDR</name>
            <description>Host Address Register</description>
            <addressOffset>0x114</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7F</resetMask>
            <fields>
              <field>
                <name>ADDRESS</name>
                <description>These bits are used to specify a token address.
Note:
- This bit is reset to default even if the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EOF</name>
            <description>Host EOF Setup Register</description>
            <addressOffset>0x118</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3FFF</resetMask>
            <fields>
              <field>
                <name>EOF</name>
                <description>These bits are used to specify the time to disable token sending before transferring SOF. Specify the time with a margin, which is longer than the one-packet length. The time unit is the 1-bit transfer time.
Setting example: MAXPKT = 64 bytes, full-speed mode
 (Token_length + packet_length + header + CRC)*7/6 + Turn_around_time
  =(34 bit + 546 bit)*7/6 + 36 bit = 712.7 bit
 Therefore, set 0x2C9.
Note:
- This bit is not reset to default even if the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[13:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_FRAME</name>
            <description>Host Frame Setup Register</description>
            <addressOffset>0x11C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FF</resetMask>
            <fields>
              <field>
                <name>FRAME</name>
                <description>These bits are used to specify a frame number of SOF.
Notes:
- This bit isn't reset to default even if the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.
- Specify a frame number in this register before setting SOF in the TKNEN bit of the Host Token Endpoint Register (HOST_TOKEN).
- This register cannot be written while the SOFBUSY bit of the Host Status Register (HOST_STATUS) is '1' and a SOF token is in process.</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_TOKEN</name>
            <description>Host Token Endpoint Register</description>
            <addressOffset>0x120</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x17F</resetMask>
            <fields>
              <field>
                <name>ENDPT</name>
                <description>These bits are used to specify an endpoint to send or receive data to or from the device.
Note:
- This bit isn't reset to default even if the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TKNEN</name>
                <description>These bits send a token according to the current settings. After operation is complete, the TKNEN bit is set to '000', and the CMPIRQ bit of the Interrupt USB Host Register (INTR_USBHOST) is set to '1'.
The settings of the TGGL and ENDPT bits are ignored when sending a SOF token.
Notes:
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.
- The PRE packet isn't supported.
- Do not set '100' to the TKNEN bit when the SOFBUSY bit of the Host Status Register (HOST_STATUS) is '1'
- Mode should be USB Host before writing data to this bit.
- When issuing a token again after the token interrupt flag (CMPIRQ) has been set to '1', wait for 3 cycles or more after a USB transfer clock (12 MHz in the full-speed mode, 1.5 MHz in the low-speed mode) was output, then write data to this bit.
- Read the value of TKNEN bit if a new value is written in it .Continue writing in this bit until a retrieved value equals a new value written in. During this checking process, it is needed to prevent any interrupt.
- Take the following steps when CMPIRQ bit of Interrupt USB Host Register (INTR_USBHOST) is set to '1' by finishing IN token or Isochronous IN token.
1. Read HS bit of Host Error Status Register (HOST_ERR), then set CMPIRQ bit to '0'.
2. Set EPn bit of Host DMA Enable Register (HOST_DMA_ENBL) (n=1 or 2) to '1' if HS bit of Host Error Status Register (HOST_ERR) is equal to '00' and wait until EPn bit of Host DMA Data Request Register (HOST_DMA_DREQ) changes to '1'. Finish the IN token processing if HS bit is not equal to '00'.
3. Read the received data if EPn bit of Host DMA Data Requet (HOST_DMA_DREQ) (n=1 or 2) changes to '1'.</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NONE</name>
                    <description>Sends no data.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SETUP</name>
                    <description>Sends SETUP token.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>IN</name>
                    <description>Sends IN token.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OUT</name>
                    <description>Sends OUT token.</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SOF</name>
                    <description>Sends SOF token.</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>Sends Isochronous IN.</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>Sends Isochronous OUT.</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSV</name>
                    <description>N/A</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TGGL</name>
                <description>This bit is used to set toggle data. Toggle data is sent depending on the setting of this bit. When receiving toggle data, received toggle data is compared with the toggle data of this bit to verify whether or not an error occurs.
'0' : DATA0
'1' : DATA1
Notes:
- This bit isn't reset to the default value even if the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.
- Set this bit when the TKNEN bit of the Host Token Endpoint Register (HOST_TOKEN) is '000'.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP1_CTL</name>
            <description>Host Endpoint 1 Control Register</description>
            <addressOffset>0x400</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x8100</resetValue>
            <resetMask>0x9DFF</resetMask>
            <fields>
              <field>
                <name>PKS1</name>
                <description>This bit specifies the maximum size transferred by one packet. The configurable range is from 0x001 to 0x100.
- If automatic buffer transfer mode (DMAE='1') is used, Endpoint 0,1, or 2 cannot be used,</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NULLE</name>
                <description>When a data transfer request in OUT the direction is transmitted while automatic buffer transfer mode is set (DMAE = 1), this bit sets a mode that transfers 0-byte data automatically upon the detection of the last packet transfer.
'0' : Releases the NULL automatic transfer mode.
'1' : Sets the NULL automatic transfer mode.
Note :
- For data transfer in the IN direction or when automatic buffer transfer mode is not set, the NULL bit configuration does not affect communication.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMAE</name>
                <description>This bit sets a mode that uses DMA for writing or reading transfer data to/from send/receive buffer, and automatically transfers the send/receive data synchronized with an data request in the IN or OUT direction. Until the data size set in the DMA is reached, the data is transferred.
'0' : Releases the packet transfer mode.
'1' : Sets the packet transfer mode.
Note :
- The CPU must not access the send/receive buffer while the DMAE bit is set to '1'. For data transfer in the IN direction, set the DMA transfer size to the multiples of that set in PKS1 bits of the Host EP1 Control Register (HOST_EP1_CTL) and Host EP2 Control Register (HOST_EP2_CTR).</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIR</name>
                <description>This bit specifies the transfer direction the Endpoint support.
'0' : IN Endpoint.
'1' : OUT Endpoint
Note:
- This bit must be changed when INI_ST bit of the Host Endpoint 1 Status Register (HOST_EP1_STATUS) is '1'.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BFINI</name>
                <description>This bit initializes the send/receive buffer of transfer data. The BFINI bit is also automatically set by setting the RST bit of the HOST Control 1 Register (HOST_CTL1). If the RST bit was used for resetting, therefore, set the RST bit to '0' before clearing the BFINI bit.
'0' : Clears the initialization.
'1' : Initializes the send/receive buffer
Note :
- The EP1 buffer has a double-buffer configuration. The BFINI bit initialization initializes the double buffers concurrently and also initializes the EP1DRQ and EP1SPK bits.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP1_STATUS</name>
            <description>Host Endpoint 1 Status Register</description>
            <addressOffset>0x404</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x60000</resetValue>
            <resetMask>0x70000</resetMask>
            <fields>
              <field>
                <name>SIZE1</name>
                <description>These bits indicate the number of data bytes written to the receive buffer when IN packet transfer of EP1 has finished.
The indication range is from 0x000 to 0x100.
Note :
- These bits are set to the data size transferred in the IN direction and written to the buffer. Therefore, a value read during transfer in the OUT direction has no effect.</description>
                <bitRange>[8:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VAL_DATA</name>
                <description>This bit shows that there is valid data in the EP1 buffer.
'0' : Invalid data in the buffer
'1' : Valid data in the buffer</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INI_ST</name>
                <description>This bit shows that EP1 is initialized. If the init bit of the Host Endpoint 1 Control Register (HOST_EP1_CTL) is set to '1' and EP1 is initialized, this bit is to '1'.
'0' : Not initiatialized
'1' : Initialized
Note:
- This bit isn't set to '0' or '1' immediately even if BFINI bit of the Host Endpoint 1 Control Register (HOST_EP1_CTL) is set to '0' or '1'.  Read this bit to confirm the transition.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RSVD_18</name>
                <description>N/A</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP1_RW1_DR</name>
            <description>Host Endpoint 1 Data 1-Byte Register</description>
            <addressOffset>0x408</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>BFDT8</name>
                <description>Data Register for EP1 for 1-byte data</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP1_RW2_DR</name>
            <description>Host Endpoint 1 Data 2-Byte Register</description>
            <addressOffset>0x40C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>BFDT16</name>
                <description>Data Register for EP1 for 2-byte data</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP2_CTL</name>
            <description>Host Endpoint 2 Control Register</description>
            <addressOffset>0x500</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x8040</resetValue>
            <resetMask>0x9C7F</resetMask>
            <fields>
              <field>
                <name>PKS2</name>
                <description>This bit specifies the maximum size transferred by one packet. The configurable range is from 0x001 to 0x40.
- If automatic buffer transfer mode (DMAE='1') is used, this Endpoint must not set from 0 to 2.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NULLE</name>
                <description>When a data transfer request in the OUT direction transmitted while packet transfer mode is set (DMAE = 1), this bit sets a mode that transfers 0-byte data automatically upon the detection of the last packet transfer.
'0' : Releases the NULL automatic transfer mode.
'1' : Sets the NULL automatic transfer mode.
Note :
- For data transfer in the IN direction or when automatic buffer transfer mode is not set, the NULL bit configuration does not affect communication.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMAE</name>
                <description>This bit sets a mode that uses DMA for writing or reading transfer data to/from send/receive buffer, and automatically transfers the send/receive data synchronized with an data request in the IN or OUT direction. Until the data size set in the DMA is reached, the data is transferred.
'0' : Releases the automatic buffer transfer mode.
'1' : Sets the automatic buffer transfer mode.
Note :
- The CPU must not access the send/receive buffer while the DMAE bit is set to '1'. For data transfer in the IN direction, set the DMA transfer size to the multiples of that set in PKS bits of the Host EP1 Control Register (HOST_EP1_CTL) and Host EP2 Control Register (HOST_EP2_CTR).</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIR</name>
                <description>This bit specifies the transfer direction the Endpoint support.
'0' : IN Endpoint.
'1' : OUT Endpoint
Note:
- This bit must be changed when INI_ST bit of the Host Endpoint 2 Status Register (HOST_EP2_STATUS) is '1'.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BFINI</name>
                <description>This bit initializes the send/receive buffer of transfer data. The BFINI bit is also automatically set by setting the RST bit of the HOST Control 1 Register (HOST_CTL1). If the RST bit was used for resetting, therefore, set the RST bit to '0' before clearing the BFINI bit.
'0' : Clears the initialization.
'1' : Initializes the send/receive buffer
Note :
- The EP2 buffer has a double-buffer configuration. The BFINI bit initialization initializes the double buffers concurrently and also initializes the EP2DRQ and EP2SPK bits.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP2_STATUS</name>
            <description>Host Endpoint 2 Status Register</description>
            <addressOffset>0x504</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x60000</resetValue>
            <resetMask>0x70000</resetMask>
            <fields>
              <field>
                <name>SIZE2</name>
                <description>These bits indicate the number of data bytes written to the receive buffer when IN packet transfer of EP2 has finished.
The indication range is from 0x000 to 0x40.
Note :
- These bits are set to the data size transferred in the IN direction and written to the buffer. Therefore, a value read during transfer in the OUT direction has no effect.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VAL_DATA</name>
                <description>This bit shows that there is valid data in the EP2 buffer.
'0' : Invalid data in the buffer
'1' : Valid data in the buffer</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INI_ST</name>
                <description>This bit shows that EP2 is initialized. If the BFINI bit of the Host Endpoint 2 Control Register (HOST_EP2_CTL) is set to '1' and EP2 is initialized, this bit is to '1'.
'0' : Not Initialized
'1' : Initialized
Note:
- This bit isn't set to '0' or '1' immediately evne if BFINI bit of the Host Endpoint 2 Control Register (HOST_EP2_CTL) is set to '0' or '1'.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RSVD_18</name>
                <description>N/A</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP2_RW1_DR</name>
            <description>Host Endpoint 2 Data 1-Byte Register</description>
            <addressOffset>0x508</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>BFDT8</name>
                <description>Data Register for EP2 for 1-byte data.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP2_RW2_DR</name>
            <description>Host Endpoint 2 Data 2-Byte Register</description>
            <addressOffset>0x50C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>BFDT16</name>
                <description>Data Register for EP2 for 2 byte data.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_LVL1_SEL</name>
            <description>Host Interrupt Level 1 Selection Register</description>
            <addressOffset>0x800</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>SOFIRQ_SEL</name>
                <description>These bits assign SOFIRQ interrupt flag to selected interrupt signals.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>HI</name>
                    <description>High priority interrupt</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MED</name>
                    <description>Medium priority interrupt</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LO</name>
                    <description>Low priority interrupt</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DIRQ_SEL</name>
                <description>These bits assign DIRQ interrupt flag to selected interrupt signals.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CNNIRQ_SEL</name>
                <description>These bits assign CNNIRQ interrupt flag to selected interrupt signals.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMPIRQ_SEL</name>
                <description>These bits assign URIRQ interrupt flag to selected interrupt signals.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>URIRQ_SEL</name>
                <description>These bits assign URIRQ interrupt flag to selected interrupt signals.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RWKIRQ_SEL</name>
                <description>These bits assign RWKIRQ interrupt flag to selected interrupt signals.</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_13_12</name>
                <description>N/A</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TCAN_SEL</name>
                <description>These bits assign TCAN interrupt flag to selected interrupt signals.</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_LVL2_SEL</name>
            <description>Host Interrupt Level 2 Selection Register</description>
            <addressOffset>0x804</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF0</resetMask>
            <fields>
              <field>
                <name>EP1_DRQ_SEL</name>
                <description>These bits assign EP1_DRQ interrupt flag to selected interrupt signals.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>HI</name>
                    <description>High priority interrupt</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MED</name>
                    <description>Medium priority interrupt</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LO</name>
                    <description>Low priority interrupt</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP1_SPK_SEL</name>
                <description>These bits assign EP1_SPK interrupt flag to selected interrupt signals.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2_DRQ_SEL</name>
                <description>These bits assign EP2_DRQ interrupt flag to selected interrupt signals.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2_SPK_SEL</name>
                <description>These bits assign EP2_SPK interrupt flag to selected interrupt signals.</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_USBHOST_CAUSE_HI</name>
            <description>Interrupt USB Host Cause High Register</description>
            <addressOffset>0x900</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>SOFIRQ_INT</name>
                <description>SOFIRQ interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DIRQ_INT</name>
                <description>DIRQ interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CNNIRQ_INT</name>
                <description>CNNIRQ interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CMPIRQ_INT</name>
                <description>CMPIRQ interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>URIRQ_INT</name>
                <description>URIRQ interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RWKIRQ_INT</name>
                <description>RWKIRQ interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RSVD_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TCAN_INT</name>
                <description>TCAN interrupt</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_USBHOST_CAUSE_MED</name>
            <description>Interrupt USB Host Cause Medium Register</description>
            <addressOffset>0x904</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>SOFIRQ_INT</name>
                <description>SOFIRQ interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DIRQ_INT</name>
                <description>DIRQ interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CNNIRQ_INT</name>
                <description>CNNIRQ interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CMPIRQ_INT</name>
                <description>CMPIRQ interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>URIRQ_INT</name>
                <description>URIRQ interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RWKIRQ_INT</name>
                <description>RWKIRQ interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RSVD_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TCAN_INT</name>
                <description>TCAN interrupt</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_USBHOST_CAUSE_LO</name>
            <description>Interrupt USB Host Cause Low Register</description>
            <addressOffset>0x908</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>SOFIRQ_INT</name>
                <description>SOFIRQ interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DIRQ_INT</name>
                <description>DIRQ interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CNNIRQ_INT</name>
                <description>CNNIRQ interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CMPIRQ_INT</name>
                <description>CMPIRQ interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>URIRQ_INT</name>
                <description>URIRQ interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RWKIRQ_INT</name>
                <description>RWKIRQ interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RSVD_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TCAN_INT</name>
                <description>TCAN interrupt</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_HOST_EP_CAUSE_HI</name>
            <description>Interrupt USB Host Endpoint Cause High Register</description>
            <addressOffset>0x920</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3C</resetMask>
            <fields>
              <field>
                <name>EP1DRQ_INT</name>
                <description>EP1DRQ interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP1SPK_INT</name>
                <description>EP1SPK interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2DRQ_INT</name>
                <description>EP2DRQ interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2SPK_INT</name>
                <description>EP2SPK interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_HOST_EP_CAUSE_MED</name>
            <description>Interrupt USB Host Endpoint Cause Medium Register</description>
            <addressOffset>0x924</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3C</resetMask>
            <fields>
              <field>
                <name>EP1DRQ_INT</name>
                <description>EP1DRQ interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP1SPK_INT</name>
                <description>EP1SPK interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2DRQ_INT</name>
                <description>EP2DRQ interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2SPK_INT</name>
                <description>EP2SPK interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_HOST_EP_CAUSE_LO</name>
            <description>Interrupt USB Host Endpoint Cause Low Register</description>
            <addressOffset>0x928</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3C</resetMask>
            <fields>
              <field>
                <name>EP1DRQ_INT</name>
                <description>EP1DRQ interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP1SPK_INT</name>
                <description>EP1SPK interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2DRQ_INT</name>
                <description>EP2DRQ interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2SPK_INT</name>
                <description>EP2SPK interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_USBHOST</name>
            <description>Interrupt USB Host Register</description>
            <addressOffset>0x940</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>SOFIRQ</name>
                <description>If this bit is set to '1', it means that SOF token sending is started. When this bit is '0', it has no meaning. Write '1' to clear, a write of '0' is ignored.
'0' : Does not issue an interrupt request by starting a SOF token.
'1' : Issues an interrupt request by starting a SOF token.
Note :
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIRQ</name>
                <description>If this bit is set to '1', it means that a device disconnection is detected. When this bit is '0', it has no meaning. Write '1' to clear, a write of '0' is ignored.
'0' : Issues no interrupt request by detecting a device disconnection.
'1' : Issues an interrupt request by detecting a device disconnection.
Note :
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CNNIRQ</name>
                <description>If this bit is set to '1', it means that a device connection is detected. When this bit is '0', it has no meaning. Write '1' to clear, a write of '0' is ignored.
'0' : Issues no interrupt request by detecting a device connection.
'1' : Issues an interrupt request by detecting a device connection.
Note :
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMPIRQ</name>
                <description>If this bit is set to '1', it means that a token is completed. When this bit is '0', it has no meaning. Write '1' to clear, a write of '0' is ignored.
'0' : Issues no interrupt request by token completion.
'1' : Issues an interrupt request by token completion.
Note :
- This bit is set to the initial value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.
- This bit is not set to '1' even if the TCAN bit of the Interrupt USBHost Register (INTR_USBHOST) changes to '1'.
- Take the following steps when this bit is set to '1' by finishing IN token or Isochronous IN token.
1. Read HS bit of Host Error Status Register (HOST_ERR), then set CMPIRQ bit to '0'.
2. Set EPn bit of Host DMA Enable Register (HOST_DMA_ENBL) (n=1 or 2) to '1' if HS bit of Host Error Status Register (HOST_ERR) is equal to '00' and wait until EPn bit of Host DMA Data Request Register (HOST_DMA_DREQ) changes to '1'. Finish the IN token processing if HS bit is not equal to '00'.
3. Read the received data if EPn bit of Host DMA Data Requet (HOST_DMA_DREQ) (n=1 or 2) changes to '1'.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>URIRQ</name>
                <description>If this bit is set to '1', it means that USB bus resetting is ended. When this bit is '0', it has no meaning. If this bit is written with '1', it is set to '0'. However, if this bit is written with '0', its value is ignored.
'0' : Issues no interrupt request by USB bus resetting.
'1' : Issues an interrupt request by USB bus resetting.
Note :
- This bit is set to the initial value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RWKIRQ</name>
                <description>If this bit is set to '1', it means that remote Wake-up is ended. When this bit is '0', it has no meaning. Write '1' to clear, a write of '0' is ignored.
'0' : Issues no interrupt request by restart.
'1' : Issues an interrupt request by restart.
Note :
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TCAN</name>
                <description>If this bit is set to '1', it means that token sending is canceled based on the setting of the CANCEL bit of Host Control 2 Register (HOST_CTL2). When this bit is '0', it means that token sending is not canceled. Write '1' to clear, a write of '0' is ignored.
'0' : Does not cancel token sending.
'1' : Cancels token sending.
Note :
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_USBHOST_SET</name>
            <description>Interrupt USB Host Set Register</description>
            <addressOffset>0x944</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>SOFIRQS</name>
                <description>This bit sets SOFIRQ bit. If this bit is written to '1', SOFIRQ is set to '1'. However, if this bit is written with '0', its value is ignored.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIRQS</name>
                <description>This bit sets DIRQ bit. If this bit is written to '1', DIRQ is set to '1'. However, if this bit is written with '0', its value is ignored.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CNNIRQS</name>
                <description>This bit sets CNNIRQ bit. If this bit is written to '1', CNNIRQ is set to '1'. However, if this bit is written with '0', its value is ignored.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMPIRQS</name>
                <description>This bit sets CMPIRQ bit. If this bit is written to '1', CMPIRQ is set to '1'. However, if this bit is written with '0', its value is ignored.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>URIRQS</name>
                <description>This bit sets URIRQ bit. If this bit is written to '1', URIRQ is set to '1'. However, if this bit is written with '0', its value is ignored.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RWKIRQS</name>
                <description>This bit sets RWKIRQ bit. If this bit is written to '1', RWKIRQ is set to '1'. However, if this bit is written with '0', its value is ignored.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TCANS</name>
                <description>This bit sets TCAN bit. If this bit is written to '1', TCAN is set to '1'. However, if this bit is written with '0', its value is ignored.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_USBHOST_MASK</name>
            <description>Interrupt USB Host Mask Register</description>
            <addressOffset>0x948</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>SOFIRQM</name>
                <description>This bit masks the interrupt by SOF flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIRQM</name>
                <description>This bit masks the interrupt by DIRQ flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CNNIRQM</name>
                <description>This bit masks the interrupt by CNNIRQ flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMPIRQM</name>
                <description>This bit masks the interrupt by CMPIRQ flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>URIRQM</name>
                <description>This bit masks the interrupt by URIRQ flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RWKIRQM</name>
                <description>This bit masks the interrupt by RWKIRQ flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TCANM</name>
                <description>This bit masks the interrupt by TCAN flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_USBHOST_MASKED</name>
            <description>Interrupt USB Host Masked Register</description>
            <addressOffset>0x94C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>SOFIRQED</name>
                <description>This bit indicates the interrupt by SOF flag.
'0' : Doesn't request the interrupt by SOF
'1' : Request the interrupt by SOF</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DIRQED</name>
                <description>This bit indicates the interrupt by DIRQ flag.
'0' : Doesn't request the interrupt by DIRQ
'1' : Request the interrupt by DIRQ</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CNNIRQED</name>
                <description>This bit indicates the interrupt by CNNIRQ flag.
'0' : Doesn't request the interrupt by CNNIRQ
'1' : Request the interrupt by CNNIRQ</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CMPIRQED</name>
                <description>This bit indicates the interrupt by CMPIRQ flag.
'0' : Doesn't request the interrupt by CMPIRQ
'1' : Request the interrupt by CMPIRQ</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>URIRQED</name>
                <description>This bit indicates the interrupt by URIRQ flag.
'0' : Doesn't request the interrupt by URIRQ
'1' : Request the interrupt by URIRQ</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RWKIRQED</name>
                <description>This bit indicates the interrupt by RWKIRQ flag.
'0' : Doesn't request the interrupt by RWKIRQ
'1' : Request the interrupt by RWKIRQ</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RSVD_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TCANED</name>
                <description>This bit indicates the interrupt by TCAN flag.
'0' : Doesn't request the interrupt by TCAN
'1' : Request the interrupt by TCAN</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_HOST_EP</name>
            <description>Interrupt USB Host Endpoint Register</description>
            <addressOffset>0xA00</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3C</resetMask>
            <fields>
              <field>
                <name>EP1DRQ</name>
                <description>This bit indicates that the EP1 packet transfer has normally ended, and processing of the data is required. The DRQ bit is an interrupt cause, and writing '0' is ignored. Clear the DRQ bit by writing '1'.
'0' : Clears the interrupt cause
'1' : Packet transfer normally ended
Note :
- If automatic buffer transfer mode (DMAE = '1') is not used, '1' must be written to the DRQ bit after data has been written or read to/from the send/receive buffer. Switch the access buffers once the DRQ bit is cleared. That DRQ = '0' may not be read after the DRQ bit is cleared. If the transfer direction is set to OUT, and the DRQ bit is cleared without writing buffer data while the DRQ bit is '1', it implies that 0-byte data is set. If DIR of the Host Endpoint 1 Control Register (HOST_EP1_CTL)  is set to '1' at initial settings, the DRQ bit of corresponding Endpoint is set at the same time. Also while the DRQ bit is not set, '1' must not be written.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP1SPK</name>
                <description>This bit indicates that the data size transferred from the host does not satisfy the maximum packet size (including 0-byte) set by PKS in the Host Endpoint 1 Control Register (HOST_EP1_CTL) when the data has been received successfully. This bit is an interrupt cause, and writing '0' is ignored. Clear it by writing '1'.
'0' : Received data size satisfies the maximum packet size
'1' : Received data size does not satisfy the maximum packet size
Note :
- The EP1SPK bit is not set during data transfer in the OUT direction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2DRQ</name>
                <description>This bit indicates that the EP2 packet transfer has normally ended, and processing of the data is required. The DRQ bit is an interrupt cause, and writing '0' is ignored. Clear the DRQ bit by writing '1'.
'0' : Clears the interrupt cause
'1' : Packet transfer normally ended
Note :
- If packet transfer mode (DMAE = '1') is not used, '1' must be written to the DRQ bit after data has been written or read to/from the send/receive buffer. Switch the access buffers once the DRQ bit is cleared. That DRQ = '0' may not be read after the DRQ bit is cleared. If the transfer direction is set to OUT, and the DRQ bit is cleared without writing buffer data while the DRQ bit is '1', it implies that 0-byte data is set. If DIR of the Host Endpoint 2 Control Register (HOST_EP2_CTL)  is set to '1' at initial settings, the DRQ bit of corresponding Endpoint is set at the same time. Also while the DRQ bit is not set, '1' must not be written.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2SPK</name>
                <description>This bit indicates that the data size transferred from the host does not satisfy the maximum packet size (including 0-byte) set by PKS1 in the Host Endpoint 2 Control Register (HOST_EP2_CTL) when the data has been received successfully. This bit is an interrupt cause, and writing '0' is ignored. Clear it by writing '1'.
'0' : Received data size satisfies the maximum packet size
'1' : Received data size does not satisfy the maximum packet size
Note :
- The SPK bit is not set during data transfer in the OUT direction.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_HOST_EP_SET</name>
            <description>Interrupt USB Host Endpoint Set Register</description>
            <addressOffset>0xA04</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3C</resetMask>
            <fields>
              <field>
                <name>EP1DRQS</name>
                <description>This bit sets EP1DRQ bit. If this bit is written to '1', EP1DRQ is set to '1'. However, if this bit is written with '0', its value is ignored.
Note:
If BFINI bit of the Host Endpoint 1 Control Register (HOST_EP1_CTL) is '1', EP1DRQ can't be set to '1'.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP1SPKS</name>
                <description>This bit sets EP1SPK bit. If this bit is written to '1', EP1SPK is set to '1'. However, if this bit is written with '0', its value is ignored.
Note:
If BFINI bit of the Host Endpoint 1 Control Register (HOST_EP1_CTL) is '1', EP1SPK can't be set to '1'.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2DRQS</name>
                <description>This bit sets EP2DRQ bit. If this bit is written to '1', EP2DRQ is set to '1'. However, if this bit is written with '0', its value is ignored.
Note:
If BFINI bit of the Host Endpoint 2 Control Register (HOST_EP2_CTL) is '1', EP2DRQ can't be set to '1'.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2SPKS</name>
                <description>This bit sets EP2SPK bit. If this bit is written to '1', EP2SPK is set to '1'. However, if this bit is written with '0', its value is ignored.
Note:
If BFINI bit of the Host Endpoint 2 Control Register (HOST_EP2_CTL) is '1', EP2SPK can't be set to '1'.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_HOST_EP_MASK</name>
            <description>Interrupt USB Host Endpoint Mask Register</description>
            <addressOffset>0xA08</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3C</resetMask>
            <fields>
              <field>
                <name>EP1DRQM</name>
                <description>This bit masks the interrupt by EP1DRQ flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP1SPKM</name>
                <description>This bit masks the interrupt by EP1SPK flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2DRQM</name>
                <description>This bit masks the interrupt by EP2DRQ flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2SPKM</name>
                <description>This bit masks the interrupt by EP2SPK flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_HOST_EP_MASKED</name>
            <description>Interrupt USB Host Endpoint Masked Register</description>
            <addressOffset>0xA0C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3C</resetMask>
            <fields>
              <field>
                <name>EP1DRQED</name>
                <description>This bit indicates the interrupt by EP1DRQ flag.
'0' : Doesn't request the interrupt by EP1DRQ
'1' : Request the interrupt by EP1DRQ</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP1SPKED</name>
                <description>This bit indicates the interrupt by EP1SPK flag.
'0' : Doesn't request the interrupt by EP1SPK
'1' : Request the interrupt by EP1SPK</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2DRQED</name>
                <description>This bit indicates the interrupt by EP2DRQ flag.
'0' : Doesn't request the interrupt by EP2DRQ
'1' : Request the interrupt by EP2DRQ</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2SPKED</name>
                <description>This bit indicates the interrupt by EP2SPK flag.
'0' : Doesn't request the interrupt by EP2SPK
'1' : Request the interrupt by EP2SPK</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_DMA_ENBL</name>
            <description>Host DMA Enable Register</description>
            <addressOffset>0xB00</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC</resetMask>
            <fields>
              <field>
                <name>DM_EP1DRQE</name>
                <description>This bit enables DMA Request by EP1DRQ.
'0' : Disable
'1' : Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM_EP2DRQE</name>
                <description>This bit enables DMA Request by EP2DRQ.
'0' : Disable
'1' : Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP1_BLK</name>
            <description>Host Endpoint 1 Block Register</description>
            <addressOffset>0xB20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF0000</resetMask>
            <fields>
              <field>
                <name>BLK_NUM</name>
                <description>Set the total byte number for DMA transfer. If HOST_EP1_RW1_DR or HOST_EP1_RW2_DR is written, the block number counter is decremented when DMAE='1'.
- Set this bits before DMA transfer is enabled (HOST_DMA_ENBL.DM_DP1DRQE='1')</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP2_BLK</name>
            <description>Host Endpoint 2 Block Register</description>
            <addressOffset>0xB30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF0000</resetMask>
            <fields>
              <field>
                <name>BLK_NUM</name>
                <description>Set the total byte number for DMA transfer. If HOST_EP2_RW1_DR or HOST_EP2_RW2_DR is written, the block number counter is decremented when DMAE='1'.
- Set this bits before DMA transfer is enabled (HOST_DMA_ENBL.DM_DP2DRQE='1')</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>MXS40USBHSDEV</name>
      <description>USB 2 Device Controller Memory Register Map</description>
      <baseAddress>0x40430000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>40960</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <name>USBHSDEV</name>
          <description>USB 2.0 Device Controller Registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>DEV_CS</name>
            <description>Device controller Master Control and Status</description>
            <addressOffset>0x9000</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x8000004</resetValue>
            <resetMask>0x8FFFFFFF</resetMask>
            <fields>
              <field>
                <name>ERR_LIMIT</name>
                <description>Error interrupt limit (COUNT &gt;= LIMIT will cause UIB_ERR_INTR.ERRLIMIT interrupt)</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COUNT</name>
                <description>Number of errors detected. To clear the error count write 0 to these bits</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DEVICEADDR</name>
                <description>During the USB enumeration process, the host sends a device a unique 7-bit address, which the USB core copies into this register. The USB Core will automatically respond only to its assigned address.  During the USB RESET, this register will be cleared to zero.</description>
                <bitRange>[22:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_MODE</name>
                <description>USB Test Mode
    000:  normal operation
    001:  Test_J
    010:  Test_K
    011:  Test_SE0_NAK
    100:  Test_Packet
[USB 2.0, Sec 7.1.20, p 169; Sec 9.4.9, Table 9-7, p 259]</description>
                <bitRange>[25:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SETUP_CLR_BUSY</name>
                <description>Allow device to ACK SETUP data/status phase packets</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONT_TO_DATA</name>
                <description>This bit controls waiting on SETUP_CLR_BUSY flag either during DATA or STATUS phase of a transaction.
0 - Waits for SETUP_CLR_BUSY flag to be cleared before starting DATA phase of a transaction.
1 - Continues to DATA phase of a transaction with SETUP_CLR_BUSY flag set. After DATA phase completion this bit must be cleared to wait on SETUP_CLR_BUSY flag in STATUS phase of a transaction for a status of NAK/ACK/STALL to be sent to USB Host.
The bit must be used during Control Write requests.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NAKALL</name>
                <description>Set '1' to this bit, the HW will NAK all transfers from the host in all endpoint1-31.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_FRAMECNT</name>
            <description>FRAMECNT register</description>
            <addressOffset>0x9004</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3FFF</resetMask>
            <fields>
              <field>
                <name>MICROFRAME</name>
                <description>MICROFRAME contains a count 0-7 which indicates which of the 8 125-microsecond micro-frames last occurred. This register is active only when Bay is operating at high speed (480 Mbits/sec).</description>
                <bitRange>[2:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FRAMECNT</name>
                <description>Every millisecond the host sends a SOF token indicating 'Start Of Frame,' along with an 11-bit incrementing frame count. The Bay copies the frame count into these registers at every SOF. One use of the frame count is to respond to the USB SYNC_FRAME Request. If the USB core detects a missing or garbled SOF, it generates an internal SOF and increments USBFRAMEL-USBRAMEH.</description>
                <bitRange>[13:3]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_PWR_CS</name>
            <description>Power management control and status</description>
            <addressOffset>0x9008</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x8</resetValue>
            <resetMask>0x7DD</resetMask>
            <fields>
              <field>
                <name>SIGRSUME</name>
                <description>Set SIGRSUME=1 to drive the 'K' state onto the USB bus for device-initiated resume from L1-sleep and L2-suspend low-power modes. The bit is set by firmware and cleared by hardware. The duration of resume is controlled by DEV_LPM_TIM_1 Register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NOSYNSOF</name>
                <description>If set to 1, disable synthesizing missing SOFs.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISCON</name>
                <description>Setting this bit to '1' will disconnect HW from the USB bus by removing the internal 1.5 K pull-up resistor from the D+</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DEV_SUSPEND</name>
                <description>Puts the USB device controller and PHY into suspend mode (pull up connected, drivers, PLLs etc turned off).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_FS</name>
                <description>Forces the device controller to enumerate as FS-only device.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HSM</name>
                <description>If HSM=1, the SIE is operating in High Speed Mode
0-1 transition of this bit causes a HSGRANT interrupt request.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>L0_ACTIVE</name>
                <description>Indicates USB2.0 link active state. 1 - Link is in active state. 0 - Link is not in active state.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>L2_SUSPEND</name>
                <description>Indicates USB2.0 link L2 suspend state. 1 - Link is in l2-suspend state. 0 - Link is not in l2-suspend state.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>L1_SLEEP</name>
                <description>Indicates USB2.0 link L1 sleep state. 1 - Link is in l1-sleep state. 0 - Link is not in l1-sleep state</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_SETUPDAT_0</name>
            <description>SETUPDAT0 register</description>
            <addressOffset>0x900C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SETUP_REQUEST_TYPE</name>
                <description>Setup data field</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SETUP_REQUEST</name>
                <description>Setup data field</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SETUP_VALUE</name>
                <description>Setup data field</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_SETUPDAT_1</name>
            <description>SETUPDAT1 register</description>
            <addressOffset>0x9010</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SETUP_INDEX</name>
                <description>Setup data field</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SETUP_LENGTH</name>
                <description>Setup data field</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_TOGGLE</name>
            <description>Data toggle for endpoints</description>
            <addressOffset>0x9014</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x100</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>ENDPOINT</name>
                <description>Endpoint</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO</name>
                <description>1=IN, 0=OUT</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>R</name>
                <description>Write '1' to reset data toggle to '0'.  When both R and S are set, behavior is undefined.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>S</name>
                <description>Write '1' to set data toggle to '1'.  When both R and S are set, behavior is undefined.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>Q</name>
                <description>Current value of toggle bit for EP selected in IO/ENDPOINT</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TOGGLE_VALID</name>
                <description>Indicates Q is valid for selected endpoint, may be polled in s/w.
After writing to R/S, indicates write completion.
This bit must be cleared by s/w to initiate an operation.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>16</dim>
            <dimIncrement>4</dimIncrement>
            <name>DEV_EPI_CS[%s]</name>
            <description>IN Endpoint Control and Status register</description>
            <addressOffset>0x9018</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x40</resetValue>
            <resetMask>0xFCFDFFFF</resetMask>
            <fields>
              <field>
                <name>PAYLOAD</name>
                <description>Max number of bytes transferred for each token
0=1024 (Powerup default value = 64)</description>
                <bitRange>[9:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TYPE</name>
                <description>The End Point Type (Control on EP0 only)
00: Control
01: Isochronous
10: Bulk
11: Interrupt</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ISOINPKS</name>
                <description>Number of packets to be sent per microframe (aka high-bandwidth mode ISO).  For this implementation only EP3 and EP7 support values other than 1.  EP3 and EP7 support values 1..3.  This field must be 0 for non-ISO endpoints.</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Set VALID=1 to activate an endpoint, and VALID=0 to de-activate it. All USB endpoints default to disabled. An endpoint whose VALID bit is 0 does not respond to any USB traffic.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NAK</name>
                <description>Setting this bit causes NAK on IN transactions.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>Set this bit to '1' to stall an endpoint, and to '0' to clear a stall.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMMIT</name>
                <description>Set whenever an IN token was ACKed by the host.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BNAK</name>
                <description>When the host sends an IN token to any Bulk IN endpoint which does not have data to send, the Bay automatically NAKs the IN token and asserts this interrupt.
Note that this bit will not be set if either the Endpoint NAK or global NAK_ALL bits are set when the NAK is transmitted</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DONE</name>
                <description>Indicates transfer is done (UIB_EPI_XFER_CNT=0).
This bit must be cleared by s/w.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ZERO</name>
                <description>Indicates a zero length packet was returned to the host in an IN transaction.  Must be cleared by s/w.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SHORT</name>
                <description>This interrupt is for ISO requests only as ISO requests does not have an ACK mechanism built-in as part of USB specification. An interrupt is set when Host makes an ISO request when device is not ready with the data, NAK, STALL and per-endpoint NAK bit is set for requested endpoint.</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ISOERR</name>
                <description>The ISO_ERR is set when ISO data PIDs arrive out of sequence (applies to high speed only), or when an an ISO packet was dropped because no data was available (FS or HS)</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMMIT_MASK</name>
                <description>Interrupt mask for COMMIT bit</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BNAK_MASK</name>
                <description>Interrupt mask for BNAK bit</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DONE_MASK</name>
                <description>Interrupt mask for DONE bit</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ZERO_MASK</name>
                <description>Interrupt mask for ZERO bit</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SHORT_MASK</name>
                <description>Interrupt mask for SHORT bit</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ISOERR_MASK</name>
                <description>Interrupt mask for ISOERR bit</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>16</dim>
            <dimIncrement>4</dimIncrement>
            <name>DEV_EPI_XFER_CNT[%s]</name>
            <description>IN Endpoint remaining transfer length register</description>
            <addressOffset>0x9058</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BYTES_REMAINING</name>
                <description>Number of bytes remaining in the transfer.  This value will never go negative (if more bytes are transferred than remaining in counter, counter will go to 0). DONE interrupt is raised when the counter decrements to 0.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>16</dim>
            <dimIncrement>4</dimIncrement>
            <name>DEV_EPO_CS[%s]</name>
            <description>OUT Endpoint Control and Status</description>
            <addressOffset>0x9098</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x40</resetValue>
            <resetMask>0xFEFFFFFF</resetMask>
            <fields>
              <field>
                <name>PAYLOAD</name>
                <description>Max number of bytes transferred for each token
0=1024 (Powerup default value = 64)</description>
                <bitRange>[9:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TYPE</name>
                <description>The End Point Type (Control on EP0 only)
00: Control
01: Isochronous
10: Bulk
11: Interrupt</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ISOINPKS</name>
                <description>Number of packets to be sent per microframe (aka high-bandwidth mode ISO).  For this implementation only EP3 and EP7 support values other than 1.  EP3 and EP7 support values 1..3.  This field must be 0 for non-ISO endpoints.</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Set VALID=1 to activate an endpoint, and VALID=0 to de-activate it. All USB endpoints default to disabled. An endpoint whose VALID bit is 0 does not respond to any USB traffic.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NAK</name>
                <description>Setting this bit causes NAK on OUT and PING transactions.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>Set this bit to '1' to stall an endpoint, and to '0' to clear a stall.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OVF</name>
                <description>Indicates a packet was received in an OUT token with more bytes than PAYLOAD.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMMIT</name>
                <description>Set whenever device controller ACKs an OUT token.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BNAK</name>
                <description>When the host sends a PING/OUT token to any Bulk OUT endpoint, which does not have an empty buffer, the Bay automatically NAKs the token and asserts this interrupt.
Note that this bit will be set if there is no empty buffer at the receipt of the OUT Packet and if neither the Endpoint NAK or global NAK_ALL bits are set when the NAK is transmitted.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DONE</name>
                <description>Indicates transfer is done (UIB_EPI_XFER_CNT=0).
This bit must be cleared by s/w.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ZERO</name>
                <description>Indicates a zero length packet was returned to the host in an IN transaction.  Must be cleared by s/w.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SHORT</name>
                <description>Indicates a shorter-than-maxsize packet was received, but UIB_EPI_XFER_CNT did not reach 0).</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ISOERR</name>
                <description>The ISO_ERR is set when ISO data PIDs arrive out of sequence (applies to high speed only), or when no buffer space is available (FS or HS) in EPM after accepting current DATA PID. All subsequent packets are dropped.</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OVF_MASK</name>
                <description>Interrupt mask for OVUF bit</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMMIT_MASK</name>
                <description>Intterupt mask for COMMIT bit</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BNAK_MASK</name>
                <description>Interrupt mask for BNAK bit</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DONE_MASK</name>
                <description>Interrupt mask for DONE bit</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ZERO_MASK</name>
                <description>Interrupt mask for ZERO bit</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SHORT_MASK</name>
                <description>Interrupt mask for SHORT bit</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ISOERR_MASK</name>
                <description>Interrupt mask for ISOERR bit</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>16</dim>
            <dimIncrement>4</dimIncrement>
            <name>DEV_EPO_XFER_CNT[%s]</name>
            <description>OUT Endpoint remaining transfer length register</description>
            <addressOffset>0x90D8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BYTES_REMAINING</name>
                <description>Number of bytes remaining in the transfer.  This value will never go negative (if more bytes are transferred than remaining in counter, counter will go to 0). DONE interrupt is raised when the counter decrements to 0.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_CTL_INTR_MASK</name>
            <description>CONTROL interrupt mask register</description>
            <addressOffset>0x9118</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>SETADDR</name>
                <description>Active high. 1 - Unmasks the SET_ADDRESS interrupt. 0 - Masks the SET_ADDRESS interrupt.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SOF</name>
                <description>Set whenever a SOF occurrs</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SUSP</name>
                <description>Set when the host suspends the USB bus (USB SUSPEND)</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>URESET</name>
                <description>Set when the host has initiated USB RESET (2.5us single ended 0 on bus)</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HSGRANT</name>
                <description>Set when the host grants high speed communications.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SUTOK</name>
                <description>Set whenever a (valid of invalid) SETUP token is received</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SUDAV</name>
                <description>Set when a valid SETUP token and data is received.  Data from this token can be read from UIB_DEV_SETUPDAT.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERRLIMIT</name>
                <description>USB Error limit detect from UIB_DEV_CS (COUNT&gt;=LIMIT)</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>URESUME</name>
                <description>Set when the host has initiated USB RESUME (&gt;2.5us K state on bus)</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STATUS_STAGE</name>
                <description>Set when host completes Status Stage of a Control Transfer</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>L1_SLEEP_REQ</name>
                <description>Set when host issues a LPM-L1-SLEEP request</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>L1_URESUME</name>
                <description>Set when the host has initiated USB RESUME to exit from L1-Sleep low-power mode and device has moved to normal operation. It indicates both host-initiated and host-reflected resume request.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESETDONE</name>
                <description>Set when an end-of-reset signaling is detected by the device.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HOST_URSUME_ARRIVED</name>
                <description>Set upon detection of USB Host initiated resume sequence for 3us in the device controller.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DPSLP</name>
                <description>Set upon wake-up request due to K-state during USB Host initiated resume sequence.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PID_MISMATCH_ON_NAK</name>
                <description>Set when a new transfer with incorrect PID is sent by the Host even after the device has sent a NAK for previous request. This interrupt is raised for both isochronous and bulk endpoints upon incorrect PID detection from Host.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_CTL_INTR</name>
            <description>CONTROL interrupt request register</description>
            <addressOffset>0x911C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>SETADDR</name>
                <description>Set when host issues a SET_ADDR request to the device</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SOF</name>
                <description>Set whenever a SOF occurrs</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SUSP</name>
                <description>Set when the host suspends the USB bus (USB SUSPEND)</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>URESET</name>
                <description>Set when the host has initiated USB RESET (2.5us single ended 0 on bus)</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HSGRANT</name>
                <description>Set when the host grants high speed communications.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SUTOK</name>
                <description>Set whenever a (valid of invalid) SETUP token is received</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SUDAV</name>
                <description>Set when a valid SETUP token and data is received.  Data from this token can be read from UIB_DEV_SETUPDAT.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERRLIMIT</name>
                <description>USB Error limit detect from UIB_DEV_CS (COUNT&gt;=LIMIT)</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>URESUME</name>
                <description>Set when end-of-resume signalling is detected from L2-suspend</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STATUS_STAGE</name>
                <description>Set when host completes Status Stage of a Control Transfer</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>L1_SLEEP_REQ</name>
                <description>Set when host issues a LPM token to enter L1-SLEEP request</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>L1_URESUME</name>
                <description>Set when end-of-resume signalling is detected from L1-sleep</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESETDONE</name>
                <description>Set when an end-of-reset signaling is detected by the device</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HOST_URSUME_ARRIVED</name>
                <description>Set upon detection of USB Host initiated resume sequence for 3us in the device controller.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DPSLP</name>
                <description>Set upon wake-up request, during deep-sleep, based on line state change to K-state on USB interface.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PID_MISMATCH_ON_NAK</name>
                <description>Set when a new transfer with incorrect PID is sent by the Host. This interrupt is raised for both isochronous and bulk endpoints upon incorrect PID detection from Host.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_CTL_INTR_MASKED</name>
            <description>CONTROL interrupt masked register</description>
            <addressOffset>0x9120</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>SETADDR_MASKED</name>
                <description>Mask status for SET_ADDRESS interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SOF_MASKED</name>
                <description>Mask status for SOF interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SUSP_MASKED</name>
                <description>Mask status for Suspend interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>URESET_MASKED</name>
                <description>Mask status for USB interface interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HSGRANT_MASKED</name>
                <description>Mask status for interrupt indicating the host accepting high speed communications.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SUTOK_MASKED</name>
                <description>Mask status for SETUP token interrupt.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SUDAV_MASKED</name>
                <description>Mask status for interrupt - Receiving SETUP and Data tokens.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ERRLIMIT_MASKED</name>
                <description>Mask status for USB Error limit detect interrupt</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>URESUME_MASKED</name>
                <description>Mask status for host initiated USB RESUME interrupt (&gt;2.5us K state on bus)</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>STATUS_STAGE_MASKED</name>
                <description>Mask status for interrupt indicating host completed Status Stage of a Control Transfer</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>L1_SLEEP_REQ_MASKED</name>
                <description>Mask status for interrupt indicating host issued a LPM token for L1-SLEEP request</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>L1_URESUME_MASKED</name>
                <description>Mask status for interrupt indicating host sent a resume request when in L1-Sleep low-power mode. It indicates both host-initiated and host-reflected resume request.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RESETDONE_MASKED</name>
                <description>Mask status for interrupt indicating end-of-reset signaling detected by the device controller.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HOST_URSUME_ARRIVED_MASKED</name>
                <description>Mask status for interrupt indicating detection of resume sequence sent by USB host.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DPSLP_MASKED</name>
                <description>Mask status for deep sleep interrupt indicating linestate change due to USB host.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PID_MISMATCH_ON_NAK_MASKED</name>
                <description>Set when a new transfer with incorrect PID is sent by the Host even after the device has sent a NAK for previous request. This interrupt is raised for both isochronous and bulk endpoints upon incorrect PID detection from Host.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_CTL_INTR_SET</name>
            <description>CONTROL interrupt set register</description>
            <addressOffset>0x9124</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>SETADDR_MASKED</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SOF_MASKED</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SUSP_MASKED</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>URESET_MASKED</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HSGRANT_MASKED</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SUTOK_MASKED</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SUDAV_MASKED</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERRLIMIT_MASKED</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>URESUME_MASKED</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STATUS_STAGE_MASKED</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>L1_SLEEP_REQ_MASKED</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>L1_URESUME_MASKED</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESETDONE_MASKED</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HOST_URSUME_ARRIVED_MASKED</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DPSLP_MASKED</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PID_MISMATCH_ON_NAK_MASKED</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_EP_INTR_MASK</name>
            <description>USB EP interrupt mask register</description>
            <addressOffset>0x9128</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EP_IN</name>
                <description>Bit &lt;x&gt; masks any interrupt from EPI_CS[x]. Active high. 1 - Unmasks the interrupt. 0 - Masks the interrupt.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP_OUT</name>
                <description>Bit &lt;16+x&gt; masks any interrupt from EPO_CS[x]. Active high. 1 - Unmasks the interrupt. 0 - Masks the interrupt.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_EP_INTR</name>
            <description>USB EP interrupt request register</description>
            <addressOffset>0x912C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EP_IN</name>
                <description>Bit &lt;x&gt; indicates an interrupt from EPI_CS[x]</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP_OUT</name>
                <description>Bit &lt;16+x&gt; indicates an interrupt from EPO_CS[x]</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_EP_INTR_MASKED</name>
            <description>USB EP interrupt masked register</description>
            <addressOffset>0x9130</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EP_IN</name>
                <description>1 - Corresponding interrupt is masked. 0 - Not masked.
Bit &lt;x&gt; indicates an interrupt from EPI_CS[x]</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP_OUT</name>
                <description>1 - Corresponding interrupt is masked. 0 - Not masked. Bit &lt;16+x&gt; indicates an interrupt from EPO_CS[x]</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_EP_INTR_SET</name>
            <description>USB EP interrupt set register</description>
            <addressOffset>0x9134</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EP_IN</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP_OUT</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_EP_INGRS_INTR_MASK</name>
            <description>USB EP INGRS interrupt mask register</description>
            <addressOffset>0x9138</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EP_INGRS_ZLP_RCVD</name>
                <description>Bit &lt;x&gt; masks any interrupt from DEV_EP_INGRS_INTR[x]. Active high. 1 - Unmasks the interrupt. 0 - Masks the interrupt.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP_INGRS_SLP_RCVD</name>
                <description>Bit &lt;16+x&gt; masks any interrupt from DEV_EP_INGRS_INTR[x]. Active high. 1 - Unmasks the interrupt. 0 - Masks the interrupt.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_EP_INGRS_INTR</name>
            <description>USB EP INGRS interrupt request register</description>
            <addressOffset>0x913C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EP_INGRS_ZLP_RCVD</name>
                <description>Bit &lt;x&gt; indicates a zero-packet arrival interrupt for each endpoint.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP_INGRS_SLP_RCVD</name>
                <description>Bit &lt;16+x&gt; indicates a zero-packet arrival interrupt for each endpoint.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_EP_INGRS_INTR_MASKED</name>
            <description>USB EP INGRS interrupt masked register</description>
            <addressOffset>0x9140</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EP_INGRS_ZLP_RCVD</name>
                <description>1 - Corresponding interrupt is masked. 0 - Not masked.
Bit &lt;x&gt; indicates masked bit for DEV_EP_INGRS_INTR[x]</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP_INGRS_SLP_RCVD</name>
                <description>1 - Corresponding interrupt is masked. 0 - Not masked. Bit &lt;16+x&gt; indicates masked bit for DEV_EP_INGRS_INTR[x]</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_EP_INGRS_INTR_SET</name>
            <description>USB EP INGRS interrupt set register</description>
            <addressOffset>0x9144</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EP_INGRS_ZLP_RCVD</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP_INGRS_SLP_RCVD</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_EP_EGRS_REQ</name>
            <description>USB EP Egress Request register</description>
            <addressOffset>0x9148</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EP_EGRS_ZLP_SENT</name>
                <description>1 - Firmware sets to schedule a ZLP request on egress path for an endpoint.
0 - Hardware clears to indicate a ZLP packet is sent after all pending transfers for an endpoint.
Each bit represents an endpoint on egress path.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP_EGRS_SLP_SENT</name>
                <description>1 - Firmware sets to schedule a SLP request on egress path for an endpoint.
0 - Hardware clears to indicate a SLP packet is sent on egress path for an endpoint.
Each bit represents an endpoint on egress path.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_EP_EGRS_INTR_MASK</name>
            <description>USB EP EGRS interrupt mask register</description>
            <addressOffset>0x914C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EP_EGRS_ZLP_SENT</name>
                <description>Bit &lt;x&gt; masks any interrupt from DEV_EP_EGRS_INTR[x]. Active high. 1 - Unmasks the interrupt. 0 - Masks the interrupt.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP_EGRS_SLP_SENT</name>
                <description>Bit &lt;16+x&gt; masks any interrupt from DEV_EP_EGRS_INTR[x]. Active high. 1 - Unmasks the interrupt. 0 - Masks the interrupt.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_EP_EGRS_INTR</name>
            <description>USB EP EGRS interrupt request register</description>
            <addressOffset>0x9150</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EP_EGRS_ZLP_SENT</name>
                <description>1 - Hardware clear of DEV_EP_EGRS_REQ register bit results in setting of an interrupt on egress path for an endpoint.
0 - Firmware clears the bit for each endpoint.
Each bit represents an endpoint on egress path.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP_EGRS_SLP_SENT</name>
                <description>1 - Hardware clear of DEV_EP_EGRS_REQ register bit results in setting of an interrupt on egress path for an endpoint.
0 - Firmware clears the bit for each endpoint.
Each bit represents an endpoint on egress path.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_EP_EGRS_INTR_MASKED</name>
            <description>USB EP EGRS interrupt masked register</description>
            <addressOffset>0x9154</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EP_EGRS_ZLP_SENT</name>
                <description>1 - Corresponding interrupt is masked. 0 - Not masked.
Bit &lt;x&gt; indicates an interrupt from DEV_EP_EGRS_INTR[x]</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP_EGRS_SLP_SENT</name>
                <description>1 - Corresponding interrupt is masked. 0 - Not masked. Bit &lt;16+x&gt; indicates an interrupt from DEV_EP_EGRS_INTR[x]</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_EP_EGRS_INTR_SET</name>
            <description>USB EP EGRS interrupt set register</description>
            <addressOffset>0x9158</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EP_EGRS_ZLP_SENT</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP_EGRS_SLP_SENT</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POWER</name>
            <description>USB 2.0 Device Power, Clock &amp; Reset Control Register</description>
            <addressOffset>0x915C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xA</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>RESETN</name>
                <description>Active LOW reset signal for all logic in the block.  Note that reset is active on all flops in the block when either system reset is asserted (RESET# pin or SYSTEM_POWER.RESETN is asserted) or this signal is active.
After setting this bit to 1, firmware shall poll and wait for the 'active' bit to assert.  Reading '1' from 'resetn' does not indicate the block is out of reset - this may take some time depending on initialization tasks and clock frequencies.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EPM_DCG_ENABLE</name>
                <description>Active High. 1 - Indicates that dynamic clock gating is enabled in the EPM core. 0 - Indicates that dynamic clock gating is disabled in the EPM core.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AHB2AHB_SCALING_EN</name>
                <description>Controls operation between clk_peri_i and clk_slow_i domain in the AHB-to-AHB bridge when MMIO interface is selected to access EPM. 0 - Set it when clk_slow_i &lt;= clk_peri_i. 1 - Clear it when clk_slow_i &gt; clk_peri_i.
NOTE: Use case is clk_peri_i = clk_slow_i = 75MHz/100MHz. This is only required if one of the clocks is scaled down while other remains unchanged. This is not a planned use case.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LPM_ENABLE</name>
                <description>Active High. 1 - Indicates LPM feature is enabled in controller. 0 - Indicates LPM feature is disabledi n controller.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VBUS_VALID</name>
                <description>Active High. 1 - Indicates VBUS supply ready and stable on USB interface. 0 - Indicates VBUS supply is not ready on USB interface.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>REFCLK_SEL</name>
                <description>Selects source of reference clock. 0 - Selects clk_eco as reference clock to the PLL. 1 - Selects clk_xop as reference clock to the PLL.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_LPM_ATTR</name>
            <description>USB 2.0 Device LPM Register</description>
            <addressOffset>0x9160</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x10E00</resetValue>
            <resetMask>0x80FFFF3F</resetMask>
            <fields>
              <field>
                <name>RMT_WAKEUP_ENABLE</name>
                <description>Active High. 1 - Host enabled support for remote wake-up by device during L1-Sleep. 0 - Host disabled support for remote wake-up by device during L1-sleep.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HIRD</name>
                <description>Host publishes value of the HIRD ranging from 75us till 9.95ms for the device.
0x0: Duration of resume sequence by host 75us.
0x1: Duration of resume sequence by host 100us.
0x2: Duration of resume sequence by host 150us.
0x3: Duration of resume sequence by host 250us.
0x4: Duration of resume sequence by host 350us.
0x5: Duration of resume sequence by host 450us.
0x6: Duration of resume sequence by host 950us.
0x7: Duration of resume sequence by host 1950us.
0x8: Duration of resume sequence by host 2950us.
0x9: Duration of resume sequence by host 3950us.
0xA: Duration of resume sequence by host 4950us.
0xB: Duration of resume sequence by host 5950us.
0xC: Duration of resume sequence by host 6950us.
0xD: Duration of resume sequence by host 7950us.
0xE: Duration of resume sequence by host 8950us.
0xF: Duration of resume sequence by host 9950us.</description>
                <bitRange>[4:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NYET</name>
                <description>Active High. 1 - Sends a NYET response for a LPM token received from the Host. 0 - No NYET response sent to the host for a LPM token received.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>T_L1_TOKEN_RETRY</name>
                <description>Programmable value to wait for 10us after a LPM token is received and before the device enters L1-state. Allowed values range from 240 till 300 as required by USB LPM specification.</description>
                <bitRange>[23:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>L2_SUSP_RMT_WAKEUP_EN</name>
                <description>Active High. 1 - Host enabled support for remote wake-up by device during L2-Suspend. 0 - Host disabled support for remote wake-up by device during L2-Suspend. The bit is updated based on set_feature or clear_feature request from USB host.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_LPM_TIM_1</name>
            <description>USB 2.0 Device LPM Timer Parameter Register</description>
            <addressOffset>0x9164</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x5DC</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>T_L1_DEV_DRV_RESUME</name>
                <description>Programmable value to wait. Default value is for 50us.
Resume from L1-Sleep: Drives resume for 50us (0x5DC). Allowed values range from 0x5BE till 0x5FA as required by USB LPM specification.
Resume from L2-Suspend: Drives resume for 7ms (0x33450). Allowed values range from 0x7530 till 0x6DDD0 as required by USB 2.0 specification.</description>
                <bitRange>[19:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_CHIRP_OVERRIDE</name>
            <description>USB 2.0 Device Chirp Override Register</description>
            <addressOffset>0x9168</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF80FF</resetMask>
            <fields>
              <field>
                <name>OVERRIDE_FSM</name>
                <description>Active High. 1 - Allows override of initialization sequence by forcing transitions indicated by other bits of this register. 0 - Override is disabled.
Override needs to be disabled and re-enabled for a different value to be programmed.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_CHIRP_K</name>
                <description>Active High. 1 - Forces chirp-K sequence on interface if override is enabled. 0 - Disables chirp-K sequence on interface.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_CHIRP_J</name>
                <description>Active High. 1 - Forces chirp-J sequence on interface if override is enabled. 0 - Disables chirp-J sequence on interface.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STATE</name>
                <description>Override state value for chirp state machine when override is enabled. 0x0 - Full-Speed Mode, 0xD - High-Speed Mode.</description>
                <bitRange>[7:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SEND_TEST_PACKET</name>
                <description>1 - Allows sending of test packet during characterization. 0 - Disables sending of test packet during characterization. Setting override_fsm bit in this register is not required. The bit directly controls operation in Controller.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RCV_TEST_PACKET</name>
                <description>1 - Allows receiving of test packet during characterization. 0 - Disables receiving of test packet during characterization. Setting override_fsm bit in this register is not required. The bit directly controls operation in Controller.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_PACKET_SPEED</name>
                <description>1 - High speed mode selected during characterization. 0 - Full speed mode selected during characterization. Setting override_fsm bit in this register is not required. The bit directly controls operation in Controller.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_J_FS</name>
                <description>1 - Forces J-state during full-speed mode in Controller. 0 - Disables forcing operation. Setting override_fsm bit in this register is not required. The bit directly controls operation in Controller.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_K_FS</name>
                <description>1 - Forces K-state during full-speed mode in Controller. 0 - Disables forcing operation. Setting override_fsm bit in this register is not required. The bit directly controls operation in Controller.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_J_HS</name>
                <description>1 - Forces J-state during high-speed mode in Controller. 0 - Disables forcing operation. Setting override_fsm bit in this register is not required. The bit directly controls operation in Controller.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_K_HS</name>
                <description>1 - Forces K-state during high-speed mode in Controller. 0 - Disables forcing operation. Setting override_fsm bit in this register is not required. The bit directly controls operation in Controller.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_J_NO45</name>
                <description>1 - Forces J-state and disables 45 ohm resistance in Controller. 0 - Disables forcing operation. Setting override_fsm bit in this register is not required. The bit directly controls operation in Controller.</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_K_NO45</name>
                <description>1 - Forces K-state and disables 45 ohm resistance in Controller. 0 - Disables forcing operation. Setting override_fsm bit in this register is not required. The bit directly controls operation in Controller.</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_TIM_T_DCHSE0</name>
            <description>USB 2.0 Device Init Timing 0 Register</description>
            <addressOffset>0x916C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x4B0C0BB8</resetValue>
            <resetMask>0x7FDF3FFF</resetMask>
            <fields>
              <field>
                <name>T_DCHSE0</name>
                <description>Programmable value to detect T_DCHSE0 timing parameter for Idle detection in HS mode after chirp sequence during reset signalling by USB Host. The value ranges from 0x0BB8 (100us) to 0x3A98 (500us).</description>
                <bitRange>[13:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>T_IPG</name>
                <description>Programmable value to detect interpacket gap timing parameter. This is used to flush transaction if no new request or ACK is received by the device controller. The value ranges from 0x1 (16 bit-times) to 0xC (192 bit-times).</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>T_HST_DBOUNCE</name>
                <description>Programmable value used to debounce host-initiated resume sequence. The value ranges from 0xFA (2.5us) to 0x1FF (5.11us). The value is programmed based on clk_peri frequency.</description>
                <bitRange>[30:22]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_TIM_T_DETRST_FILT</name>
            <description>USB 2.0 Device Init Timing 1 Register</description>
            <addressOffset>0x9170</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x780005A</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>T_DETRST</name>
                <description>Programmable value to detect T_DETRST timing parameter for reset detection as governed by USB 2.0 specification. The value ranges from 0x4B to 0x493E0.</description>
                <bitRange>[19:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>T_FILT</name>
                <description>Programmable value to detect T_FILT timing parameter for chirp detection as governed by USB 2.0 specification. Supports from 2.5us to 136.5us. The specification does not provide an upper limit for this field.</description>
                <bitRange>[31:20]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_TIM_T_WTFS</name>
            <description>USB 2.0 Device Init Timing 2 Register</description>
            <addressOffset>0x9174</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xEAC4</resetValue>
            <resetMask>0x1FFFF</resetMask>
            <fields>
              <field>
                <name>T_WTFS</name>
                <description>Programmable value to detect T_WTFS timing parameter to switch to full-speed mode after no chirp is detected during interface reset request. The value ranges from 0x7530 to 0x124F8.</description>
                <bitRange>[16:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_TIM_T_SUSP</name>
            <description>USB 2.0 Device Init Timing 3 Register</description>
            <addressOffset>0x9178</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x15FF4</resetValue>
            <resetMask>0x1FFFF</resetMask>
            <fields>
              <field>
                <name>T_SUSP</name>
                <description>Programmable timing parameter value to detect suspend in full-speed or high-speed mode.</description>
                <bitRange>[16:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_TIM_T_WTRSTHS</name>
            <description>USB 2.0 Device Init Timing 4 Register</description>
            <addressOffset>0x917C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3A98</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>T_WTRSTHS</name>
                <description>Programmable timing parameter value. It indicates time a device must wait after reverting to FS before sampling the bus state for SE0. Support values range from 0xBB8 to 0x668A.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_TIM_T_UCH</name>
            <description>USB 2.0 Device Init Timing 5 Register</description>
            <addressOffset>0x9180</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xEA60</resetValue>
            <resetMask>0x1FFFF</resetMask>
            <fields>
              <field>
                <name>T_UCH</name>
                <description>Programmable timing parameter value. It indicates minimum chirp pulse width in a device in SE0. Support values range from 0x7530 to 0x15F90.</description>
                <bitRange>[16:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_TIM_T_WTREV_WTRSTFS</name>
            <description>USB 2.0 Device Init Timing 6 Register</description>
            <addressOffset>0x9184</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x15F90</resetValue>
            <resetMask>0x1FFFF</resetMask>
            <fields>
              <field>
                <name>T_WTREV_WTRSTFS</name>
                <description>Programmable timing parameter value. It indicates minimum chirp pulse width in a device in SE0. Support values range from 0x7530 to 0x15F90.</description>
                <bitRange>[16:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DDFT_CONFIG</name>
            <description>USB 2.0 DDFT Configuration Register</description>
            <addressOffset>0x9188</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x807F807F</resetMask>
            <fields>
              <field>
                <name>DDFT0_SEL</name>
                <description>N/A</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DDFT0_POLARITY</name>
                <description>0 - Observed DDFT output is not inverted.
1 - DDFT output is inverted.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DDFT1_SEL</name>
                <description>N/A</description>
                <bitRange>[22:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DDFT1_POLARITY</name>
                <description>0 - Observed DDFT output is not inverted.
1 - DDFT output is inverted.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_LOOPBACK_CTRL</name>
            <description>USB 2.0 UTMI Loopback Control Register</description>
            <addressOffset>0x9190</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>LPBK_EN</name>
                <description>Control the loopback path on UTMI interface between device controller and PHY. 1 - Enables the loopback path. 0 - Disables the loopback path.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LPBK_START</name>
                <description>Starts the transfer on the loopback path on UTMI interface. 1 - UTMI transfer in progress over the loopback path. 0 - UTMI transfer is complete over the loopback path.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LPBK_START_INTR</name>
                <description>Active high. 1 - Interrupt is set upon clearing of LPBK_START bit in this register. 0 - Interrupt is not set.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LPBK_START_MASK</name>
                <description>Mask for clearing loopback start during burn-in test. 1 - Unmask the interrupt. 0 - Mask the interrupt.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LPBK_START_MASKED</name>
                <description>0 - Corresponding interrupt is masked. 1 - Not masked.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LPBK_START_SW_SET</name>
                <description>Write with '1' to set corresponding bit.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_LOOPBACK_IN_REQ</name>
            <description>USB 2.0 UTMI Loopback IN Token Request Register</description>
            <addressOffset>0x9194</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFF</resetMask>
            <fields>
              <field>
                <name>IN_TOKEN</name>
                <description>IN token packet for USB2.0 device controller as defined by USB2.0 specification.</description>
                <bitRange>[23:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_LOOPBACK_OUT_REQ</name>
            <description>USB 2.0 UTMI Loopback OUT Token Request Register</description>
            <addressOffset>0x9198</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFF</resetMask>
            <fields>
              <field>
                <name>OUT_TOKEN</name>
                <description>OUT token packet for USB2.0 device controller as defined by USB2.0 specification.</description>
                <bitRange>[23:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>EPM_CS</name>
            <description>EPM Control and Status Register</description>
            <addressOffset>0x9200</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>EGRS_FORCE_FLUSH_ALL</name>
                <description>1 - Forcefully flushes the Egress SRAM. 0 - Does not flush the Egress SRAM.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IGRS_FORCE_FLUSH_ALL</name>
                <description>1 - Forcefully flush the contents in Ingress SRAM. 0 - Does not flush Ingress SRAM.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ALLOW_TRIG_ON_SLP</name>
                <description>1 - Allow EPM to send a trigger to DMA when interrupt is cleared by the processor for SLP on ingress path. 0 - Allow processor to send a trigger to DMA for SLP on ingress path</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>EEPM_DEBUG</name>
            <description>Egress EPM Debug Register</description>
            <addressOffset>0x9208</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>C_EPNUM</name>
                <description>Indicates the active endpoint for which the transfer is going on in egress path.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>C_REQUEST</name>
                <description>Indicates current request for active endpoint for which the transfer is going on in egress path.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>USB_RD_ADDR</name>
                <description>Read address pointer for USB interface</description>
                <bitRange>[18:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>AHB_WR_ADDR</name>
                <description>Write address pointer for AHB interface</description>
                <bitRange>[31:19]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IEPM_DEBUG</name>
            <description>Ingress EPM Debug Register</description>
            <addressOffset>0x920C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF03FF</resetMask>
            <fields>
              <field>
                <name>ACTIVE_EP_NUM</name>
                <description>Indicates the active endpoint for which the transfer is going on in ingress path.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>P_REQUESTS</name>
                <description>Indicates the pending request count in ingress path.</description>
                <bitRange>[9:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>P_REQ_EP_NUM</name>
                <description>Indicates endpoints for which the requests are pending in ingress path. Bit16 - endpoint 0, bit17 - endpoint 1 and so on.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IEPM_DEBUG_1</name>
            <description>Ingress EPM Debug 1 Register</description>
            <addressOffset>0x9210</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>IGRS_USB_WADDR</name>
                <description>Write address pointer used by USB in ingress path</description>
                <bitRange>[8:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IGRS_AHB_RADDR</name>
                <description>Read address pointer used by AHB in ingress path</description>
                <bitRange>[24:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IEPM_DEBUG_2</name>
            <description>Ingress EPM Debug 2 Register</description>
            <addressOffset>0x9214</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>IGRS_LAST_WADDR</name>
                <description>Previous write address pointer used by USB</description>
                <bitRange>[8:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IGRS_LAST_RADDR</name>
                <description>Previous read address pointer used by AHB</description>
                <bitRange>[24:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>16</dim>
            <dimIncrement>4</dimIncrement>
            <name>EEPM_ENDPOINT[%s]</name>
            <description>Egress EPM per Endpoint Control and Status</description>
            <addressOffset>0x9220</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xBFF</resetMask>
            <fields>
              <field>
                <name>EGRS_SLP_BYTE_COUNT</name>
                <description>Number of bytes in short-length packet in the last USB transaction. 0x0 - 1 byte, 0x1 - 2 bytes, 0x2 - 3 bytes and so on. The value is valid when corresponding interrupt is set.</description>
                <bitRange>[9:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EGRS_FLUSH_EP</name>
                <description>Allows flushing of the selected endpoint on egress path. 1 - Flushes selected endpoint. 0 - No flush of the selected endpoint.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>16</dim>
            <dimIncrement>4</dimIncrement>
            <name>IEPM_ENDPOINT[%s]</name>
            <description>Ingress EPM Per Endpoint Control and Status</description>
            <addressOffset>0x9260</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xBFF</resetMask>
            <fields>
              <field>
                <name>INGRS_SLP_BYTE_COUNT</name>
                <description>Number of bytes in short-length packet in last USB transaction. 0x0 - 1 byte, 0x1 - 2 bytes, 0x2 - 3 bytes and so on. The value is valid when corresponding interrupt is set.</description>
                <bitRange>[9:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ALLOW_NAK_TILL_DMA_RDY</name>
                <description>Allows sending NAK on USB interface for ingress path till the DMA channel is ready for this endpoint. 1 - Allows sending NAK. 0 - Do not send NAK.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>16</dim>
            <dimIncrement>4</dimIncrement>
            <name>EEPM_DEBUG_ENDPOINT[%s]</name>
            <description>Egress EPM Per Endpoint Debug</description>
            <addressOffset>0x92A0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FFFFFFF</resetMask>
            <fields>
              <field>
                <name>EGRS_P_REQUESTS</name>
                <description>Number of pending requests for each endpoint in Egress SRAM. Used for debug only.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EGRS_DMA_TRIGGERED</name>
                <description>1 - Egress path sent a trigger to the DMA. 0 - No trigger is sent to the DMA. Used for debug only.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP_NEXT_ADDR</name>
                <description>Next address pointer on egress path</description>
                <bitRange>[15:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP_CURR_ADDR</name>
                <description>Current address pointer on egress path</description>
                <bitRange>[28:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP_NEXT_SLP</name>
                <description>Next SLP flag on egress path</description>
                <bitRange>[29:29]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP_CURR_SLP</name>
                <description>Current SLP flag on egress path</description>
                <bitRange>[30:30]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>16</dim>
            <dimIncrement>4</dimIncrement>
            <name>IEPM_DEBUG_ENDPOINT[%s]</name>
            <description>Ingress EPM Per Endpoint Debug</description>
            <addressOffset>0x92E0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>INGRS_DMA_TRIGGERED</name>
                <description>1 - Indicates the DMA was triggered on ingress path. 0 - No trigger sent to DMA on ingress path. Used for debug only.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>16</dim>
            <dimIncrement>4</dimIncrement>
            <name>MMIO_EEPM_ENDPOINT[%s]</name>
            <description>MMIO Egress EPM per Endpoint Control and Status</description>
            <addressOffset>0x9320</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>EGRS_IF_SELECT</name>
                <description>Allows access to egress SRAMs on MMIO interface. 1 - Egress SRAMS are accessible on MMIO for the selected endpoint. 0 - Egress SRAMs are accessible on DMA for the selected endpoint. The bit must be programmed one time during configuration.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MMIO_EGRS_TR_SEND</name>
                <description>Trigger from Processor to Egress EPM when MMIO interface is selected for an endpoint. Processor sets the trigger after pre-loading data into egress SRAM. 1 - Trigger request sent to egress EPM. 0 - Trigger request cleared to egress EPM.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MMIO_EGRS_TR_RCV</name>
                <description>Trigger from Egress EPM to the Processor when MMIO interface is selected for an endpoint. Ingress EPM sets the trigger indicating a request to pre-fetch next packet for an endpoint. 1 - Trigger request received from egress EPM. 0 - Trigger request cleared by egress EPM.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MMIO_EGRS_TR_RCV_MASK</name>
                <description>Mask for trigger as interrupt when MMIO interface is selected for an endpoint. 1 - Mask the interrupt. 0 - Unmask the interrupt.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MMIO_EGRS_TR_RCV_MASKED</name>
                <description>1 - Corresponding trigger interrupt is masked. 0 - Not masked.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MMIO_EGRS_TR_RCV_SW_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>16</dim>
            <dimIncrement>4</dimIncrement>
            <name>MMIO_IEPM_ENDPOINT[%s]</name>
            <description>MMIO Ingress EPM Per Endpoint Control and Status</description>
            <addressOffset>0x9360</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>INGRS_IF_SELECT</name>
                <description>Allows access to ingress SRAMs on MMIO interface. 1 - Ingress SRAMS are accessible on MMIO for the selected endpoint. 0 - Ingress SRAMs are accessible on DMA for the selected endpoint. The bit must be programmed one time during configuration.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MMIO_IGRS_TR_SEND</name>
                <description>Trigger from Processor to Ingress EPM when MMIO interface is selected for an endpoint. Processor sets a trigger after reading an arrived packet for an endpoint. The bit needs to be cleared by FW. 1 - Trigger request sent to ingress EPM. 0 - Trigger request cleared to ingress EPM.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MMIO_IGRS_TR_RCV</name>
                <description>Trigger from Ingress EPM to the Processor when MMIO interface is selected for an endpoint. Ingress EPM sets a trigger after arrival of a packet on USB interface for an endpoint. Trigger needs to be cleared by FW. 1 - Trigger request received from ingress EPM. 0 - Trigger request cleared by ingress EPM.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MMIO_IGRS_TR_RCV_MASK</name>
                <description>Mask for trigger as interrupt when MMIO interface is selected for an endpoint. 1 - Mask the interrupt. 0 - Unmask the interrupt.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MMIO_IGRS_TR_RCV_MASKED</name>
                <description>1 - Corresponding trigger interrupt is masked. 0 - Not masked.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MMIO_IGRS_TR_RCV_SW_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_SPARE_1</name>
            <description>DEV SPARE 1 Register</description>
            <addressOffset>0x93A0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF0000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SPARE_1_1</name>
                <description>Spare register bits</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE_1_2</name>
                <description>Spare register bits</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_SPARE_2</name>
            <description>DEV SPARE 2 Register</description>
            <addressOffset>0x93A4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF0000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SPARE_2_1</name>
                <description>Spare register bits</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE_2_2</name>
                <description>Spare register bits</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LEGACY_FEATURE_ENABLE</name>
            <description>Legacy Feature Enable Register</description>
            <addressOffset>0x93A8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA0_TOG_UPON_STALL</name>
                <description>1 - Selects legacy implementation in device controller.
0 - Clears DATA PID toggle to DATA0 upon STALL. The CDT-387103 tracks the issue.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONT_LP_UPON_NO_HOST_RSUME</name>
                <description>0 - Selects legacy implementation in device controller. 1 - Continues in Low-power state upon no resume reflection by Host during device-initiated remote wake-up. The CDT-385686 tracks the issue.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NO_PID_UPDATE_ON_NAK</name>
                <description>0 - Selects legacy implementation in device controller and generates an interrupt. 1 - NAK response and update of PID value is blocked for received DATA token when previous DATA token was NAK'd. Interrupt is generated. The CDT-391172 tracks the issue.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD</name>
                <description>N/A</description>
                <bitRange>[31:3]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DFT_OBSERVE</name>
            <description>DFT Observable Register</description>
            <addressOffset>0x93AC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DFT_OBSERVE</name>
                <description>N/A</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>USBHSPHY</name>
          <description>USB 2.0 PHY Registers</description>
          <addressOffset>0x00009800</addressOffset>
          <register>
            <name>AFE_CONTROL_1</name>
            <description>AFE Control register #1</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>HS_PRED_DP_SEL</name>
                <description>HS PMOS Pre-driver Skew</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HS_PRED_DN_SEL</name>
                <description>HS NMOS Pre-driver Skew</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HS_AMP_SEL</name>
                <description>HS Driver Amplitude Control</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HS_PREE_SEL</name>
                <description>HS Driver Pre-emphasis Amplitude</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HS_SR_FINE_SEL</name>
                <description>HS Driver Fine Slew Rate Control</description>
                <bitRange>[13:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HS_TED_LP_MODE</name>
                <description>HS TED Low Power Mode
0: Normal operation
1: Reduced current mode</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EN_LANE_SWAP</name>
                <description>The DP/DN pins are swapped on both the transmit and receive direction</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HS_CTLE_SEL</name>
                <description>HS Receiver CTLE Control</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FS_VTRIG_SEL</name>
                <description>FS Receiver Trigger Voltage Control</description>
                <bitRange>[21:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FS_SR_SEL</name>
                <description>FS Driver Slew Rate Control</description>
                <bitRange>[25:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LS_SR_SEL</name>
                <description>LS Driver Slew Rate Control</description>
                <bitRange>[27:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HS_LB_EN</name>
                <description>This bit enables the loopback mode. 
In this mode, the TX can either be looped back at the pads or at the input of the AFE.
This is specified by the RX_EN of the AFE.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HS_TED_25_MODE</name>
                <description>HS Squelch VDDD Selection bit
1: VDDD = 3.3V range - DONOT USE THIS SETTING for normal operation
0: VDDD = 1.8V range</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CPU_DELAY_ENABLE_VCCD</name>
                <description>INTR0.ENABLE_VCCD indicates that the 2p5 regulator is powered up. FW is required to set this bit after a delay as specified in the AFE requirements</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CPU_DELAY_ENABLE_HS_VCCD</name>
                <description>INTR0.ENABLE_HS_VCCD indicates that the 1p1 regulator is powere up. FW is required to set this aftera a delay as specifed in the AFE requirements</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>AFE_CONTROL_2</name>
            <description>AFE Control register #2</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x27FFF</resetMask>
            <fields>
              <field>
                <name>AFE_DFT_SEL</name>
                <description>N/A</description>
                <bitRange>[9:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EUSB_RX_CRUDE_EN</name>
                <description>Enables the OVERRIDE function for the eUSB receiver. This bit is used in conjunction with EUSB_RX_MUX_SEL and EUSB_RX_MISSION_EN. When 0, the switching between default and mission mode receiver happens through ENABLE_EUSB_RX</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EUSB_RX_MUX_SEL</name>
                <description>This bit selects between the default  receiver and mission mode receiver
0 - Default receiver  selected
1 - Mission mode receiver selected</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EUSB_RX_OVERRIDE</name>
                <description>N/A</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EUSB_RX_MISSION_EN</name>
                <description>This bit enables the default receiver
0 - mission mode receiver enabled based on se_rx_en. In testmode this can be done by setting ENABLE_EUSB_RX and AFE_CONTROL_3.SE_RX_EN_EDP
1 - default mode receiver enabled</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SE_RX_SE1_FILTER_EN_N</name>
                <description>Enable signal for SE1 RX filter, active LOW</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE_EUSB_RX</name>
                <description>This bit enabled the mission mode receiver for EUSB. Until this the default crude receiver is ON. This bit must be set after REG_SW_1P2 is turned on and cleared before disabling REG_SW_1P2</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTMI_CONTROL</name>
            <description>UTMI Control register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x55420000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SOFT_DISCONNECT_N</name>
                <description>1: Connect D+/D Pull downs for DS PHY and Pull-ups for US PHY in Non-Driving Mode indicated by op_mode=01. For test-mode controllability only.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VLOAD</name>
                <description>Active Low Signal. On setting this signal to 1, the  VCONTROL values determin the PHY Test modes. To change the testmode this bit has to be cleared and set again.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VCONTROL_TESTCODE</name>
                <description>This will contain the TESTCODE PHY during PHY Test modes and BISTMODE for BIST operation.
 This value is latched by PHY using VLOAD during Test Modes and  BIST_EN during BIST mode.
Refer to the PHY BROS for the Testcodes</description>
                <bitRange>[5:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VCONTROL_TESTDATA</name>
                <description>This will contain the TESTDATA for the PHY during PHY Test modes. This value is latched by PHY using VLOAD during Test Modes and  BIST_EN during BIST mode. Refer to the PHY BROS for the testdata</description>
                <bitRange>[9:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BIST_EN</name>
                <description>Triggers bist operation. VCONTROL values specifies the parameters of bist are latched when this bit is test.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TUNE_BYPASS_EN</name>
                <description>1: Bypass calibration for D+ and D- lines</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EXT_CAL_VALUE</name>
                <description>Apply this value to D+ and D- lines when self calibration is bypassed through CAL_BYPASS_EN=1</description>
                <bitRange>[16:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OTG_IN_SUSPEND</name>
                <description>N/A</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BIST_CONTINOUS_EN</name>
                <description>1: If BIST_EN is 1, Bist will continue a long pattern specified in BIST_CONTINUOUS_PATTERN until BIST_EN==0.
0: If BIST_EN is 1, Bist will send one packet.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LINESTATE_COMBO_SEQ</name>
                <description>Specifies if the generated linestate is filtered or unfiltered
0: use combo logic
1: use sequential logic</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LINESTATE_EXT_SEL</name>
                <description>Selects where the selection between combo and sequential logic is coming from.
0: Internal. Done by HW.
1: from LINE_STATE_COMBO_SEQ</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LINESTATE_CLK_SEL</name>
                <description>Selects clock input for the linestate module.
0: selects sieclk
1: selects clk480m</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CAL_BIG_LITTLE_ENDIAN</name>
                <description>0: Little endian 5,4,3,2,1,0
1: Big   endian  0,1,2,3,4,5</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BIST_CONTINOUS_PATTERN</name>
                <description>Bist pattern sent when BIST_CONTINOUS_EN==1 and BIST_EN==1</description>
                <bitRange>[30:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>REVERT_RPU_CTRL</name>
                <description>Setting this bit will revert the RPU control to the old logic used on HX3/Benicia.
0 - New implementation
1 - RPU Control not available in Serial Mode of operation</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CDR_CONTROL</name>
            <description>CDR registers</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2143</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CONF_EOI_VEC</name>
                <description>N/A</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONF_HS_6_SYNC</name>
                <description>Enables 6 or 4 bit SYNC detection in HS Serial Interface for PHY
1: Enables 6 Bit SYNC detection
0: Enables 4 Bit SYNC detection</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EBUF_DEPTH</name>
                <description>Specifies the half depth of the elastic buffer.
0: 13   
1: 12
2: 14
3: 15</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CDR_CONFIG_1</name>
                <description>It specifies the phase offset at which serial data is selected during recovery
0 : Serial data is captured 3 phases before clkrec.
1: serial data is captured 2 phasses before clkrec</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CDR_ENABLE</name>
                <description>0: CDR is kept in reset
1: CDR is enabled
CDR has to be enabled only after the PLL is locked</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SQUELCH_FILTER</name>
                <description>Squelch Filter specified in terms of 480MHz cycles
0 - no filtering
1-5 - 2-6 cycles of filtering</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SYNC_MATCH_PATTERN</name>
                <description>0: SYNC declared on seeing 3 KJ pairs
1: SYNC delcared on seeing 2 KJ pairs</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GATE_SERIAL_IN_TILL_SQUELCH</name>
                <description>0: Data is synchronized in parallel to squelch. Recovered data is qualified by squelch filter
1: Data input to CDR is qualified by squelch. Introduces delay on the repeater latency path</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SERIAL_IN_DELAY</name>
                <description>Bits [1:0]Delaying the Serial_in signal in CDR. There is a mismatch of 3 cycles between data and TED on the input to the elasticbuffer. This can be used to delay the data also to the elastic buffer. The squelch filter gates the output of this delay
Bit[2] Risk Mitigation for CDR. Will fasten lock time by changing phases once in 2 cycles, instead of once in 3 cycles</description>
                <bitRange>[15:13]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BC_CONTROL</name>
            <description>UHC Battery Charging CSR Bank</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>CHRGR_DET_ON</name>
                <description>1: Power on AFE charger detector circuit</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VDM_SRC_EN</name>
                <description>1: Enables voltage source on DN pin. If lane swap is enabled, enables voltage source on DP pin</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VDP_SRC_EN</name>
                <description>1: Enables voltage source on DP pin. If lane swap is enabled, enables voltage source on DN pin</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PLL_CONTROL_1</name>
            <description>Primary PLL control register#1</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3FFFEF7F</resetMask>
            <fields>
              <field>
                <name>RUN_AWAY_DEL</name>
                <description>Internal delay from comparator indicate run away to output rise</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RUN_AWAY_DIS</name>
                <description>Disable run away operation</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VCO_GAIN</name>
                <description>Gain of the vco circuit</description>
                <bitRange>[6:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PLL_EN</name>
                <description>Enable pll core operation. This bit can only be set after SUPPLY_EN is set. Refer to PLL BROS for further details of startup sequencing</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SUPPLY_EN</name>
                <description>Enable the PLL suply</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LD_DELAY</name>
                <description>Lock window adjust</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LDO_VCO_BYPASS</name>
                <description>Bypass LDO operation - PLL core operate from vccd</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>P_DIV</name>
                <description>Feedback divider - division</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>Q_DIV</name>
                <description>Input divider division</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PLL_SPARE</name>
                <description>Spare bit for future use</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VCO_INIT_DIS</name>
                <description>Bypass core LDO</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATST_SEL</name>
                <description>Test mode bits</description>
                <bitRange>[23:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CAL_UP_DN</name>
                <description>Trim for up/dn calibration mismatch</description>
                <bitRange>[27:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RA_UP_TR</name>
                <description>Trim for run away detector upper level threshold</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PLL_CONTROL_2</name>
            <description>Primary PLL control register#2</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2080</resetValue>
            <resetMask>0xFE01FFFF</resetMask>
            <fields>
              <field>
                <name>EN_CPU_OVERIDE_PLL_LOCK</name>
                <description>Setting this bit will drive the CPU_OVERIDE_PLL_LOCK_VALUE to pll_lock</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CPU_OVERIDE_PLL_LOCK_VALUE</name>
                <description>Value to driven on pll_lock</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SOURCE_OF_PLL_LOCK</name>
                <description>Specifies whether the pll_lock towards the logic is filtered version or from the PLL Hard-IP directly
0: Filter
1: s40pllusb2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCK_DELAY</name>
                <description>The output of the PLL lock signal is filtered for #LOCK_DELAY of refclk. The PLL lock signal must be high for # of LOCK_DELAY before declaring LOCKED.  Once the PLL lock signal is high, the internal counter for lock detection restarts.
This register should be programmed when PLL_CONTROL.PLL_EN is 0.</description>
                <bitRange>[10:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LOSS_LOCK_DELAY</name>
                <description>The output of the PLL lock signal is filtered for #LOSS_LOCK_DELAY of refclk. The PLL lock signal must be low for # of LOSS_LOCK_DELAY before declaring UNLOCKED.  Once the PLL lock signal is low, the internal counter for lock loss detection restarts.
This register should be programmed when PLL_CONTROL.PLL_EN is 0.</description>
                <bitRange>[15:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>JITTER_TEST_MODE</name>
                <description>Setting this bit will put the PHY that has the PLL inJitter measurement mode. In this mode a 240MHz signal generated on p0 is output through the HS transmitter. The References required for HS and the PLL should be enabled before setting this bit</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIV_VALUE</name>
                <description>This register is used to divide the selected PLL output phase (Per PLL_CLKOUT_DDFT_SEL) for observing on DDFT</description>
                <bitRange>[28:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PLL_CLKOUT_DDFT_SEL</name>
                <description>The selected PLL output will be divided by DIV_VALUE and routed to IP DDFT mux.
DDFT selection:
0: p0
1: p45
2: p90
3: p135
4: p180
5: p225
6: p270
7: p315</description>
                <bitRange>[31:29]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TEST_PLL_CONTROL</name>
            <description>Test PLL control register</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFEF7F</resetMask>
            <fields>
              <field>
                <name>RUN_AWAY_DEL</name>
                <description>Internal delay from comparator indicate run away to signal rise</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RUN_AWAY_DIS</name>
                <description>Disable run away operation</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VCO_GAIN</name>
                <description>Gain of the vco circuit</description>
                <bitRange>[6:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PLL_EN</name>
                <description>Enable pll core operation</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SUPPLY_EN</name>
                <description>Enable the PLL suply</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LD_DELAY</name>
                <description>Lock window adjust</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LDO_VCO_BYPASS</name>
                <description>Bypass LDO operation - PLL core operate from vccd</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>P_DIV</name>
                <description>Feedback divider - division</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>Q_DIV</name>
                <description>Input divider division</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PLL_SPARE</name>
                <description>N/A</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VCO_INIT_DIS</name>
                <description>Bypass core LDO</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATST_SEL</name>
                <description>Test mode bits</description>
                <bitRange>[23:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CAL_UP_DN</name>
                <description>Trim for up/dn calibration mismatch</description>
                <bitRange>[27:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RA_UP_TR</name>
                <description>Trim for run away detector upper level threshold</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_LOCK_DELAY</name>
                <description>The output of the PLL lock signal is filtered for # of LOCK_DELAY. The PLL lock signal must be high for # of LOCK_DELAY before declaring LOCKED.  Once the PLL lock signal is low, the internal counter for lock detection restarts.
This register should be programmed when TEST_PLL_CONTROL.PLL_EN is 0. 
0: 16 REFCLK
1: 32 REFCLK
2: 64 REFCLK
3: 128 REFCLK</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TEST_CONTROL</name>
            <description>Test control register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>RUN_CALIBRATION</name>
                <description>Test mode trigger to run calibration</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CALIBRATED_VALUE</name>
                <description>Calibration value from calibration logic</description>
                <bitRange>[5:1]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DDFT_CFG</name>
            <description>DDFT configuration</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DDFT0_SEL</name>
                <description>77                       controlled_oncal,
76                        controlled_cal_f1,
75                       controlled_cal_f2,
74                        controlled_hs_pree_en,
73                        controlled_conn_rpu1,
72                        controlled_conn_rpu2,
71                        controlled_hs_ded_en,
70                       controlled_hs_ded_reset,
69                        controlled_hs_ded_start,
68                       controlled_rpu_sel,
67                        controlled_ls_nfs,
66                       controlled_lsfs_diff_rx_en,
65                        controlled_conn_rpd_dp,
64                        controlled_conn_rpd_dn,
63                        controlled_iref_en,
62                        controlled_hs_rx_en,
61                        controlled_hs_rx_buf_on,
60                        controlled_hs_ted_en,
59                        controlled_hs_tx_en_slow,
58                        controlled_se_rx_en_dp,
57                        controlled_se_rx_en_dn,
56                        controlled_lfs_tx_en,
55                        controlled_lfs_tx_in,
54                        controlled_lfs_tx_on,
53                        controlled_enase0,
52                        eusb_onlfsserec, 
51                       controlled_enase1,
50                        controlled_se_tx_in_edn,
49                        controlled_se_tx_en_edn,
48:47                       increase_ted_threshold[1:0],
46                        irefgen_bypass_mode,
45 PLL_SUPPLY_EN
44 PLL_EN
43 AFE hs_ted_out
42 AFE cal_out
41 AFE se_rx_out_dn/se_rx_out_edn
40  AFE se_rx_out_dp/se_rx_out_edp
39  AFE hs_rx_out
38 AFE hs_ded_out
37 AFE lsfs_diff_rx_out
36 AFE stress_out
35 s40usb2afe_reg_2p5.ok_v25_vccd
34 s40usb2afe_reg_1p1.ok_vhs_vccd
33 0
32: PLL clockoutput per PLL_CONTROL2.PLL_CLKOUT_DDFT_SEL
31: reg_sw_1p2_control_enable_lv,
30: reg_2p5_control_enable_lv,
29: vrefgen_control_enable_lv
28: regulator_1p1_enable
27: irefgen_enable
26:19: lbstatus
18:11: vstatustester
10:   intr0_cause_bistdone_done
9:   intr0_cause_pll_run_away_sticky_change_done
8:   intr0_cause_test_pll_run_away_sticky_change_done
7:   0
6:   0
5:   test_pll_lock
4:   pll_lock
3:   test_pll_dft
2:   pll_dft
1:0:   afe_ddft</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DDFT0_POLARITY</name>
                <description>0 - Observed DDFT output is not inverted
1 - DDFT output is inverted</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DDFT1_SEL</name>
                <description>77                       controlled_oncal,
76                        controlled_cal_f1,
75                       controlled_cal_f2,
74                        controlled_hs_pree_en,
73                        controlled_conn_rpu1,
72                        controlled_conn_rpu2,
71                        controlled_hs_ded_en,
70                       controlled_hs_ded_reset,
69                        controlled_hs_ded_start,
68                       controlled_rpu_sel,
67                        controlled_ls_nfs,
66                       controlled_lsfs_diff_rx_en,
65                        controlled_conn_rpd_dp,
64                        controlled_conn_rpd_dn,
63                        controlled_iref_en,
62                        controlled_hs_rx_en,
61                        controlled_hs_rx_buf_on,
60                        controlled_hs_ted_en,
59                        controlled_hs_tx_en_slow,
58                        controlled_se_rx_en_dp,
57                        controlled_se_rx_en_dn,
56                        controlled_lfs_tx_en,
55                        controlled_lfs_tx_in,
54                        controlled_lfs_tx_on,
53                        controlled_enase0,
52                        eusb_onlfsserec, 
51                       controlled_enase1,
50                        controlled_se_tx_in_edn,
49                        controlled_se_tx_en_edn,
48:47                       increase_ted_threshold[1:0],
46                        irefgen_bypass_mode,
45 PLL_SUPPLY_EN
44 PLL_EN
43 AFE hs_ted_out
42 AFE cal_out
41 AFE se_rx_out_dn/se_rx_out_edn
40  AFE se_rx_out_dp/se_rx_out_edp
39  AFE hs_rx_out
38 AFE hs_ded_out
37 AFE lsfs_diff_rx_out
36 AFE stress_out
35 s40usb2afe_reg_2p5.ok_v25_vccd
34 s40usb2afe_reg_1p1.ok_vhs_vccd
33 0
32: PLL clockoutput per PLL_CONTROL2.PLL_CLKOUT_DDFT_SEL
31: reg_sw_1p2_control_enable_lv,
30: reg_2p5_control_enable_lv,
29: vrefgen_control_enable_lv
28: regulator_1p1_enable
27: irefgen_enable
26:19: lbstatus
18:11: vstatustester
10:   intr0_cause_bistdone_done
9:   intr0_cause_pll_run_away_sticky_change_done
8:   intr0_cause_test_pll_run_away_sticky_change_done
7:   0
6:   0
5:   test_pll_lock
4:   pll_lock
3:   test_pll_dft
2:   pll_dft
1:0:   afe_ddft</description>
                <bitRange>[14:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DDFT1_POLARITY</name>
                <description>0 - Observed DDFT output is not inverted
1 - DDFT output is inverted</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DIGITAL_CONTROL</name>
            <description>Provides control and configuration to digital blocks</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x120</resetValue>
            <resetMask>0xEFFF7FEF</resetMask>
            <fields>
              <field>
                <name>DLAUNCH_SEL</name>
                <description>selects pre-emphasis phase
0: Pre-emphasis disabled
1: pll phase 2
2: pll phase 4
3: pll phase 6</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_CLOCK_SOURCE_DFT</name>
                <description>Selects the source of TX clock.
0: TX clock source is the Primary of primary PLL,
1: TX clock source is the test PLL 
This bit should be set when loopback is enabled if the CDR is to be validated</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CLK480_PHASE_SEL</name>
                <description>Selects which phase of PLL to use as the TX clock for the PHY
0: selects phase 0
1: selects phase 4</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DLAUNCH_ON_DELAY</name>
                <description>This field controls the delay from assertion of hs_tx_en_fast to assertion of hs_dum_sr_sel. The actual delay applied is DLAUNCH_ON_DELAY+1</description>
                <bitRange>[7:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DLAUNCH_OFF_DELAY</name>
                <description>N/A</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BURN_IN_EN</name>
                <description>Enables Burn-in Mode</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BURN</name>
                <description>2p5 Regulator Burn-in Output Voltage Select</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIS_PRE_EMPHASIS_HS_SOF</name>
                <description>Setting this bit to 1 disables the PRE_EMPHASIS during the EOP of an SOF packet. The bit position at which the pre-emphasis is disabled is determined by BIT_TIME_DIS_PRE_EMPHASIS</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BIT_TIME_DIS_PRE_EMPHASIS</name>
                <description>The 40-bit EOP counter is designed as two counter of 3-bits each to meet 480MHZ timing
A 3-bit counter counts every 6 bits and another every 6-bit word (x6)
The counters cycle through values as follows 0,4,6,7,3,1 - starting with 0
This field specifies the bit position, 
[21:19] specify the word and [18:16] specify the bit in the word</description>
                <bitRange>[21:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTROL_HS_TX_IN</name>
                <description>1: The hs_tx_in_dp/hs_tx_in_dn output ports of D-Launch block
     will be driven by the HX_TX_IN_DP_VALUE/HX_TX_IN_DN_VALUE
0: The hs_tx_in_dp/hs_tx_in_dn will be driven by D-launch logic</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HX_TX_IN_DP_VALUE</name>
                <description>When CONTROL_HS_TX_IN is set, hs_tx_in_dp output port of D-Launch
block is driven by this register, otherwise it is driven by the D-Luanch logic.</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HX_TX_IN_DN_VALUE</name>
                <description>When CONTROL_HS_TX_IN is set, hs_tx_in_dn output port of D-Launch
block is driven by this register, otherwise it is driven by the D-Luanch logic.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTROL_HS_TX_PREE</name>
                <description>1: The hs_tx_pree_dp/hs_tx_pree_dn output ports of D-Launch block
     will be driven by the HX_TX_PREE_DP_VALUE/HX_TX_PREE_DN_VALUE
0: The hs_tx_pree_dp/hs_tx_pree_dn will be driven by D-launch logic</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HX_TX_PREE_DP_VALUE</name>
                <description>When CONTROL_HS_TX_PREE is set, hs_tx_pree_dp output port of D-Launch
block is driven by this register, otherwise it is driven by the D-Luanch logic.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HX_TX_PREE_DN_VALUE</name>
                <description>When CONTROL_HS_TX_PREE is set, hs_tx_pree_dn output port of D-Launch
block is driven by this register, otherwise it is driven by the D-Luanch logic.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLE_POWER_SAVING_CDR_CLK480M</name>
                <description>This bit disables the dynamic clock gating on CDR clock .</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLE_POWER_SAVING_UTMI_HSRX_CLK480M</name>
                <description>This bit disables the dynamic clock gating on UTMI RX clock</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLE_POWER_SAVING_UTMI_HSTX_CLK480M</name>
                <description>This bit disables the dynamic clock gating on UTMI TX clock</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>VREFGEN_CONTROL</name>
            <description>VREFGEN control</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x801FFFFF</resetMask>
            <fields>
              <field>
                <name>TED_SEL_0</name>
                <description>TED Threshold Select for vref_ted_hi&lt;0&gt;</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TED_SEL_1</name>
                <description>TED Threshold Select for vref_ted_hi&lt;1&gt;</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DED_SEL_0</name>
                <description>DED Threshold Select for vref_ded&lt;0&gt;</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DED_SEL_1</name>
                <description>DED Threshold Select for vref_ded&lt;1&gt;</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREFGEN_ADFT_CTRL</name>
                <description>Analog DFT mode slection bits</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREFGEN_ADFT_EN</name>
                <description>Analog DFT master enable</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE_LV</name>
                <description>Vrefgen block enable</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>REG_SW_1P2_CONTROL</name>
            <description>REG_SW_1P2 control</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x8000003F</resetMask>
            <fields>
              <field>
                <name>SW_ADFT_CTRL</name>
                <description>analog DFT mode slection bits</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SW_ADFT_EN</name>
                <description>analog DFT master enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>USE_REG</name>
                <description>Indicator that selects vout_1p2 driver:
0: regulator
1: switch</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE_LV</name>
                <description>Regulator block enable</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>REG_1P1_CONTROL</name>
            <description>REG_1P1 control</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x8000011F</resetMask>
            <fields>
              <field>
                <name>ONEP1_ADFT_CTRL</name>
                <description>analog DFT mode slection bits</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ONEP1_ADFT_EN</name>
                <description>analog DFT master enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SWITCH_EN</name>
                <description>Indicator that selects vout_1p1 driver:
0: regulator
1: switch</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE_LV</name>
                <description>Regulator block enable</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>REG_2P5_CONTROL</name>
            <description>REG_2P5_ control</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x8000011F</resetMask>
            <fields>
              <field>
                <name>TWOP5_ADFT_CTRL</name>
                <description>analog DFT mode slection bits</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TWOP5_ADFT_EN</name>
                <description>analog DFT master enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BYPASS_MODE</name>
                <description>When set the 2.5V regulator is bypassed to 3V3 supply.This bit has to be set to allow Deepsleep in Suspend mode</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE_LV</name>
                <description>Regulator block enable</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IREFGEN_CONTROL</name>
            <description>IREFGEN_ control</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x8000011F</resetMask>
            <fields>
              <field>
                <name>IREF_ADFT_CTRL</name>
                <description>analog DFT mode slection bits</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IREF_ADFT_EN</name>
                <description>analog DFT master enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BYPASS_MODE</name>
                <description>When set vref/iref to PLL is generated from 3.3 supply and not SRSS vref.
Forced to 1 in SCAN_TDF mode</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE_LV</name>
                <description>Irefgen block enable</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Status</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FFFFFD</resetMask>
            <fields>
              <field>
                <name>PLL_LOCK</name>
                <description>Live status of pll.pll_lock</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TEST_PLL_LOCK</name>
                <description>Live status of test_pll.pll_lock</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VSTATUSTESTER</name>
                <description>Refer to TEST_CONTROL.VCONTROL</description>
                <bitRange>[10:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LBSTATUS</name>
                <description>17: reginprogress
16: error
15: startbist
14: bistdone
13: txready
12: txvalid
11: rxactive
10: rxerror</description>
                <bitRange>[18:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LINE_STATE</name>
                <description>Current state of single ended D+/D- receivers. Used in production test</description>
                <bitRange>[20:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HOST_DISCONNECT</name>
                <description>Indicates Peripheral disconnect detection. Only valid if dppulldown and dmpulldown signals are '1'. In UHC, all the DS Ports dppulldown and dmpulldown are tied to '1'. Hence this bit is valid only for DS ports and invalid for US port. So named to keep UTMO spec compatibility, should have been named DEVICE_DISCONNECT otherwise.
0: Device Connected
1: Device Disconnect Detected
This signal is the output from the UTMI+ PHY. During reset, the value resets to 0 and reflects the current status of the ports  TDIS ot TCONN after reset is deasserted, typically in 2.5us.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PLL_LOSS_CNT</name>
                <description>Count of PLL lossing lock</description>
                <bitRange>[25:22]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BISTOK</name>
                <description>This bit should be read after INTR0.BISTDONE
0: BIST failed
1: BIST passed</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR0</name>
            <description>INTR0 Cause.  These are the wakeup interrupts get reflected on interrupt_wakeup pin.</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FF</resetMask>
            <fields>
              <field>
                <name>PLL_LOCK</name>
                <description>PLL is locked</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PLL_LOSS</name>
                <description>PLL lost lock.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_PLL_LOCK</name>
                <description>test_pll.pll_lock</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PLL_RUN_AWAY_STICKY_CHANGE</name>
                <description>pll.pll_run_away_sticky</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_PLL_RUN_AWAY_STICKY_CHANGE</name>
                <description>pll.pll_run_away_sticky</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE_VCCD</name>
                <description>s40usb2afe_reg_2p5.ok_v25_vccd is detected</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE_HS_VCCD</name>
                <description>s40usb2afe_reg_1p1.ok_vhs_vccd is detected</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BISTDONE</name>
                <description>Bist is done if BIST_CONTINOUS_EN is 0.
Status of BIST is BISTOK STATUS register</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERRORFLOW</name>
                <description>Elasticity buffer overflow error indicator</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STRESS_OUT</name>
                <description>Over-voltage stress event detected on the dp or dn pins</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CAL_DONE</name>
                <description>Calibration Complete</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR0_SET</name>
            <description>INTR0 Set</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FF</resetMask>
            <fields>
              <field>
                <name>PLL_LOCK</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PLL_LOSS</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_PLL_LOCK</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PLL_RUN_AWAY_STICKY_CHANGE</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_PLL_RUN_AWAY_STICKY_CHANGE</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE_VCCD</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE_HS_VCCD</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BISTDONE</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERRORFLOW</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STRESS_OUT</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CAL_DONE</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR0_MASK</name>
            <description>INTR0 Mask</description>
            <addressOffset>0x4C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FF</resetMask>
            <fields>
              <field>
                <name>PLL_LOCK_MASK</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PLL_LOSS_MASK</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_PLL_LOCK_MASK</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PLL_RUN_AWAY_STICKY_CHANGE_MASK</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_PLL_RUN_AWAY_STICKY_CHANGE_MASK</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE_VCCD_MASK</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE_HS_VCCD_MASK</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BISTDONE_MASK</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERRORFLOW_MASK</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STRESS_OUT_MASK</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CAL_DONE_MASK</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR0_MASKED</name>
            <description>INTR0 Masked</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FF</resetMask>
            <fields>
              <field>
                <name>PLL_LOCK_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PLL_LOSS_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TEST_PLL_LOCK_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PLL_RUN_AWAY_STICKY_CHANGE_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TEST_PLL_RUN_AWAY_STICKY_CHANGE_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ENABLE_VCCD_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ENABLE_HS_VCCD_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BISTDONE_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ERRORFLOW_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>STRESS_OUT_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CAL_DONE_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SPARE</name>
            <description>Spare</description>
            <addressOffset>0x54</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFF000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DFT</name>
                <description>Spare</description>
                <bitRange>[11:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SPARE0</name>
                <description>Spare with default 0</description>
                <bitRange>[23:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE1</name>
                <description>Spare with default 1</description>
                <bitRange>[31:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>AFE_CONTROL_3</name>
            <description>AFE Control register #3</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CONTROL_CONN_RPD</name>
                <description>1: The conn_rpd_dp/conn_rpd_dn input ports of AFE block
     will be driven by the CONN_RPD_DP_VALUE/CONN_RPD_DN_VALUE
0: The conn_rpd_dp/conn_rpd_dn will be driven by logic</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONN_RPD_DP_VALUE</name>
                <description>When CONTROL_CONN_RPT is set, conn_rpd_dp input port of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONN_RPD_DN_VALUE</name>
                <description>When CONTROL_CONN_RPT is set, conn_rpd_dn input port of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTROL_CONN_RPU</name>
                <description>1: The conn_rpu1/conn_rpu2 input ports of AFE block
     will be driven by the CONN_RPU1_VALUE/CONN_RPU2_VALUE
0: The conn_rpu1/conn_rpu2 will be driven by logic</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONN_RPU1_VALUE</name>
                <description>When CONTROL_CONN_RPU is set, conn_rpu1 input port of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONN_RPU2_VALUE</name>
                <description>When CONTROL_CONN_RPU is set, conn_rpu2 input port of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTROL_HS_DED</name>
                <description>1: The hs_ded_en/hs_ded_reset/hs_ded_start input ports of AFE block
     will be driven by the HS_DED_EN_VALUE/HS_DED_RESET_VALUE/HS_DED_START_VALUE
0: The hs_ded_en/hs_ded_reset/hs_ded_start will be driven by logic</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HS_DED_EN_VALUE</name>
                <description>When CONTROL_HS_DED is set, hs_ded_en input ports of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HS_DED_RESET_VALUE</name>
                <description>When CONTROL_HS_DED is set, hs_ded_reset input port of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HS_DED_START_VALUE</name>
                <description>When CONTROL_HS_DED is set, chs_ded_start input port of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTROL_IREF_EN</name>
                <description>1: The iref_en input ports of AFE block will be driven by the IREF_EN_VALUE
0: The iref_en will be driven by logic</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IREF_EN_VALUE</name>
                <description>When CONTROL_IREF_EN is set, iref_en input ports of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTROL_HS_RX_EN</name>
                <description>1: The hs_rx_en input ports of AFE block will be driven by the HS_RX_EN_VALUE
0: The hs_rx_en will be driven by logic</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HS_RX_EN_VALUE</name>
                <description>When CONTROL_HS_RX_EN is set, hs_rx_en input ports of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTROL_HS_RX_BUF_ON</name>
                <description>1: The hs_rx_buf_on input ports of AFE block will be driven by the HS_RX_BUF_ON_VALUE
0: The hs_rx_buf_on will be driven by logic</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HS_RX_BUF_ON_VALUE</name>
                <description>When CONTROL_HS_RX_BUF_ON is set, hs_rx_buf_on input ports of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTROL_HS_TED_EN</name>
                <description>1: The hs_ted_en input ports of AFE block will be driven by the HS_TED_EN_VALUE
0: The hs_ted_en will be driven by logic</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HS_TED_EN_VALUE</name>
                <description>When CONTROL_HS_TED_EN is set, hs_ted_en input ports of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTROL_HS_TX_EN_SLOW</name>
                <description>1: The hs_tx_en_slow input ports of AFE block will be driven by the HS_TX_EN_SLOW_VALUE
0: The hs_tx_en_slow will be driven by logic</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HS_TX_EN_SLOW_VALUE</name>
                <description>When CONTROL_HS_TX_EN_SLOW is set, hs_tx_en_slow input ports of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTROL_RPU_SEL</name>
                <description>1: The rpu_sel input ports of AFE block will be driven by the RPU_SEL_VALUE
0: The rpu_sel will be driven by logic</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RPU_SEL_VALUE</name>
                <description>When CONTROL_RPU_SEL is set, rpu_sel input ports of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTROL_SE_RX_EN_DP</name>
                <description>1: The se_rx_en_dp input ports of AFE block will be driven by the SE_RX_EN_DP_VALUE
0: The se_rx_en_dp will be driven by logic</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SE_RX_EN_DP_VALUE</name>
                <description>When CONTROL_SE_RX_EN_DP is set, se_rx_en_dp input ports of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTROL_SE_RX_EN_DN</name>
                <description>1: The se_rx_en_dn input ports of AFE block will be driven by the SE_RX_EN_DN_VALUE
0: The se_rx_en_dn will be driven by logic</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SE_RX_EN_DN_VALUE</name>
                <description>When CONTROL_SE_RX_EN_DN is set, se_rx_en_dn input ports of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTROL_LS_NFS</name>
                <description>1: The ls_nfs input ports of AFE block will be driven by the LS_NFS_VALUE
0: The ls_nfs will be driven by logic</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LS_NFS_VALUE</name>
                <description>When CONTROL_LS_NFS is set, ls_nfs input ports of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTROL_LSFS_DIFF_RX_EN</name>
                <description>1: The lsfs_diff_rx_en input ports of AFE block will be driven by the LSFS_DIFF_RX_EN_VALUE
0: The lsfs_diff_rx_en will be driven by logic</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LSFS_DIFF_RX_EN_VALUE</name>
                <description>When CONTROL_LSFS_DIFF_RX_EN is set, lsfs_diff_rx_en input ports of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTROL_LFS_TX_EN</name>
                <description>1: The lfs_tx_en input ports of AFE block will be driven by the LFS_TX_EN_VALUE
0: The lfs_tx_en will be driven by logic</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LFS_TX_EN_VALUE</name>
                <description>When CONTROL_LFS_TX_EN is set, lfs_tx_en input ports of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>AFE_CONTROL_4</name>
            <description>AFE Control register #4</description>
            <addressOffset>0x5C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CONTROL_LFS_TX_IN</name>
                <description>1: The lfs_tx_in input ports of AFE block will be driven by the LFS_TX_IN_VALUE
0: The lfs_tx_in will be driven by logic</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LFS_TX_IN_VALUE</name>
                <description>When CONTROL_LFS_TX_IN is set, lfs_tx_in input ports of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTROL_LFS_TX_ON</name>
                <description>1: The lfs_tx_on input ports of AFE block will be driven by the LFS_TX_ON_VALUE
0: The lfs_tx_on will be driven by logic</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LFS_TX_ON_VALUE</name>
                <description>When CONTROL_LFS_TX_ON is set, lfs_tx_on input ports of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTROL_ENASE0</name>
                <description>1: The enase0 input ports of AFE block will be driven by the ENASE0_VALUE
0: The enase0 will be driven by logic</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENASE0_VALUE</name>
                <description>When CONTROL_ENASE0 is set, enase0 input ports of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTROL_ENASE1</name>
                <description>1: The enase1 input ports of AFE block will be driven by the ENASE1_VALUE
0: The enase0 will be driven by logic</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENASE1_VALUE</name>
                <description>When CONTROL_ENASE1 is set, enase1 input ports of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTROL_CAL</name>
                <description>1: The cal/oncal/cal_f1/cal_f2 input ports of AFE block will be driven by the 
     CAL_VALUE, ONCAL_VALUE, CAL_F1_VALUE, CAL_F2_VALUE
0: The cal/oncal/cal_f1/cal_f2 will be driven by logic</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CAL_VALUE</name>
                <description>When CONTROL_CAL is set, cal input ports of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[13:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ONCAL_VALUE</name>
                <description>When CONTROL_CAL is set, cal input ports of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CAL_F1_VALUE</name>
                <description>When CONTROL_CAL is set, cal input ports of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CAL_F2_VALUE</name>
                <description>When CONTROL_CAL is set, cal input ports of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTROL_SE_TX_IN_EDN</name>
                <description>1: The se_tx_in_edn input ports of AFE block will be driven by the SE_TX_IN_EDN_VALUE
0: The se_tx_in_edn will be driven by logic</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SE_TX_IN_EDN_VALUE</name>
                <description>When CONTROL_SE_TX_IN_EDN is set, se_tx_in_edn input ports of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTROL_SE_TX_EN_EDN</name>
                <description>1: The se_tx_en_edn input ports of AFE block will be driven by the SE_TX_EN_EDN_VALUE
0: The se_tx_en_edn will be driven by logic</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SE_TX_EN_EDN_VALUE</name>
                <description>When CONTROL_SE_TX_EN_EDN is set, se_tx_en_edn input ports of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTROL_HS_PREE_EN</name>
                <description>1: The hs_pree_en input ports of AFE block will be driven by the HS_PREE_EN_VALUE
0: The hs_pree_en will be driven by logic</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HS_PREE_EN_VALUE</name>
                <description>When CONTROL_HS_PREE_EN is set, hs_pree_en input ports of AFE block
block is driven by this register, otherwise it is driven by logic.</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTROL_HS_TERM_EN</name>
                <description>1: hs_term_en input ports of USB2 AFE will be driven by HS_TERM_EN_VALUE
0:Controlled by logic</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HS_TERM_EN_VALUE</name>
                <description>When CONTROL.HS_TERM_EN is set, hs_term_en input of USB2 AFE is driven by this register</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTROL_HS_TX_EN</name>
                <description>1: HS Tranmit control signals are generated in dlaunch based on HS_TX_EN_VALUE and HS_TX_EN_FAST_VALUE
0:Controlled by logic</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HS_TX_EN_VALUE</name>
                <description>When CONTROL.HS_TX_EN is set, the AFE hs_tx_en_n signal is controlled from this filed through dlaunch</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HS_TX_EN_FAST_VALUE</name>
                <description>1: *dum* ports of the AFE are controlled in dlaunch through this field
0:Controlled by logic</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTMI_CONTROL_2</name>
            <description>UTMI Configurtation Registers</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x809C21</resetValue>
            <resetMask>0xFFFFFF</resetMask>
            <fields>
              <field>
                <name>DED_RESET_ASSERT_X6_BIT</name>
                <description>To detect HS disconnect 2 signals reset and start are generated during the 40-bit of the EOP
The 40-bit EOP counter is designed as two counter of 3-bits each to meet 480MHZ timing
A 3-bit counter counts every 6 bits and another every 6-bit word (x6)
The counters cycle through values as follows 0,4,6,7,3,1 - starting with 0
This field specifies the word position at which RESET is asserted - currently set to 32nd bit of EOP</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DED_RESET_ASSERT_BIT</name>
                <description>This filed specifies the bit position at which RESET is asserted - current set to 32nd bit of EOP</description>
                <bitRange>[5:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DED_RESET_DEASSERT_X6_BIT</name>
                <description>This field specifies the word position at which RESET is deasserted - currently set to 39th bit of EOP</description>
                <bitRange>[8:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DED_RESET_DEASSERT_BIT</name>
                <description>This filed specifies the bit position at which RESET is deasserted - current set to 39th bit of EOP</description>
                <bitRange>[11:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DED_START_ASSERT_X6_BIT</name>
                <description>This filed specifies the bit position at which START is asserted - current set to 36th bit of EOP</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DED_START_ASSERT_BIT</name>
                <description>This filed specifies the bit position at which START is asserted - current set to 36th bit of EOP</description>
                <bitRange>[17:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DED_START_DEASSERT_X6_BIT</name>
                <description>This field specifies the word position at which START is deasserted - currently set to 38th bit of EOP</description>
                <bitRange>[20:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DED_START_DEASSERT_BIT</name>
                <description>This filed specifies the bit position at which START is deasserted - current set to 38th bit of EOP</description>
                <bitRange>[23:21]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PLL_TRIMS</name>
            <description>Trim register for the PLL</description>
            <addressOffset>0xF0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x92A4A</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>RUN_AWAY</name>
                <description>PLL Run away detector level trim</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CP_CUR</name>
                <description>PLL Trim option for analog charge pump</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LDO_VCO</name>
                <description>PLL LDO VCO voltage trim</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LDO_CORE</name>
                <description>PLL Spare bits - unused</description>
                <bitRange>[9:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_RUN_AWAY</name>
                <description>TEST PLL Run away detector level trim</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_CP_CUR</name>
                <description>TEST PLL Trim option for analog charge pump</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_LDO_VCO</name>
                <description>TEST PLL LDO VCO voltage trim</description>
                <bitRange>[16:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_LDO_CORE</name>
                <description>TEST PLL Spare bits - unused</description>
                <bitRange>[19:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>AFE_TRIMS</name>
            <description>Trim register for the AFE</description>
            <addressOffset>0xF4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRIM_VREF</name>
                <description>Vrefgen - Trim output reference voltage level</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM_IREF</name>
                <description>Irefgen - Trim output reference current level</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM_VREG_2P5</name>
                <description>2p5 Regulator output votlage trim control</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM_VREG_1P1</name>
                <description>1p1 Regulator output votlage trim control</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM_REG_SW_1P2</name>
                <description>1p2 Regulator output votlage trim control</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM_AFE_HS_IREF</name>
                <description>High Speed Transmit Current Source Trim</description>
                <bitRange>[22:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM_VREF_600M_0</name>
                <description>Voltage Select for vref_600m&lt;0&gt;</description>
                <bitRange>[26:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM_VREF_600M_1</name>
                <description>Voltage Select for vref_600m&lt;1&gt;</description>
                <bitRange>[30:27]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>SCB0</name>
      <description>Serial Communications Block (SPI/UART/I2C)</description>
      <headerStructName>SCB</headerStructName>
      <baseAddress>0x40500000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Generic control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x300000F</resetValue>
          <resetMask>0x83031F0F</resetMask>
          <fields>
            <field>
              <name>OVS</name>
              <description>N/A</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_AM_MODE</name>
              <description>This field specifies the clocking for the address matching (I2C slave) or slave selection detection logic (SPI slave)
'0': Internally clocked mode 
'1': Externally clocked mode 

In internally clocked mode the address detection(and slave selection detection) is done by clk_scb, and thus won't be done in deep sleep power mode as clk_scb isn't active. 
In externally clocked mode the address detection is done by the I2C/SPI interface clock. This allows for the device to be awoken on I2C salve address match and SPI slave select assertion.

The clocking for the rest of the logic is determined by CTRL.EC_OP_MODE.

Externally clocked mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported.

In UART mode this field must be '0'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_OP_MODE</name>
              <description>This field specifies the clocking for the SCB block after the address phase
'0': Internally clocked mode 
'1': externally clocked mode

In internally clocked mode, the serial interface protocols run off the clk_scb. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface. 

Externally clocked operation mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported. 

In UART mode this field must be '0'.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_MODE</name>
              <description>This field determines if EZ mode is enabled or disabled for the SCB block
'0': EZ Mode Disabled
'1': EZ Mode Enabled

In EZ mode, a meta protocol is applied to the serial interface protocol. This meta protocol adds meaning to the data frames transferred by the serial interface protocol: a data frame can represent a memory address, a write memory data element or a read memory data element. 

EZ mode can only be used for synchronous  serial interface protocols (SPI and I2C) in slave mode. 

In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported. The external master should use continuous data frames; i.e. data frames not seperated by slave deselection.  

In EZ mode, data frames should 8-bit in size and should be transmitted and received with the Most Significant Bit (MSB) first.

In UART mode this field must be '0'.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTE_MODE</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_RESP_MODE</name>
              <description>Determines CMD_RESP mode of operation:
'0': CMD_RESP mode disabled.
'1': CMD_RESP mode enabled (also requires EC_AM_MODE and EC_OP_MODE to be set to '1').

In CMD_RESP mode, a meta protocol is applied to the serial interface protocol. This meta protocol adds meaning to the data frames transferred by the serial interface protocol: a data frame can represent  a write memory data element or a read memory data element. The difference from EZ mode is that the address is written by the CPU, not the interface master.

CMD_RESP mode can only be used for synchronous  serial interface protocols (SPI and I2C) in slave mode. 

In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported. The external master should use continuous data frames; i.e. data frames not seperated by slave deselection.  

In CMD_RESP mode, data frames should 8-bit in size and should be transmitted and received with the Most Significant Bit (MSB) first.

In UART mode this field must be '0'.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_ACCEPT</name>
              <description>Determines whether a received matching address is accepted in the RX FIFO:.
'0': Matching address does not go in RX FIFO
'1': Match address does go in RX FIFO

In I2C mode, this field is used to allow the slave to put the received slave address or general call address in the RX FIFO. Note that a received matching address is put in the RX FIFO when this bit is '1' for both I2C read and write transfers.

In multi-processor UART receiver mode, this field is used to allow the receiver to put the received address in the RX FIFO. 

Note: non-matching addresses are never put in the RX FIFO. 

In SPI mode this field must be '0'</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK</name>
              <description>Only used in externally clocked mode. If the externally clocked logic and the CPU access the EZ memory at the same time this bit determines whether a CPU access should block and result in bus wait states 
'0': Do not block, but ingore a write and return 0xffff:ffff for a read
'1': Block, resulting in CPU wait states. 

If BLOCK is '0' and the accesses collide, CPU read operations return 0xffff:ffff and CPU write operations are ignored. Colliding accesses are registered as interrupt causes: field BLOCKED of the INTR_TX and INTR_RX registers.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>I2C</name>
                  <description>Inter-Integrated Circuits (I2C) mode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI</name>
                  <description>Serial Peripheral Interface (SPI) mode.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART</name>
                  <description>Universal Asynchronous Receiver/Transmitter (UART) mode.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>0': Block Disabled
'1': Block Enabled

The proper order in which to initialize the SCB is as follows:
- Program protocol specific information using SPI_CTRL, UART_CTRL (and UART_TX_CTRL and UART_RX_CTRL) or I2C_CTRL. This includes selection of a submode, master/slave functionality and transmitter/receiver functionality when applicable.
- Program generic transmitter (TX_CTRL) and receiver (RX_CTRL) information. This includes enabling of the transmitter and receiver functionality.
- Program transmitter FIFO (TX_FIFO_CTRL) and receiver FIFO (RX_FIFO_CTRL) information.
- Program CTRL to enable SCB, select the specific operation mode and oversampling factor.
When the SCB is enabled, no control information should be changed. Changes must be made AFTER disabling the SCB, e.g. to modify the operation mode (from I2C to SPI) or to go from externally to internally clocked. The change takes effect after the SCB is re-enabled. Note that disabling the SCB will cause re-initialization of the design and associated state is lost (e.g. FIFO content).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Generic status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>EC_BUSY</name>
              <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory (this is only possible in EZ and CMD_RESP mode). This bit can be used by SW to determine whether it is safe for the CPU to access the EZ memory (without bus wait states (a blocked CPU access) or bus errors being generated). Note that the INTR_TX.BLOCKED and INTR_RX.BLOCKED interrupt causes are used to indicate whether CPU access was actually blocked by externally clocked logic.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_CTRL</name>
          <description>Command/response control</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FF01FF</resetMask>
          <fields>
            <field>
              <name>BASE_RD_ADDR</name>
              <description>I2C/SPI read base address for CMD_RESP mode. At the start of a read transfer this BASE_RD_ADDR is copied to CMD_RESP_STATUS.CURR_RD_ADDR. This field should not be modified during ongoing bus transfers.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BASE_WR_ADDR</name>
              <description>I2C/SPI write base address for CMD_RESP mode. At the start of a write transfer this BASE_WR_ADDR is copied to CMD_RESP_STATUS.CURR_WR_ADDR. This field should not be modified during ongoing bus transfers.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_STATUS</name>
          <description>Command/response status</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>CURR_RD_ADDR</name>
              <description>I2C/SPI read current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address). 

The field is used to determine how many bytes have been read (# bytes = CURR_RD_ADDR - CMD_RESP_CTRL.BASE_RD_ADDR). 

This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e. when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_WR_ADDR</name>
              <description>I2C/SPI write current address for CMD_RESP mode. HW increments the field after a write access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address).

The field is used to determine how many bytes have been written (# bytes = CURR_WR_ADDR - CMD_RESP_CTRL.BASE_WR_ADDR).

This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUS_BUSY</name>
              <description>Indicates whether there is an ongoing bus transfer to the SCB.
'0': no ongoing bus transfer.
'1': ongoing bus transfer.

For SPI, the field is '1' when slave mode is selected.

For I2C, the field is set to '1' at a I2C START/RESTART. In case of an address match, the  field is set to '0' on a I2C STOP. In case of NO address match, the field is set to '0' after the failing address match.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUSY</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_CTRL</name>
          <description>SPI control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000000</resetValue>
          <resetMask>0x8F010F3F</resetMask>
          <fields>
            <field>
              <name>SSEL_CONTINUOUS</name>
              <description>Continuous SPI data transfers enabled ('1') or not ('0'). This field is used in master mode. In slave mode, both continuous and non-continuous SPI data transfers are supported independent of this field.

When continuous transfers are enabled indiviual data transfers are NOT seperated by slave select deselection as long as there is data in the TX FIFO. If the TX FIFO becomes empty then the slave select will be deselected. 

When continuous transfers are not enabled individual data frame transfers are always seperated by slave select deselection: independent of the availability of TX FIFO data frames.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SELECT_PRECEDE</name>
              <description>Only used in SPI Texas Instruments' submode.

When '1', the data frame start indication is a pulse on the Slave SELECT line that precedes the transfer of the first data frame bit.

When '0', the data frame start indication is a pulse on the Slave SELECT line that coincides with the transfer of the first data frame bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHA</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPOL</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LATE_MISO_SAMPLE</name>
              <description>Changes the SCLK edge on which MISO is captured. Only used in master mode.

When '0', the default applies (
for Motorola as determined by CPOL and CPHA, 
for Texas Instruments on the falling edge of SCLK and 
for National Semiconductors on the rising edge of SCLK). 

When '1', the alternate clock edge is used (which comes half a SPI SCLK period later). Late sampling addresses the round trip delay associated with transmitting SCLK from the master to the slave and transmitting MISO from the slave to the master.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLK_CONTINUOUS</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY0</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY1</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY2</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY3</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). Only used in master mode. Not used in National Semiconductors submode.
'0': No local loopback
'1': the SPI master MISO line is connected to the SPI master MOSI line. In other words, in loopback mode the SPI master receives on MISO what it transmits on MOSI.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SPI_MOTOROLA</name>
                  <description>SPI Motorola submode. In master mode, when not transmitting data (SELECT is inactive), SCLK is stable at CPOL. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_TI</name>
                  <description>SPI Texas Instruments submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive; i.e. no pulse is generated.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_NS</name>
                  <description>SPI National Semiconductors submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>Selects one of the four incoming/outgoing SPI slave select signals:
- 0: Slave 0, SSEL[0].
- 1: Slave 1, SSEL[1].
- 2: Slave 2, SSEL[2].
- 3: Slave 3, SSEL[3].
The SCB should be disabled when changes are made to this field.</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_STATUS</name>
          <description>SPI status</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC_BUSY</name>
              <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_ADDR or CURR_ADDR (this is only possible in EZ and CMD_RESP mode). This bit can be used by the CPU to determine whether BASE_ADDR and CURR_ADDR are reliable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>SPI current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when SPI_EC_BUSY is '1').</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>SPI base EZ address. Address as provided by a SPI write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_CTRL</name>
          <description>UART control</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000000</resetValue>
          <resetMask>0x3010000</resetMask>
          <fields>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). 
0: Loopback is not enabled
1: UART_TX is connected to UART_RX. UART_RTS is connected to UART_CTS.
This allows a SCB UART transmitter to communicate with its receiver counterpart.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UART_STD</name>
                  <description>Standard UART submode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_SMARTCARD</name>
                  <description>SmartCard (ISO7816) submode. Support for negative acknowledgement (NACK) on the receiver side and retransmission on the transmitter side.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_IRDA</name>
                  <description>Infrared Data Association (IrDA) submode. Return to Zero modulation scheme.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_TX_CTRL</name>
          <description>UART transmitter control</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x137</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of half bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RETRY_ON_NACK</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_CTRL</name>
          <description>UART receiver control</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA0002</resetValue>
          <resetMask>0xF3777</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of half bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period. 

Note that in case of a stop bits error, the successive data frames may get lost as the receiver needs to resynchronize its start bit detection. The amount of lost data frames depends on both the amount of stop bits, the idle time between data frames and the data frame value.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY</name>
              <description>Inverts incoming RX line signal 'uart_rx_in'. Inversion is after local loopback. This functionality only works for IrDA receiver functionality.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_PARITY_ERROR</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_FRAME_ERROR</name>
              <description>Behaviour when an error is detected in a start or stop period. When '0', received data is sent to the RX FIFO. When '1', received data is dropped and lost.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MP_MODE</name>
              <description>Multi-processor mode. When '1', multi-processor mode is enabled. In this mode, RX_CTRL.DATA_WIDTH must be 9 bits. In multi-processor mode, the 9th received bit of a data frame seperates addresses (bit is '1') from data (bit is '0'). A received address is matched with RX_MATCH.DATA and RX_MATCH.MASK. In the case of a match, subsequent received data is sent to the RX FIFO. In the case of NO match, subsequent received data is dropped.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_MODE</name>
              <description>Only applicable in standard UART submode. When '1', the receiver performs break detection and baud rate detection on the incoming data. First, break detection counts the amount of bit periods that have a line value of '0'. BREAK_WIDTH specifies the minum required amount of bit periods. Successful break detection sets the INTR_RX.BREAK_DETECT interrupt cause to '1'. Second, baud rate detection counts the amount of peripheral clock periods that are use to receive the synchronization byte (0x55; least significant bit first). The count is available through UART_RX_STATUS.BR_COUNTER. Successful baud rate detection sets the INTR_RX.BAUD_DETECT interrupt cause to '1' (BR_COUNTER is reliable). This functionality is used to synchronize/refine the receiver clock to the transmitter clock. The receiver software can use the BR_COUNTER value to set the right clk_scb to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SKIP_START</name>
              <description>Only applicable in standard UART submode. When '1', the receiver skips start bit detection for the first received data frame. Instead, it synchronizes on the first received data frame bit, which should be a '1'. 

This functionality is intended for wake up from DeepSleep when receiving a data frame. The transition from idle ('1') to START ('0') on the RX line is used to wake up the CPU. The transition detection (and the associated wake up functionality) is performed by the GPIO. 

The woken up CPU will enable the SCB's UART receiver functionality. Once enabled, it is assumed that the START bit is ongoing (the CPU wakeup and SCB enable time should be less than the START bit period). The SCB will then synchronize to a '0' to '1' transition, which indicates the first data frame bit is received (first data frame bit should be '1'). After synchronization to the first data frame bit, the SCB will resume normal UART functionality: subsequent data frames will be synchronized on the receipt of a START bit.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_WIDTH</name>
              <description>Break width. BREAK_WIDTH + 1 is the minimum width in bit periods of a break. During a break the transmitted/received line value is '0'. This feature is useful for standard UART submode and LIN submode ('break field' detection). Once, the break is detected, the INTR_RX.BREAK_DETECT bit is set to '1'. 

Note for LIN the break detection precedes baud rate detection, which is used to synchronize/refine the receiver clock to the transmitter clock. As a result, break detection operates with an unsynchronized/unrefined receiver clock. Therefore, the receiver's definition of a bit period is imprecise and the setting of this field should take this imprecision into account. The LIN standard also accounts for this imprecision: a LIN start bit followed by 8 data bits allows for up to 9 consecutive '0' bit periods during regular transmission, whereas the LIN break detection should be at least 13 consecutive '0' bit periods. This provides for a margin of 4 bit periods. Therefore, the default value of this field is set to 10, representing a minimal break field with of 10+1 = 11 bit periods; a value in between the 9 consecutive bit periods of a regular transmission and the 13 consecutive bit periods of a break field. This provides for slight imprecisions of the receiver clock wrt. the transmitter clock. There should not be a need to program this field to any value other than its default value.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_STATUS</name>
          <description>UART receiver status</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BR_COUNTER</name>
              <description>For LIN: Amount of clk_scb periods that constitute the transmission of a 0x55 data frame (sent least signficant bit first) as determined by the receiver. BR_COUNTER / 8 is the amount of clk_scb periods that constitute a bit period. This field has valid data when INTR_RX.BAUD_DETECT is set to '1'.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_FLOW_CTRL</name>
          <description>UART flow control</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30100FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has less entries than the amount of this field, a Ready To Send (RTS) output signal is activated. By setting this field to '0', flow control is disabled</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_POLARITY</name>
              <description>Polarity of the RTS output signal:
'0': RTS is active low; 
'1': RTS is active high; 

During SCB reset (Hibernate system power mode), RTS output signal is '1'. This represents an inactive state assuming an active low polarity.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_POLARITY</name>
              <description>Polarity of the CTS input signal
'0': CTS is active low ; 
'1': CTS is active high;</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_ENABLED</name>
              <description>Enable use of CTS input signal by the UART transmitter:
'0': Disabled. The UART transmitter ignores the CTS input signal and transmits when a data frame is available for transmission in the TX FIFO or the TX shift register.
'1': Enabled. The UART transmitter uses CTS input signal to qualify the transmission of data. It transmits when CTS input signal is active and a data frame is available for transmission in the TX FIFO or the TX shift register.

If UART_CTRL.LOOPBACK is '1', the CTS input signal is driven by the RTS output signal locally in SCB (both signals are subjected to signal polarity changes as indicated by RTS_POLARITY and CTS_POLARITY).</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CTRL</name>
          <description>I2C control</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFB88</resetValue>
          <resetMask>0xC001FBFF</resetMask>
          <fields>
            <field>
              <name>HIGH_PHASE_OVS</name>
              <description>Serial I2C interface high phase oversampling factor. (HIGH_PHASE_OVS + 1) * clk_scb  constitutes the high phase of a bit period. The valid range is [5, 15] with input signal median filtering and [4, 15] without input signal median filtering.

The field is only used in master mode. In slave mode, the field is NOT used. See architecture TRM for information on slave data rate requirments.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOW_PHASE_OVS</name>
              <description>Serial I2C interface low phase oversampling factor. (LOW_PHASE_OVS + 1) * clk_scb constitutes the low phase of a bit period. The valid range is [7, 15] with input signal median filtering and [6, 15] without input signal median filtering. 

The field is only used in master mode. In slave mode, the field is NOT used. See architecture TRM for information on slave data rate requirments.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_READY_DATA_ACK</name>
              <description>When '1', a received data element by the master is immediately ACK'd when the RX FIFO is not full. When '0' the CPU is responsible for ACK/NACKing the received data frame using I2C_M_CMD.M_ACK or I2C_M_CMD.M_NACK</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NOT_READY_DATA_NACK</name>
              <description>When '1', a received data element by the master is immediately NACK'd when the RX FIFO is full. When '0', clock stretching is used instead (till the RX FIFO is no longer full).</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_GENERAL_IGNORE</name>
              <description>When '1', a received general call slave address is immediately NACK'd (no ACK or clock stretching) and treated as a non matching slave address. This is useful for slaves that do not need any data supplied within the general call structure.
When '0' the general call address is accepted and follows S_READY_ADDR_ACK and S_NOT_READY_ADDR_NACK</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_ADDR_ACK</name>
              <description>When '1', a received (matching) slave address is immediately ACK'd when the RX FIFO is not full. In EZ and CMD_RESP mode, this field should be set to '1'.
When '0' the address must be ACK/NACK'd by the CPU using I2C_S_CMD.S_ACK or I2C_S_CMD.S_NACK</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_DATA_ACK</name>
              <description>When '1', a received data element by the slave is immediately ACK'd when the RX FIFO is not full. In EZ and CMD_RESP mode, this field should be set to '1'.
When '0' the data must be ACK/NACK'd by the CPU using I2C_S_CMD.S_ACK or I2C_S_CMD.S_NACK</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_ADDR_NACK</name>
              <description>Only used for FIFO mode, NOT EZ or CMD_RESP mode.

Functionality is as follows:
- 1: In Active/Sleep mode a received (matching) slave address is immediately NACK'd when the RX FIFO is full
In DeepSleep power mode when EC_AM = '1' and EC_OP = '0' clk_scb is not avaliable, so the incoming address will be NACK'd until the clock is avaliable. Once clk_scb is avaliable the address ACK will follow S_READY_ADDR_ACK
- 0: in Active/Sleep mode clock stretching is performed when the RX FIFO is full, the strech is released when the RX FIFO is no longer full.
In DeepSleep power mode when  EC_AM = '1' and EC_OP = '0' clk_scb is not avaliable, so the clocked will be streched on an incoming address until clk_scb is avaliable. After clk_scb is avalaible the address ACK will follow S_READY_ADDR_ACK</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_DATA_NACK</name>
              <description>Only used for FIFO mode, NOT EZ or CMD_RESP mode.

Functionality is as follows:
- 1: a received data element byte the slave is immediately NACK'd when the receiver FIFO is full.
- 0: clock stretching is performed (till the receiver FIFO is no longer full).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). Only applicable in master/slave mode. 
When '0', no loopback
When '1', loopback is enabled internally in the peripheral, and as a result unaffected by other I2C devices. This allows a SCB I2C peripheral to address itself.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE_MODE</name>
              <description>N/A</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>Master mode enabled ('1') or not ('0'). Note that both master and slave modes can be enabled at the same time. This allows the SCB to address itself.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_STATUS</name>
          <description>I2C status</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x31</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>I2C bus is busy. The bus is considered busy ('1'), from the time a START is detected or from the time the SCL line is '0'. The bus is considered idle ('0'), from the time a STOP is detected. If the SCB is disabled, BUS_BUSY is '0'. After enabling the SCB, it takes time for the BUS_BUSY to detect a busy bus. This time is the maximum high time of the SCL line. For a 100 kHz interface frequency, this maximum high time may last roughly 5 us (half a bit period).

For single master systems, BUS_BUSY does not have to be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START (no bus collisions).

For multi-master systems, BUS_BUSY can be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START_ON_IDLE (to prevent bus collisions).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC_BUSY</name>
              <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_EZ_ADDR or CURR_EZ_ADDR (this is only possible in EZ and CMD_RESP mode). This bit can be used by the CPU to determine whether BASE_EZ_ADDR and CURR_EZ_ADDR are reliable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S_READ</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>M_READ</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>I2C slave current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when I2C_EC_BUSY is '1').</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>I2C slave base EZ address. Address as provided by an I2C write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_M_CMD</name>
          <description>I2C master command</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>M_START</name>
              <description>When '1', transmit a START or REPEATED START. 

Whether a START or REPEATED START is transmitted depends on the state of the master state machine. A START is only transmitted when the master state machine is in the default state. A REPEATED START is transmitted when the master state machine is not in the default state, but is working on an ongoing transaction. The REPEATED START can only be transmitted after a NACK or ACK has been received for a transmitted data element or after a NACK has been transmitted for a received data element. When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_START_ON_IDLE</name>
              <description>When '1', transmit a START as soon as the bus is idle (I2C_STATUS.BUS_BUSY is '0', note that BUSY has a default value of '0'). 

For bus idle detection the hardware relies on STOP detection. As a result, bus idle detection is only functional after at least one I2C bus transfer has been detected on the bus (default/reset value of BUSY is '0') . A START is only transmitted when the master state machine is in the default state. When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_ACK</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NACK</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_STOP</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_S_CMD</name>
          <description>I2C slave command</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>S_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'. In EZ and CMD_RESP mode, this field should be set to '0' (it is only to be used in FIFO mode).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NACK</name>
              <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.  In EZ and CMD_RESP mode, this field should be set to '0' (it is only to be used in FIFO mode). This command has a higher priority than I2C_S_CMD.S_ACK, I2C_CTRL.S_READY_ADDR_ACK or I2C_CTRL.S_READY_DATA_ACK.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CFG</name>
          <description>I2C configuration</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2A1013</resetValue>
          <resetMask>0x303F1313</resetMask>
          <fields>
            <field>
              <name>SDA_IN_FILT_TRIM</name>
              <description>Trim bits for 'i2c_sda_in' 50 ns filter. 

SDA_IN_FILT_TRIM[1] is used to enable I2CS_EC or SPIS_EC access to internal EZ memory.
1: enable clk_scb
0: disable clk_scb

Before going to deepsleep this field should be set to 0. It should be re-enabled once the device is awoken and clk_hf[0] is at the desired frequency.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_IN_FILT_SEL</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_TRIM</name>
              <description>Trim bits for 'i2c_scl_in' 50 ns filter. Not to be modified by the user</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_SEL</name>
              <description>N/A</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT0_TRIM</name>
              <description>Trim bits for 'i2c_sda_out' 50 ns filter 0.  Not to be modified by the user</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT1_TRIM</name>
              <description>Trim bits for 'i2c_sda_out' 50 ns filter 1. Not to be modified by the user</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT2_TRIM</name>
              <description>Trim bits for 'i2c_sda_out' 50 ns filter 2. Not to be modified by the user</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT_SEL</name>
              <description>N/A</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CTRL</name>
          <description>Transmitter control</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x107</resetValue>
          <resetMask>0x1010F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Dataframe width. DATA_WIDTH + 1 is the amount of bits in a transmitted data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7. In EZ and CMD_RESP mode (for both SPI and I2C), the only valid value is 7.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'. For EZ and CMD_RESP this field must be set to '1'</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OPEN_DRAIN</name>
              <description>Each IO cell 'xxx' has two associated SCB output signals 'xxx_out_en' and 'xxx_out'. This field determines how the SCB controls those two signals. Consult the GPIO chapter in the architecture TRM to understand how the pin drive modes behave when connected to SCBs.

'0': Normal operation mode. In this operation mode 'xxx_out_en' output enable signal is typically constant '1' the 'xxx_out' output is the outputted value. In other words, in normal operation mode, the 'xxx_out' output is used to control the IO cell output value: 'xxx_out' is '0' to drive an IO cell output value of '0' and 'xxx_out' is '1' to drive an IO cell output value of '1'.

'1': Open drain operation mode. In this operation mode 'xxx_out_en' output controls the outputted value. Typically the 'xxx_out' signal is a constant '0'. Thus when 'xxx_out_en' is '1' the line is driven low, but when 'xxx_out_en' is '0' the output is not driven. This requires that the line is driven high by an external device or pull-up resistor

The open drain mode is supported for:
- I2C mode this field must be set.
- UART mode use this mode when a pull-up resistor is used on the TX line. 
- SPI mode this field must be set if there are multiple slaves driving MISO.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_CTRL</name>
          <description>Transmitter FIFO control</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>N/A</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>N/A</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_STATUS</name>
          <description>Transmitter FIFO status</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF81FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>N/A</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>N/A</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>N/A</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>N/A</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_WR</name>
          <description>Transmitter FIFO write</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>N/A</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_CTRL</name>
          <description>Receiver control</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x107</resetValue>
          <resetMask>0x30F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>N/A</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'. For EZ and CMD_RESP this field must be set to '1'</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEDIAN</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_CTRL</name>
          <description>Receiver FIFO control</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>N/A</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>N/A</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_STATUS</name>
          <description>Receiver FIFO status</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF81FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>N/A</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>N/A</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>N/A</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>N/A</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_MATCH</name>
          <description>Slave address and mask</description>
          <addressOffset>0x310</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF00FF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK</name>
              <description>N/A</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD</name>
          <description>Receiver FIFO read</description>
          <addressOffset>0x340</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will remove the data frame from the FIFO; i.e. behavior is similar to that of a POP operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.

When in debug mode a read from this register behaves as a read from the SCB_RX_FIFO_RD_SILENT register. That is data will not be removed from the FIFO

A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD_SILENT</name>
          <description>Receiver FIFO read silent</description>
          <addressOffset>0x344</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>N/A</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>Active clocked interrupt signal</description>
          <addressOffset>0xE00</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>M</name>
              <description>Master interrupt active ('interrupt_master'): INTR_M_MASKED != 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S</name>
              <description>Slave interrupt active ('interrupt_slave'): INTR_S_MASKED != 0.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX</name>
              <description>Transmitter interrupt active ('interrupt_tx'): INTR_TX_MASKED != 0.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX</name>
              <description>Receiver interrupt active ('interrupt_rx'): INTR_RX_MASKED != 0.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC</name>
              <description>Externally clock I2C interrupt active ('interrupt_i2c_ec'): INTR_I2C_EC_MASKED != 0.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC</name>
              <description>Externally clocked SPI interrupt active ('interrupt_spi_ec'): INTR_SPI_EC_MASKED != 0.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC</name>
          <description>Externally clocked I2C interrupt request</description>
          <addressOffset>0xE80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request (with address match).

Only set when EC_AM is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (I2C STOP).

Only set for a slave request with an address match, in EZ and CMD_RESP modes, when EC_OP is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (I2C STOP). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 

Only set for a slave request with an address match, in EZ and CMD_RESP modes, when EC_OP is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (I2C STOP). This event is an indication that a buffer memory location has been read from.

Only set for a slave request with an address match, in EZ and CMD_RESP modes, when EC_OP is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASK</name>
          <description>Externally clocked I2C interrupt mask</description>
          <addressOffset>0xE88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASKED</name>
          <description>Externally clocked I2C interrupt masked</description>
          <addressOffset>0xE8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC</name>
          <description>Externally clocked SPI interrupt request</description>
          <addressOffset>0xEC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request.

Only set when EC_AM is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (SPI deselection).

Only set in EZ and CMD_RESP mode and when EC_OP is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (SPI deselection). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 

Only set in EZ and CMD_RESP modes and when EC_OP is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (SPI deselection). This event is an indication that a buffer memory location has been read from.

Only set in EZ and CMD_RESP modes and when EC_OP is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASK</name>
          <description>Externally clocked SPI interrupt mask</description>
          <addressOffset>0xEC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASKED</name>
          <description>Externally clocked SPI interrupt masked</description>
          <addressOffset>0xECC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M</name>
          <description>Master interrupt request</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_SET</name>
          <description>Master interrupt set request</description>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASK</name>
          <description>Master interrupt mask</description>
          <addressOffset>0xF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASKED</name>
          <description>Master interrupt masked request</description>
          <addressOffset>0xF0C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S</name>
          <description>Slave interrupt request</description>
          <addressOffset>0xF40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C slave lost arbitration: the value driven on the SDA line is not the same as the value observed on the SDA line (while the SCL line is '1'). This should not occur, it represents erroneous I2C bus behavior. In case of lost arbitration, the I2C slave state machine aborts the ongoing transfer.  SW may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>I2C STOP event for I2C write transfer intended for this slave (address matching is performed). Set to '1', when STOP or REPEATED START event is detected. The REPEATED START event is included in this interrupt cause such that the I2C transfers separated by a REPEATED START can be distinguished and potentially treated separately by the firmware. Note that the second I2C transfer (after a REPEATED START) may be to a different slave address.

Note that a I2C write address intended for the slave (address is matching and a it is a write transfer) will result in a I2C_WRITE_STOP event independent of whether the I2C address is ACK'd or NACK'd.

In EZ mode, the event is detected only on I2C write transfers that have EZ data written to the memory structure (an I2C write transfer that only communicates an I2C address and EZ base address, will not result in this event being detected).</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>I2C slave START received. Set to '1', when START or REPEATED START event is detected.

In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') AND clock stretching is performed (till the internally clocked logic takes over) (I2C_CTRL.S_NOT_READY_ADDR_NACK is '0'), this field is NOT set. Firmware should use INTR_S_EC.WAKE_UP, INTR_S.I2C_ADDR_MATCH and INTR_S.I2C_GENERAL.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>N/A</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>I2C slave general call address received.  If CTRL.ADDR_ACCEPT is set the received address 0x00 (including the R/W bit) is available in the RX FIFO.  

In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') and internally clocked operation (CTRL.EC_OP_MODE is '0'), this field is set when the event is detected.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>I2C slave bus error (unexpected detection of START or STOP condition). This should not occur, it represents erroneous I2C bus behavior. In case of a bus error, the I2C slave state machine abort the ongoing transfer. Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>SPI slave deselected at an unexpected time in the SPI transfer. Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_SET</name>
          <description>Slave interrupt set request</description>
          <addressOffset>0xF44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASK</name>
          <description>Slave interrupt mask</description>
          <addressOffset>0xF48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASKED</name>
          <description>Slave interrupt masked request</description>
          <addressOffset>0xF4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX</name>
          <description>Transmitter interrupt request</description>
          <addressOffset>0xF80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Attempt to read from an empty TX FIFO. This happens when the SCB is ready to transfer data and EMPTY is '1'.

Only used in FIFO mode.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>CPU write can not get access to the EZ memory (EZ data access), due to an externally clocked EZ access.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>UART transmitter done event. This happens when the SCB is done transferring all data in the TX FIFO, and the last stop field is transmitted (both TX FIFO and transmit shifter register are empty).</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>UART lost arbitration: the value driven on the TX line is not the same as the value observed on the RX line. This condition event is usefull when transmitter and receiver share a TX/RX line. This is the case in LIN or SmartCard modes.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_SET</name>
          <description>Transmitter interrupt set request</description>
          <addressOffset>0xF84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASK</name>
          <description>Transmitter interrupt mask</description>
          <addressOffset>0xF88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASKED</name>
          <description>Transmitter interrupt masked request</description>
          <addressOffset>0xF8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX</name>
          <description>Receiver interrupt request</description>
          <addressOffset>0xFC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>N/A</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>CPU read transfer can not get access to the EZ memory (EZ_DATA accesses), due to an externally clocked EZ access.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>UART Frame error in received data frame.  
This can be either a start or stop bit(s) error:
Start bit error: after the detection of the beginning of a start bit period (RX line changes from '1' to '0'), the middle of the start bit period is sampled erroneously (RX line is '1').  Note: a start bit error is detected BEFORE a data frame is received.
Stop bit error: the RX line is sampled as '0', but a '1' was expected. Note: a stop bit error may result in failure to receive successive data frame(s). Note: a stop bit error is detected AFTER a data frame is received.

A stop bit error is detected after a data frame is received, and the UART_RX_CTL.DROP_ON_FRAME_ERROR field specifies whether the received frame is dropped or send to the RX FIFO. If UART_RX_CTL.DROP_ON_FRAME_ERROR is '1', the received data frame is dropped. If UART_RX_CTL.DROP_ON_FRAME_ERROR is '0', the received data frame is send to the RX FIFO. Note that Firmware can only identify the erroneous data frame in the RX FIFO if it is fast enough to read the data frame before the hardware writes a next data frame into the RX FIFO; i.e. the RX FIFO does not have error flags to tag erroneous data frames.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>UART Parity error in received data frame. If UART_RX_CTL.DROP_ON_PARITY_ERROR is '1', the received frame is dropped. If UART_RX_CTL.DROP_ON_PARITY_ERROR is '0', the received frame is send to the RX FIFO. In SmartCard submode, negatively acknowledged data frames generate a parity error. Note that Firmware can only identify the erroneous data frame in the RX FIFO if it is fast enough to read the data frame before the hardware writes a next data frame into the RX FIFO.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>LIN baudrate detection is completed.  The receiver software uses the UART_RX_STATUS.BR_COUNTER value to set the clk_scb to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Break detection is successful: the line is '0' for UART_RX_CTRL.BREAK_WIDTH + 1 bit period. Can occur at any time to address unanticipated break fields; i.e. 'break-in-data' is supported. This feature is supported for the UART standard and LIN submodes. For the UART standard submodes, ongoing receipt of data frames is NOT affected; i.e. Firmware is expected to take the proper action. For the LIN submode, possible ongoing receipt of a data frame is stopped and the (partially) received data frame is dropped and baud rate detection is started. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_SET</name>
          <description>Receiver interrupt set request</description>
          <addressOffset>0xFC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASK</name>
          <description>Receiver interrupt mask</description>
          <addressOffset>0xFC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASKED</name>
          <description>Receiver interrupt masked request</description>
          <addressOffset>0xFCC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB1</name>
      <baseAddress>0x40510000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB2</name>
      <baseAddress>0x40520000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB3</name>
      <baseAddress>0x40530000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB4</name>
      <baseAddress>0x40540000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB5</name>
      <baseAddress>0x40550000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB6</name>
      <baseAddress>0x40560000</baseAddress>
    </peripheral>
    <peripheral>
      <name>CANFD0</name>
      <description>CAN Controller</description>
      <headerStructName>CANFD</headerStructName>
      <baseAddress>0x40580000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>131072</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <name>CH</name>
          <description>FIFO wrapper around M_TTCAN 3PIP, to enable DMA</description>
          <addressOffset>0x00000000</addressOffset>
          <cluster>
            <name>M_TTCAN</name>
            <description>TTCAN 3PIP, includes FD</description>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>CREL</name>
              <description>Core Release Register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x32380609</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DAY</name>
                  <description>Time Stamp Day
Two digits, BCD-coded. This field is set by generic parameter on M_TTCAN synthesis.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MON</name>
                  <description>Time Stamp Month
Two digits, BCD-coded. This field is set by generic parameter on M_TTCAN synthesis.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>YEAR</name>
                  <description>Time Stamp Year
One digit, BCD-coded. This field is set by generic parameter on M_TTCAN synthesis.</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SUBSTEP</name>
                  <description>Sub-step of Core Release
One digit, BCD-coded.</description>
                  <bitRange>[23:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STEP</name>
                  <description>Step of Core Release
One digit, BCD-coded.</description>
                  <bitRange>[27:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>REL</name>
                  <description>Core Release
One digit, BCD-coded.</description>
                  <bitRange>[31:28]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ENDN</name>
              <description>Endian Register</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x87654321</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ETV</name>
                  <description>Endianness Test Value
The endianness test value is 0x87654321.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DBTP</name>
              <description>Data Bit Timing &amp; Prescaler Register</description>
              <addressOffset>0xC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xA33</resetValue>
              <resetMask>0x9F1FFF</resetMask>
              <fields>
                <field>
                  <name>DSJW</name>
                  <description>Data (Re)Synchronization Jump Width
0x0-0xF Valid values are 0 to 15. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DTSEG2</name>
                  <description>Data time segment after sample point
0x0-0xF Valid values are 0 to 15. The actual interpretation by the hardware of this value is
such that one more than the programmed value is used.</description>
                  <bitRange>[7:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DTSEG1</name>
                  <description>Data time segment before sample point
0x00-0x1F Valid values are 0 to 31. The actual interpretation by the hardware of this value is
such that one more than the programmed value is used.</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DBRP</name>
                  <description>Data Bit Rate Prescaler
0x00-0x1F The value by which the oscillator frequency is divided for generating the bit time
quanta. The bit time is built up from a multiple of this quanta. Valid values for the Bit
Rate Prescaler are 0 to 31. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TDC</name>
                  <description>Transmitter Delay Compensation
0= Transmitter Delay Compensation disabled
1= Transmitter Delay Compensation enabled</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TEST</name>
              <description>Test Register</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F</resetMask>
              <fields>
                <field>
                  <name>TAM</name>
                  <description>ASC is not supported by M_TTCAN
Test ASC Multiplexer Control
Controls output pin m_ttcan_ascm in test mode, ORed with the signal from the FSE
0= Level at pin m_ttcan_ascm controlled by FSE
1= Level at pin m_ttcan_ascm = '1'</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TAT</name>
                  <description>ASC is not supported by M_TTCAN
Test ASC Transmit Control
Controls output pin m_ttcan_asct in test mode, ORed with the signal from the FSE
0= Level at pin m_ttcan_asct controlled by FSE
1= Level at pin m_ttcan_asct = '1'</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CAM</name>
                  <description>ASC is not supported by M_TTCAN
Check ASC Multiplexer Control
Monitors level at output pin m_ttcan_ascm.
0= Output pin m_ttcan_ascm = '0'
1= Output pin m_ttcan_ascm = '1'</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CAT</name>
                  <description>ASC is not supported by M_TTCAN
Check ASC Transmit Control
Monitors level at output pin m_ttcan_asct.
0= Output pin m_ttcan_asct = '0'</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LBCK</name>
                  <description>Loop Back Mode
0= Reset value, Loop Back Mode is disabled
1= Loop Back Mode is enabled (see Section 3.1.9, Test Modes)</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TX</name>
                  <description>Control of Transmit Pin
00 Reset value, m_ttcan_tx controlled by the CAN Core, updated at the end of the CAN bit time
01 Sample Point can be monitored at pin m_ttcan_tx
10 Dominant ('0') level at pin m_ttcan_tx
11 Recessive ('1') at pin m_ttcan_tx</description>
                  <bitRange>[6:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX</name>
                  <description>Receive Pin
Monitors the actual value of pin m_ttcan_rx
0= The CAN bus is dominant (m_ttcan_rx = '0')
1= The CAN bus is recessive (m_ttcan_rx = '1')</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RWD</name>
              <description>RAM Watchdog</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>WDC</name>
                  <description>Watchdog Configuration
Start value of the Message RAM Watchdog Counter. With the reset value of '00' the counter is
disabled.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDV</name>
                  <description>Watchdog Value
Actual Message RAM Watchdog Counter Value.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CCCR</name>
              <description>CC Control Register</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1</resetValue>
              <resetMask>0xF3FF</resetMask>
              <fields>
                <field>
                  <name>INIT</name>
                  <description>Initialization
0= Normal Operation
1= Initialization is started</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CCE</name>
                  <description>Configuration Change Enable
0= The CPU has no write access to the protected configuration registers
1= The CPU has write access to the protected configuration registers (while CCCR.INIT = '1')</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ASM</name>
                  <description>Restricted Operation Mode
Bit ASM can only be set by the Host when both CCE and INIT are set to '1'. The bit can be reset by
the Host at any time. For a description of the Restricted Operation Mode see Section 3.1.5.
0= Normal CAN operation
1= Restricted Operation Mode active</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSA</name>
                  <description>Clock Stop Acknowledge
0= No clock stop acknowledged
1= M_TTCAN may be set in power down by stopping m_ttcan_hclk and m_ttcan_cclk</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSR</name>
                  <description>Clock Stop Request, not supported by M_TTCAN use CTL.STOP_REQ at the group level instead.
0= No clock stop is requested
1= Clock stop requested. When clock stop is requested, first INIT and then CSA will be set after
all pending transfer requests have been completed and the CAN bus reached idle.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MON_</name>
                  <description>Bus Monitoring Mode
Bit MON can only be set by the Host when both CCE and INIT are set to '1'. The bit can be reset by
the Host at any time.
0= Bus Monitoring Mode is disabled
1= Bus Monitoring Mode is enabled</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DAR</name>
                  <description>Disable Automatic Retransmission
0= Automatic retransmission of messages not transmitted successfully enabled
1= Automatic retransmission disabled</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEST</name>
                  <description>Test Mode Enable
0= Normal operation, register TEST holds reset values
1= Test Mode, write access to register TEST enabled</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FDOE</name>
                  <description>FD Operation Enable
0= FD operation disabled
1= FD operation enabled</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BRSE</name>
                  <description>Bit Rate Switch Enable
0= Bit rate switching for transmissions disabled
1= Bit rate switching for transmissions enabled</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PXHD</name>
                  <description>Protocol Exception Handling Disable
0= Protocol exception handling enabled
1= Protocol exception handling disabled</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EFBI</name>
                  <description>Edge Filtering during Bus Integration
0= Edge filtering disabled
1= Two consecutive dominant tq required to detect an edge for hard synchronization</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXP</name>
                  <description>Transmit Pause
If this bit is set, the M_TTCAN pauses for two CAN bit times before starting the next transmission
after itself has successfully transmitted a frame (see Section 3.5).
0= Transmit pause disabled
1= Transmit pause enabled</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NISO</name>
                  <description>Non ISO Operation
If this bit is set, the M_TTCAN uses the CAN FD frame format as specified by the Bosch CAN FD
Specification V1.0.
0= CAN FD frame format according to ISO 11898-1:2015
1= CAN FD frame format according to Bosch CAN FD Specification V1.0 addressing the non-ISO CAN FD</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>NBTP</name>
              <description>Nominal Bit Timing &amp; Prescaler Register</description>
              <addressOffset>0x1C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x6000A03</resetValue>
              <resetMask>0xFFFFFF7F</resetMask>
              <fields>
                <field>
                  <name>NTSEG2</name>
                  <description>Nominal Time segment after sample point
0x01-0x7F Valid values are 1 to 127. The actual interpretation by the hardware of this value is
such that one more than the programmed value is used.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NTSEG1</name>
                  <description>Nominal Time segment before sample point
0x01-0xFF Valid values are 1 to 255. The actual interpretation by the hardware of this value is
such that one more than the programmed value is used.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NBRP</name>
                  <description>Nominal Bit Rate Prescaler
0x000-0x1FFThe value by which the oscillator frequency is divided for generating the bit time
quanta. The bit time is built up from a multiple of this quanta. Valid values for the Bit
Rate Prescaler are 0 to 511. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
                  <bitRange>[24:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NSJW</name>
                  <description>Nominal (Re)Synchronization Jump Width
0x00-0x7F Valid values are 0 to 127. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
                  <bitRange>[31:25]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TSCC</name>
              <description>Timestamp Counter Configuration</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xF0003</resetMask>
              <fields>
                <field>
                  <name>TSS</name>
                  <description>Timestamp Select, should always be set to external timestamp counter
00= Timestamp counter value always 0x0000
01= Timestamp counter value incremented according to TCP
10= External timestamp counter value used
11= Same as '00'</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCP</name>
                  <description>Timestamp Counter Prescaler (still used for TOCC)
0x0-0xF Configures the timestamp and timeout counters time unit in multiples of CAN bit times
[1...16]. The actual interpretation by the hardware of this value is such that one more
than the value programmed here is used.</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TSCV</name>
              <description>Timestamp Counter Value</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TSC</name>
                  <description>Timestamp Counter, not used for M_TTCAN
The internal/external Timestamp Counter value is captured on start of frame (both Rx and Tx).
When TSCC.TSS = '01', the Timestamp Counter is incremented in multiples of CAN bit times
[1...16] depending on the configuration of TSCC.TCP. A wrap around sets interrupt flag IR.TSW.
Write access resets the counter to zero. When TSCC.TSS = '10', TSC reflects the external
Timestamp Counter value. A write access has no impact.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TOCC</name>
              <description>Timeout Counter Configuration</description>
              <addressOffset>0x28</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFF0000</resetValue>
              <resetMask>0xFFFF0007</resetMask>
              <fields>
                <field>
                  <name>ETOC</name>
                  <description>Enable Timeout Counter
0= Timeout Counter disabled
1= Timeout Counter enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOS</name>
                  <description>Timeout Select
When operating in Continuous mode, a write to TOCV presets the counter to the value configured
by TOCC.TOP and continues down-counting. When the Timeout Counter is controlled by one of the
FIFOs, an empty FIFO presets the counter to the value configured by TOCC.TOP. Down-counting
is started when the first FIFO element is stored.
00= Continuous operation
01= Timeout controlled by Tx Event FIFO
10= Timeout controlled by Rx FIFO 0
11= Timeout controlled by Rx FIFO 1</description>
                  <bitRange>[2:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOP</name>
                  <description>Timeout Period
Start value of the Timeout Counter (down-counter). Configures the Timeout Period.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TOCV</name>
              <description>Timeout Counter Value</description>
              <addressOffset>0x2C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFF</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TOC</name>
                  <description>Timeout Counter
The Timeout Counter is decremented in multiples of CAN bit times [1...16] depending on the
configuration of TSCC.TCP. When decremented to zero, interrupt flag IR.TOO is set and the
Timeout Counter is stopped. Start and reset/restart conditions are configured via TOCC.TOS.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ECR</name>
              <description>Error Counter Register</description>
              <addressOffset>0x40</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TEC</name>
                  <description>Transmit Error Counter
Actual state of the Transmit Error Counter, values between 0 and 255</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>REC</name>
                  <description>Receive Error Counter
Actual state of the Receive Error Counter, values between 0 and 127</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RP</name>
                  <description>Receive Error Passive
0= The Receive Error Counter is below the error passive level of 128
1= The Receive Error Counter has reached the error passive level of 128</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CEL</name>
                  <description>CAN Error Logging
The counter is incremented each time when a CAN protocol error causes the Transmit Error Counter
or the Receive Error Counter to be incremented. It is reset by read access to CEL. The counter stops
at 0xFF; the next increment of TEC or REC sets interrupt flag IR.ELO.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PSR</name>
              <description>Protocol Status Register</description>
              <addressOffset>0x44</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x707</resetValue>
              <resetMask>0x7F7FFF</resetMask>
              <fields>
                <field>
                  <name>LEC</name>
                  <description>Last Error Code,
Set on Read0
The LEC indicates the type of the last error to occur on the CAN bus. This field will be cleared to '0'
when a message has been transferred (reception or transmission) without error.

0= No Error: No error occurred since LEC has been reset by successful reception or transmission.
1= Stuff Error: More than 5 equal bits in a sequence have occurred in a part of a received message where this is not allowed.
2= Form Error: A fixed format part of a received frame has the wrong format.
3= AckError: The message transmitted by the M_TTCAN was not acknowledged by another node.
4= Bit1Error: During the transmission of a message (with the exception of the arbitration field),
the device wanted to send a recessive level (bit of logical value '1'), but the monitored bus
 value was dominant. 
5= Bit0Error: During the transmission of a message (or acknowledge bit, or active error flag, or
overload flag), the device wanted to send a dominant level (data or identifier bit logical value
0'), but the monitored bus value was recessive. During Bus_Off recovery this status is set
each time a sequence of 11 recessive bits has been monitored. This enables the CPU to
monitor the proceeding of the Bus_Off recovery sequence (indicating the bus is not stuck at
dominant or continuously disturbed).
6= CRCError: The CRC check sum of a received message was incorrect. The CRC of an incoming
message does not match with the CRC calculated from the received data.
7= NoChange: Any read access to the Protocol Status Register re-initializes the LEC to '7'.
When the LEC shows the value '7', no CAN bus event was detected since the last CPU read
access to the Protocol Status Register.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ACT</name>
                  <description>Activity
Monitors the module's CAN communication state.
00= Synchronizing - node is synchronizing on CAN communication
01= Idle - node is neither receiver nor transmitter
10= Receiver - node is operating as receiver
11= Transmitter - node is operating as transmitter</description>
                  <bitRange>[4:3]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EP</name>
                  <description>Error Passive
0= The M_CAN is in the Error_Active state. It normally takes part in bus communication and sends an active error flag when an error has been detected
1= The M_CAN is in the Error_Passive state</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EW</name>
                  <description>Warning Status
0= Both error counters are below the Error_Warning limit of 96
1= At least one of error counter has reached the Error_Warning limit of 96</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>BO</name>
                  <description>Bus_Off Status
0= The M_CAN is not Bus_Off
1= The M_CAN is in Bus_Off state</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DLEC</name>
                  <description>Data Phase Last Error Code
, Set on Read
Type of last error that occurred in the data phase of a CAN FD format frame with its BRS flag set. Coding is the same as for LEC. This field will be cleared to zero when a CAN FD format frame with its BRS flag set has been transferred (reception or transmission) without error.</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RESI</name>
                  <description>ESI flag of last received CAN FD Message
, Reset on Read
This bit is set together with RFDF, independent of acceptance filtering.
0= Last received CAN FD message did not have its ESI flag set
1= Last received CAN FD message had its ESI flag set</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RBRS</name>
                  <description>BRS flag of last received CAN FD Message
, Reset on Read
This bit is set together with RFDF, independent of acceptance filtering.
0= Last received CAN FD message did not have its BRS flag set
1= Last received CAN FD message had its BRS flag set</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RFDF</name>
                  <description>Received a CAN FD Message
, Reset on Read
This bit is set independent of acceptance filtering.
0= Since this bit was reset by the CPU, no CAN FD message has been received
1= Message in CAN FD format with FDF flag set has been received</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PXE</name>
                  <description>Protocol Exception Event
, Reset on Read
0= No protocol exception event occurred since last read access
1= Protocol exception event occurred</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TDCV</name>
                  <description>Transmitter Delay Compensation Value
0x00-0x7F Position of the secondary sample point, defined by the sum of the measured delay from m_can_tx to m_can_rx and TDCR.TDCO. The SSP position is, in the data phase, the number of mtq between the start of the transmitted bit and the secondary sample point. Valid values are 0 to 127 mtq.</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TDCR</name>
              <description>Transmitter Delay Compensation Register</description>
              <addressOffset>0x48</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F7F</resetMask>
              <fields>
                <field>
                  <name>TDCF</name>
                  <description>Transmitter Delay Compensation Filter Window Length
0x00-0x7F Defines the minimum value for the SSP position, dominant edges on m_ttcan_rx
that would result in an earlier SSP position are ignored for transmitter delay measurement.
The feature is enabled when TDCF is configured to a value greater than
TDCO. Valid values are 0 to 127 mtq</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TDCO</name>
                  <description>Transmitter Delay Compensation Offset
0x00-0x7F Offset value defining the distance between the measured delay from m_ttcan_tx to
m_ttcan_rx and the secondary sample point. Valid values are 0 to 127 mtq.</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IR</name>
              <description>Interrupt Register</description>
              <addressOffset>0x50</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RF0N</name>
                  <description>N/A</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0W</name>
                  <description>N/A</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0F</name>
                  <description>N/A</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0L_</name>
                  <description>N/A</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1N</name>
                  <description>N/A</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1W</name>
                  <description>N/A</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1F</name>
                  <description>N/A</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1L_</name>
                  <description>N/A</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HPM</name>
                  <description>N/A</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TC</name>
                  <description>N/A</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCF</name>
                  <description>N/A</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFE</name>
                  <description>N/A</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFN</name>
                  <description>N/A</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFW</name>
                  <description>N/A</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFF</name>
                  <description>N/A</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFL_</name>
                  <description>N/A</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TSW</name>
                  <description>N/A</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MRAF</name>
                  <description>N/A</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOO</name>
                  <description>N/A</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DRX</name>
                  <description>N/A</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEC</name>
                  <description>Bit Error Corrected
This bit always reads as 0.</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEU</name>
                  <description>Bit Error Uncorrected
Message RAM bit error detected, uncorrected. The flag is set in the folloiwng cases.
- M_TTCAN detects uncorrectable ECC error from Message RAM when ECC is enabled and ECC error injection is disabled.
- M_TTCAN reads from an out of range Message RAM address.
Message RAM bit error sets CCCR.INIT to '1'. This is done to avoid transmission of corrupted data.
0= No bit error detected when reading from Message RAM
1= Bit error detected, uncorrected</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELO</name>
                  <description>N/A</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EP_</name>
                  <description>N/A</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EW_</name>
                  <description>N/A</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BO_</name>
                  <description>N/A</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDI</name>
                  <description>N/A</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEA</name>
                  <description>N/A</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PED</name>
                  <description>N/A</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ARA</name>
                  <description>N/A</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IE</name>
              <description>Interrupt Enable</description>
              <addressOffset>0x54</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RF0NE</name>
                  <description>Rx FIFO 0 New Message Interrupt Enable
 
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0WE</name>
                  <description>Rx FIFO 0 Watermark Reached Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0FE</name>
                  <description>Rx FIFO 0 Full Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0LE</name>
                  <description>Rx FIFO 0 Message Lost Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1NE</name>
                  <description>Rx FIFO 1 New Message Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1WE</name>
                  <description>Rx FIFO 1 Watermark Reached Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1FE</name>
                  <description>Rx FIFO 1 Full Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1LE</name>
                  <description>Rx FIFO 1 Message Lost Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HPME</name>
                  <description>High Priority Message Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCE</name>
                  <description>Transmission Completed Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCFE</name>
                  <description>Transmission Cancellation Finished Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFEE</name>
                  <description>Tx FIFO Empty Interrupt Enable
0= Interrupt Disabled
1= Interrupt EnabledTx FIFO Empty Interrupt Enable</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFNE</name>
                  <description>Tx Event FIDO New Entry Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFWE</name>
                  <description>Tx Event FIFO Watermark Reached Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFFE</name>
                  <description>Tx Event FIFO Full Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFLE</name>
                  <description>Tx Event FIFO Event Lost Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TSWE</name>
                  <description>Timestamp Wraparound Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MRAFE</name>
                  <description>Message RAM Access Failure Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOOE</name>
                  <description>Timeout Occurred Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DRXE</name>
                  <description>Message stored to Dedicated Rx Buffer Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BECE</name>
                  <description>Bit Error Corrected Interrupt Enable (not used in M_TTCAN)
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEUE</name>
                  <description>Bit Error Uncorrected Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELOE</name>
                  <description>Error Logging Overflow Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EPE</name>
                  <description>Error Passive Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EWE</name>
                  <description>Warning Status Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BOE</name>
                  <description>Bus_Off Status Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDIE</name>
                  <description>Watchdog Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEAE</name>
                  <description>Protocol Error in Arbitration Phase Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEDE</name>
                  <description>Protocol Error in Data Phase Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ARAE</name>
                  <description>N/A</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ILS</name>
              <description>Interrupt Line Select</description>
              <addressOffset>0x58</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RF0NL</name>
                  <description>Rx FIFO 0 New Message Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0WL</name>
                  <description>Rx FIFO 0 Watermark Reached Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0FL</name>
                  <description>Rx FIFO 0 Full Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0LL</name>
                  <description>Rx FIFO 0 Message Lost Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1NL</name>
                  <description>Rx FIFO 1 New Message Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1WL</name>
                  <description>Rx FIFO 1 Watermark Reached Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1FL</name>
                  <description>Rx FIFO 1 Full Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1LL</name>
                  <description>Rx FIFO 1 Message Lost Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HPML</name>
                  <description>High Priority Message Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCL</name>
                  <description>Transmission Completed Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCFL</name>
                  <description>Transmission Cancellation Finished Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFEL</name>
                  <description>Tx FIFO Empty Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFNL</name>
                  <description>Tx Event FIFO New Entry Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFWL</name>
                  <description>Tx Event FIFO Watermark Reached Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFFL</name>
                  <description>Tx Event FIFO Full Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFLL</name>
                  <description>Tx Event FIFO Event Lost Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TSWL</name>
                  <description>Timestamp Wraparound Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MRAFL</name>
                  <description>Message RAM Access Failure Interrupt Select  
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOOL</name>
                  <description>Timeout Occurred Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DRXL</name>
                  <description>Message stored to Dedicated Rx Buffer Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BECL</name>
                  <description>Bit Error Corrected Interrupt Select  (not used in M_TTCAN) 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEUL</name>
                  <description>Bit Error Uncorrected Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELOL</name>
                  <description>Error Logging Overflow Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EPL</name>
                  <description>Error Passive Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EWL</name>
                  <description>Warning Status Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BOL</name>
                  <description>Bus_Off Status Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDIL</name>
                  <description>Watchdog Interrupt Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEAL</name>
                  <description>Protocol Error in Arbitration Phase Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEDL</name>
                  <description>Protocol Error in Data Phase Select 
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ARAL</name>
                  <description>N/A</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ILE</name>
              <description>Interrupt Line Enable</description>
              <addressOffset>0x5C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>EINT0</name>
                  <description>Enable Interrupt Line 0
0= Interrupt line m_ttcan_int0 disabled
1= Interrupt line m_ttcan_int0 enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EINT1</name>
                  <description>Enable Interrupt Line 1
0= Interrupt line m_ttcan_int1 disabled
1= Interrupt line m_ttcan_int1 enabled</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GFC</name>
              <description>Global Filter Configuration</description>
              <addressOffset>0x80</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>RRFE</name>
                  <description>Reject Remote Frames Extended
0= Filter remote frames with 29-bit extended IDs
1= Reject all remote frames with 29-bit extended IDs</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RRFS</name>
                  <description>Reject Remote Frames Standard
0= Filter remote frames with 11-bit standard IDs
1= Reject all remote frames with 11-bit standard IDs</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ANFE</name>
                  <description>Accept Non-matching Frames Extended
Defines how received messages with 29-bit IDs that do not match any element of the filter list are
treated.
00= Accept in Rx FIFO 0
01= Accept in Rx FIFO 1
10= Reject
11= Reject</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ANFS</name>
                  <description>Accept Non-matching Frames Standard
Defines how received messages with 11-bit IDs that do not match any element of the filter list are
treated.
00= Accept in Rx FIFO 0
01= Accept in Rx FIFO 1
10= Reject
11= Reject</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SIDFC</name>
              <description>Standard ID Filter Configuration</description>
              <addressOffset>0x84</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFC</resetMask>
              <fields>
                <field>
                  <name>FLSSA</name>
                  <description>Filter List Standard Start Address
Start address of standard Message ID filter list (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LSS</name>
                  <description>List Size Standard
0= No standard Message ID filter
1-128= Number of standard Message ID filter elements
128= Values greater than 128 are interpreted as 128</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>XIDFC</name>
              <description>Extended ID Filter Configuration</description>
              <addressOffset>0x88</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFFC</resetMask>
              <fields>
                <field>
                  <name>FLESA</name>
                  <description>Filter List Extended Start Address
Start address of extended Message ID filter list (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LSE</name>
                  <description>List Size Extended
0= No extended Message ID filter
1-64= Number of extended Message ID filter elements
64= Values greater than 64 are interpreted as 64</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>XIDAM</name>
              <description>Extended ID AND Mask</description>
              <addressOffset>0x90</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1FFFFFFF</resetValue>
              <resetMask>0x1FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>EIDM</name>
                  <description>Extended ID Mask
For acceptance filtering of extended frames the Extended ID AND Mask is ANDed with the Message
ID of a received frame. Intended for masking of 29-bit IDs in SAE J1939. With the reset value of all
bits set to one the mask is not active.</description>
                  <bitRange>[28:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>HPMS</name>
              <description>High Priority Message Status</description>
              <addressOffset>0x94</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>BIDX</name>
                  <description>Buffer Index
Index of Rx FIFO element to which the message was stored. Only valid when MSI[1] = '1'.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MSI</name>
                  <description>Message Storage Indicator
00= No FIFO selected
01= FIFO message lost
10= Message stored in FIFO 0
11= Message stored in FIFO 1</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FIDX</name>
                  <description>Filter Index
Index of matching filter element. Range is 0 to SIDFC.LSS - 1 resp. XIDFC.LSE - 1.</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FLST</name>
                  <description>Filter List
Indicates the filter list of the matching filter element.
0= Standard Filter List
1= Extended Filter List</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>NDAT1</name>
              <description>New Data 1</description>
              <addressOffset>0x98</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ND</name>
                  <description>New Data
The register holds the New Data flags of Rx Buffers 0 to 31. The flags are set when the respective
Rx Buffer has been updated from a received frame. The flags remain set until the Host clears them.
A flag is cleared by writing a '1' to the corresponding bit position. Writing a '0' has no effect. A hard
reset will clear the register.
0= Rx Buffer not updated
1= Rx Buffer updated from new message</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>NDAT2</name>
              <description>New Data 2</description>
              <addressOffset>0x9C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ND</name>
                  <description>New Data
The register holds the New Data flags of Rx Buffers 32 to 63. The flags are set when the respective
Rx Buffer has been updated from a received frame. The flags remain set until the Host clears them.
A flag is cleared by writing a '1' to the corresponding bit position. Writing a '0' has no effect. A hard
reset will clear the register.
0= Rx Buffer not updated
1= Rx Buffer updated from new message</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF0C</name>
              <description>Rx FIFO 0 Configuration</description>
              <addressOffset>0xA0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF7FFFFC</resetMask>
              <fields>
                <field>
                  <name>F0SA</name>
                  <description>Rx FIFO 0 Start Address
Start address of Rx FIFO 0 in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F0S</name>
                  <description>Rx FIFO 0 Size
0= No Rx FIFO 0
1-64= Number of Rx FIFO 0 elements
64= Values greater than 64 are interpreted as 64
The Rx FIFO 0 elements are indexed from 0 to F0S-1</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F0WM</name>
                  <description>Rx FIFO 0 Watermark
0= Watermark interrupt disabled
1-64= Level for Rx FIFO 0 watermark interrupt (IR.RF0W)
64= Watermark interrupt disabled</description>
                  <bitRange>[30:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F0OM</name>
                  <description>FIFO 0 Operation Mode
FIFO 0 can be operated in blocking or in overwrite mode (see Section 3.4.2).
0= FIFO 0 blocking mode
1= FIFO 0 overwrite mode</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF0S</name>
              <description>Rx FIFO 0 Status</description>
              <addressOffset>0xA4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x33F3F7F</resetMask>
              <fields>
                <field>
                  <name>F0FL</name>
                  <description>Rx FIFO 0 Fill Level
Number of elements stored in Rx FIFO 0, range 0 to 64.
When the software reading the value immediately after writing to RXF0A.F0AI, this value should be read twice to ensure that the update is reflected.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F0GI</name>
                  <description>Rx FIFO 0 Get Index
Rx FIFO 0 read index pointer, range 0 to 63.
This field is updated by the software writing to RXF0A.F0AI.
When the software reading the value immediately after writing to RXF0A.F0AI, this value should be read twice to ensure that the update is reflected.</description>
                  <bitRange>[13:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F0PI</name>
                  <description>Rx FIFO 0 Put Index
Rx FIFO 0 write index pointer, range 0 to 63.</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F0F</name>
                  <description>Rx FIFO 0 Full
0= Rx FIFO 0 not full
1= Rx FIFO 0 full
When the software reading the value immediately after writing to RXF0A.F0AI, this value should be read twice to ensure that the update is reflected.</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RF0L</name>
                  <description>Rx FIFO 0 Message Lost
This bit is a copy of interrupt flag IR.RF0L. When IR.RF0L is reset, this bit is also reset.
0= No Rx FIFO 0 message lost
1= Rx FIFO 0 message lost, also set after write attempt to Rx FIFO 0 of size zero</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF0A</name>
              <description>Rx FIFO 0 Acknowledge</description>
              <addressOffset>0xA8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>F0AI</name>
                  <description>Rx FIFO 0 Acknowledge Index
After the Host has read a message or a sequence of messages from Rx FIFO 0 it has to write the
 buffer index of the last element read from Rx FIFO 0 to F0AI. This will set the Rx FIFO 0 Get Index
 RXF0S.F0GI to F0AI + 1 and update the FIFO 0 Fill Level RXF0S.F0FL.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXBC</name>
              <description>Rx Buffer Configuration</description>
              <addressOffset>0xAC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFC</resetMask>
              <fields>
                <field>
                  <name>RBSA</name>
                  <description>Rx Buffer Start Address
Configures the start address of the Rx Buffers section in the Message RAM (32-bit word address).
Also used to reference debug messages A,B,C.</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF1C</name>
              <description>Rx FIFO 1 Configuration</description>
              <addressOffset>0xB0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF7FFFFC</resetMask>
              <fields>
                <field>
                  <name>F1SA</name>
                  <description>Rx FIFO 1 Start Address
Start address of Rx FIFO 1 in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1S</name>
                  <description>Rx FIFO 1 Size
0= No Rx FIFO 1
1-64= Number of Rx FIFO 1 elements
64= Values greater than 64 are interpreted as 64
The Rx FIFO 1 elements are indexed from 0 to F1S - 1</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1WM</name>
                  <description>Rx FIFO 1 Watermark
0= Watermark interrupt disabled
1-64= Level for Rx FIFO 1 watermark interrupt (IR.RF1W)
64= Watermark interrupt disabled</description>
                  <bitRange>[30:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1OM</name>
                  <description>FIFO 1 Operation Mode
FIFO 1 can be operated in blocking or in overwrite mode (see Section 3.4.2).
0= FIFO 1 blocking mode
1= FIFO 1 overwrite mode</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF1S</name>
              <description>Rx FIFO 1 Status</description>
              <addressOffset>0xB4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xC33F3F7F</resetMask>
              <fields>
                <field>
                  <name>F1FL</name>
                  <description>Rx FIFO 1 Fill Level
Number of elements stored in Rx FIFO 1, range 0 to 64.
When the software reading the value immediately after writing to RXF1A.F1AI, this value should be read twice to ensure that the update is reflected.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F1GI</name>
                  <description>Rx FIFO 1 Get Index
Rx FIFO 1 read index pointer, range 0 to 63.
This field is updated by the software writing to RXF1A.F1AI.
When the software reading the value immediately after writing to RXF1A.F1AI, this value should be read twice to ensure that the update is reflected.</description>
                  <bitRange>[13:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F1PI</name>
                  <description>Rx FIFO 1 Put Index
Rx FIFO 1 write index pointer, range 0 to 63.</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F1F</name>
                  <description>Rx FIFO 1 Full
0= Rx FIFO 1 not full
1= Rx FIFO 1 full
When the software reading the value immediately after writing to RXF1A.F1AI, this value should be read twice to ensure that the update is reflected.</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RF1L</name>
                  <description>Rx FIFO 1 Message Lost
This bit is a copy of interrupt flag IR.RF1L. When IR.RF1L is reset, this bit is also reset.
0= No Rx FIFO 1 message lost
1= Rx FIFO 1 message lost, also set after write attempt to Rx FIFO 1 of size zero</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DMS</name>
                  <description>Debug Message Status
00= Idle state, wait for reception of debug messages, DMA request is cleared
01= Debug message A received
10= Debug messages A, B received
11= Debug messages A, B, C received, DMA request is set</description>
                  <bitRange>[31:30]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF1A</name>
              <description>Rx FIFO 1 Acknowledge</description>
              <addressOffset>0xB8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>F1AI</name>
                  <description>Rx FIFO 1 Acknowledge Index
After the Host has read a message or a sequence of messages from Rx FIFO 1 it has to write the
 buffer index of the last element read from Rx FIFO 1 to F1AI. This will set the Rx FIFO 1 Get Index
 RXF1S.F1GI to F1AI + 1 and update the FIFO 1 Fill Level RXF1S.F1FL.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXESC</name>
              <description>Rx Buffer / FIFO Element Size Configuration</description>
              <addressOffset>0xBC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x777</resetMask>
              <fields>
                <field>
                  <name>F0DS</name>
                  <description>Rx FIFO 0 Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1DS</name>
                  <description>Rx FIFO 1 Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RBDS</name>
                  <description>Rx Buffer Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBC</name>
              <description>Tx Buffer Configuration</description>
              <addressOffset>0xC0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F3FFFFC</resetMask>
              <fields>
                <field>
                  <name>TBSA</name>
                  <description>Tx Buffers Start Address
Start address of Tx Buffers section in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NDTB</name>
                  <description>Number of Dedicated Transmit Buffers
0= No Dedicated Tx Buffers
1-32= Number of Dedicated Tx Buffers
32= Values greater than 32 are interpreted as 32</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFQS</name>
                  <description>Transmit FIFO/Queue Size
0= No Tx FIFO/Queue
1-32= Number of Tx Buffers used for Tx FIFO/Queue
32= Values greater than 32 are interpreted as 32</description>
                  <bitRange>[29:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFQM</name>
                  <description>Tx FIFO/Queue Mode
0= Tx FIFO operation
1= Tx Queue operation</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXFQS</name>
              <description>Tx FIFO/Queue Status</description>
              <addressOffset>0xC4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F1F3F</resetMask>
              <fields>
                <field>
                  <name>TFFL</name>
                  <description>Tx FIFO Free Level
Number of consecutive free Tx FIFO elements starting from TFGI, range 0 to 32. Read as zero when
Tx Queue operation is configured (TXBC.TFQM = '1')</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TFGI</name>
                  <description>Tx FIFO Get Index
Tx FIFO read index pointer, range 0 to 31. Read as zero when Tx Queue operation is configured
TXBC.TFQM = '1').</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TFQPI</name>
                  <description>Tx FIFO/Queue Put Index
Tx FIFO/Queue write index pointer, range 0 to 31.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TFQF</name>
                  <description>Tx FIFO/Queue Full
0= Tx FIFO/Queue not full
1= Tx FIFO/Queue full</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXESC</name>
              <description>Tx Buffer Element Size Configuration</description>
              <addressOffset>0xC8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TBDS</name>
                  <description>Tx Buffer Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBRP</name>
              <description>Tx Buffer Request Pending</description>
              <addressOffset>0xCC</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TRP</name>
                  <description>Transmission Request Pending
Each Tx Buffer has its own Transmission Request Pending bit. The bits are set via register TXBAR.
The bits are reset after a requested transmission has completed or has been cancelled via register
TXBCR.
TXBRP bits are set only for those Tx Buffers configured via TXBC. After a TXBRP bit has been set,
a Tx scan (see Section 3.5, Tx Handling) is started to check for the pending Tx request with the
highest priority (Tx Buffer with lowest Message ID).
A cancellation request resets the corresponding transmission request pending bit of register
TXBRP. In case a transmission has already been started when a cancellation is requested, this is
done at the end of the transmission, regardless whether the transmission was successful or not. The
cancellation request bits are reset directly after the corresponding TXBRP bit has been reset.
After a cancellation has been requested, a finished cancellation is signaled via TXBCF
after successful transmission together with the corresponding TXBTO bit
when the transmission has not yet been started at the point of cancellation
when the transmission has been aborted due to lost arbitration
when an error occurred during frame transmission
In DAR mode all transmissions are automatically cancelled if they are not successful. The
corresponding TXBCF bit is set for all unsuccessful transmissions.
0= No transmission request pending
1= Transmission request pending</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBAR</name>
              <description>Tx Buffer Add Request</description>
              <addressOffset>0xD0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>AR</name>
                  <description>Add Request
Each Tx Buffer has its own Add Request bit. Writing a '1' will set the corresponding Add Request
bit; writing a '0' has no impact. This enables the Host to set transmission requests for multiple Tx
Buffers with one write to TXBAR. TXBAR bits are set only for those Tx Buffers configured via TXBC.
When no Tx scan is running, the bits are reset immediately, else the bits remain set until the Tx scan
process has completed.
0= No transmission request added
1= Transmission requested added</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBCR</name>
              <description>Tx Buffer Cancellation Request</description>
              <addressOffset>0xD4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CR</name>
                  <description>Cancellation Request
Each Tx Buffer has its own Cancellation Request bit. Writing a '1' will set the corresponding
Cancellation Request bit; writing a '0' has no impact. This enables the Host to set cancellation
requests for multiple Tx Buffers with one write to TXBCR. TXBCR bits are set only for those Tx
Buffers configured via TXBC. The bits remain set until the corresponding bit of TXBRP is reset.
0= No cancellation pending
1= Cancellation pending</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBTO</name>
              <description>Tx Buffer Transmission Occurred</description>
              <addressOffset>0xD8</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TO</name>
                  <description>Transmission Occurred
Each Tx Buffer has its own Transmission Occurred bit. The bits are set when the corresponding
TXBRP bit is cleared after a successful transmission. The bits are reset when a new transmission
is requested by writing a '1' to the corresponding bit of register TXBAR.
0= No transmission occurred
1= Transmission occurred</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBCF</name>
              <description>Tx Buffer Cancellation Finished</description>
              <addressOffset>0xDC</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CF</name>
                  <description>Cancellation Finished
Each Tx Buffer has its own Cancellation Finished bit. The bits are set when the corresponding
TXBRP bit is cleared after a cancellation was requested via TXBCR. In case the corresponding
TXBRP bit was not set at the point of cancellation, CF is set immediately. The bits are reset when a
new transmission is requested by writing a '1' to the corresponding bit of register TXBAR.
0= No transmit buffer cancellation
1= Transmit buffer cancellation finished</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBTIE</name>
              <description>Tx Buffer Transmission Interrupt Enable</description>
              <addressOffset>0xE0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIE</name>
                  <description>Transmission Interrupt Enable
Each Tx Buffer has its own Transmission Interrupt Enable bit.
0= Transmission interrupt disabled
1= Transmission interrupt enable</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBCIE</name>
              <description>Tx Buffer Cancellation Finished Interrupt Enable</description>
              <addressOffset>0xE4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CFIE</name>
                  <description>Cancellation Finished Interrupt Enable
Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.
0= Cancellation finished interrupt disabled
1= Cancellation finished interrupt enabled</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXEFC</name>
              <description>Tx Event FIFO Configuration</description>
              <addressOffset>0xF0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F3FFFFC</resetMask>
              <fields>
                <field>
                  <name>EFSA</name>
                  <description>Event FIFO Start Address
Start address of Tx Event FIFO in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EFS</name>
                  <description>Event FIFO Size
0= Tx Event FIFO disabled
1-32= Number of Tx Event FIFO elements
32= Values greater than 32 are interpreted as 32
The Tx Event FIFO elements are indexed from 0 to EFS-1</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EFWM</name>
                  <description>Event FIFO Watermark
0= Watermark interrupt disabled
1-32= Level for Tx Event FIFO watermark interrupt (IR.TEFW)
32= Watermark interrupt disabled</description>
                  <bitRange>[29:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXEFS</name>
              <description>Tx Event FIFO Status</description>
              <addressOffset>0xF4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x31F1F3F</resetMask>
              <fields>
                <field>
                  <name>EFFL</name>
                  <description>Event FIFO Fill Level
Number of elements stored in Tx Event FIFO, range 0 to 32.
When the software reading the value immediately after writing to TXEFA.EFAI, this value should be read twice to ensure that the update is reflected.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EFGI</name>
                  <description>Event FIFO Get Index
Tx Event FIFO read index pointer, range 0 to 31.
This field is updated by the software writing to TXEFA.EFAI.
When the software reading the value immediately after writing to TXEFA.EFAI, this value should be read twice to ensure that the update is reflected.</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EFPI</name>
                  <description>Event FIFO Put Index
Tx Event FIFO write index pointer, range 0 to 31.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EFF</name>
                  <description>Event FIFO Full
0= Tx Event FIFO not full
1= Tx Event FIFO full
When the software reading the value immediately after writing to TXEFA.EFAI, this value should be read twice to ensure that the update is reflected.</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TEFL</name>
                  <description>Tx Event FIFO Element Lost
This bit is a copy of interrupt flag IR.TEFL. When IR.TEFL is reset, this bit is also reset.
0= No Tx Event FIFO element lost
1= Tx Event FIFO element lost, also set after write attempt to Tx Event FIFO of size zero.</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXEFA</name>
              <description>Tx Event FIFO Acknowledge</description>
              <addressOffset>0xF8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1F</resetMask>
              <fields>
                <field>
                  <name>EFAI</name>
                  <description>Event FIFO Acknowledge Index
After the Host has read an element or a sequence of elements from the Tx Event FIFO it has to write
the index of the last element read from Tx Event FIFO to EFAI. This will set the Tx Event FIFO Get
Index TXEFS.EFGI to EFAI + 1 and update the Event FIFO Fill Level TXEFS.EFFL.</description>
                  <bitRange>[4:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTTMC</name>
              <description>TT Trigger Memory Configuration</description>
              <addressOffset>0x100</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFFC</resetMask>
              <fields>
                <field>
                  <name>TMSA</name>
                  <description>Trigger Memory Start Address
Start address of Trigger Memory in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TME</name>
                  <description>Trigger Memory Elements
0= No Trigger Memory
1-64= Number of Trigger Memory elements
64= Values greater than 64 are interpreted as 64</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTRMC</name>
              <description>TT Reference Message Configuration</description>
              <addressOffset>0x104</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xDFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RID</name>
                  <description>Reference Identifier
Identifier transmitted with reference message and used for reference message filtering. Standard or
extended reference identifier depending on bit XTD. A standard identifier has to be written to
ID[28:18].</description>
                  <bitRange>[28:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>XTD</name>
                  <description>Extended Identifier
0= 11-bit standard identifier
1= 29-bit extended identifier</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RMPS</name>
                  <description>Reference Message Payload Select
Ignored in case of time slaves.
0= Reference message has no additional payload
1= The following elements are taken from Tx Buffer 0:
Message Marker MM, Event FIFO Control EFC, Data Length Code DLC, Data Bytes DB
Level 1: bytes 2-8, Level 0,2: bytes 5-8)</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTOCF</name>
              <description>TT Operation Configuration</description>
              <addressOffset>0x108</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x10000</resetValue>
              <resetMask>0x7FFFFFB</resetMask>
              <fields>
                <field>
                  <name>OM</name>
                  <description>Operation Mode
00= Event-driven CAN communication, default
01= TTCAN level 1
10= TTCAN level 2
11= TTCAN level 0</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GEN</name>
                  <description>Gap Enable
0= Strictly time-triggered operation
1= External event-synchronized time-triggered operation</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TM</name>
                  <description>Time Master
0= Time Master function disabled
1= Potential Time Master</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDSDL</name>
                  <description>LD of Synchronization Deviation Limit
The Synchronization Deviation Limit SDL is configured by its dual logarithm LDSDL with SDL =
2(LDSDL + 5). It should not exceed the clock tolerance given by the CAN bit timing configuration.
0x0-7 LD of Synchronization Deviation Limit (SDL &lt;= 32...4096)</description>
                  <bitRange>[7:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IRTO</name>
                  <description>Initial Reference Trigger Offset
0x00-7F Positive offset, range from 0 to 127</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EECS</name>
                  <description>Enable External Clock Synchronization
If enabled, TUR configuration (TURCF.NCL only) may be updated during TTCAN operation.
0= External clock synchronization in TTCAN Level 0,2 disabled
1= External clock synchronization in TTCAN Level 0,2 enabled</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AWL</name>
                  <description>Application Watchdog Limit
The application watchdog can be disabled by programming AWL to 0x00.
0x00-FF Maximum time after which the application has to serve the application watchdog.
The application watchdog is incremented once each 256 NTUs.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EGTF</name>
                  <description>Enable Global Time Filtering
0= Global time filtering in TTCAN Level 0,2 is disabled
1= Global time filtering in TTCAN Level 0,2 is enabled</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ECC</name>
                  <description>Enable Clock Calibration
0= Automatic clock calibration in TTCAN Level 0,2 is disabled
1= Automatic clock calibration in TTCAN Level 0,2 is enabled</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EVTP</name>
                  <description>Event Trigger Polarity
0= Rising edge trigger
1= Falling edge trigger</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTMLM</name>
              <description>TT Matrix Limits</description>
              <addressOffset>0x10C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFF0FFF</resetMask>
              <fields>
                <field>
                  <name>CCM</name>
                  <description>N/A</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSS</name>
                  <description>N/A</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXEW</name>
                  <description>Tx Enable Window
0x0-F Length of Tx enable window, 1-16 NTU cycles</description>
                  <bitRange>[11:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENTT</name>
                  <description>Expected Number of Tx Triggers
0x000-FFF Expected number of Tx Triggers in one Matrix Cycle</description>
                  <bitRange>[27:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TURCF</name>
              <description>TUR Configuration</description>
              <addressOffset>0x110</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x10000000</resetValue>
              <resetMask>0xBFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>NCL</name>
                  <description>Numerator Configuration Low
Write access to the TUR Numerator Configuration Low is only possible during configuration with
TURCF.ELT = '0' or if TTOCF.EECS (external clock synchronization enabled) is set. When a new
value for NCL is written outside TT Configuration Mode, the new value takes effect when
TTOST.WECS is cleared to '0'. NCL is locked TTOST.WECS is '1'.
0x0000-FFFF Numerator Configuration Low</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DC</name>
                  <description>Denominator Configuration
0x0000 Illegal value
0x0001-3FFF Denominator Configuration</description>
                  <bitRange>[29:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELT</name>
                  <description>Enable Local Time
0= Local time is stopped, default
1= Local time is enabled</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTOCN</name>
              <description>TT Operation Control</description>
              <addressOffset>0x114</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xBFFF</resetMask>
              <fields>
                <field>
                  <name>SGT</name>
                  <description>Set Global time
Writing a '1' to SGT sets TTOST.WGDT if the node is the actual Time Master. SGT is reset after one
Host clock period. The global time preset takes effect when the node transmits the next reference
message with the Master_Ref_Mark modified by the preset value written to TTGTP.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ECS</name>
                  <description>External Clock Synchronization
Writing a '1' to ECS sets TTOST.WECS if the node is the actual Time Master. ECS is reset after one
Host clock period. The external clock synchronization takes effect at the start of the next basic cycle.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWP</name>
                  <description>Stop Watch Polarity
0= Rising edge trigger
1= Falling edge trigger</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWS</name>
                  <description>Stop Watch Source
00= Stop Watch disabled
01= Actual value of cycle time is copied to TTCPT.SWV
10= Actual value of local time is copied to TTCPT.SWV
11= Actual value of global time is copied to TTCPT.SWV</description>
                  <bitRange>[4:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTIE</name>
                  <description>Register Time Mark Interrupt Pulse Enable
Register time mark interrupts are configured by register TTTMK. A register time mark interrupt pulse
with the length of one NTU is generated when the time referenced by TTOCN.TMC (cycle, local, or
global) equals TTTMK.TM, independent of the synchronization state.
0= Register Time Mark Interrupt output m_ttcan_rtp disabled
1= Register Time Mark Interrupt output m_ttcan_rtp enabled</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TMC</name>
                  <description>Register Time Mark Compare
00= No Register Time Mark Interrupt generated
01= Register Time Mark Interrupt if Time Mark = cycle time
10= Register Time Mark Interrupt if Time Mark = local time
11= Register Time Mark Interrupt if Time Mark = global time</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTIE</name>
                  <description>Trigger Time Mark Interrupt Pulse Enable
External time mark events are configured by trigger memory element TMEX (see Section 2.4.7). A
trigger time mark interrupt pulse is generated when the trigger memory element becomes active,
and the M_TTCAN is in synchronization state In_Schedule or In_Gap.
0= Trigger Time Mark Interrupt output m_ttcan_tmp disabled
1= Trigger Time Mark Interrupt output m_ttcan_tmp enabled</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GCS</name>
                  <description>Gap Control Select
0= Gap control independent from m_ttcan_evt
1= Gap control by input pin m_ttcan_evt</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FGP</name>
                  <description>Finish Gap
Set by the CPU, reset by each reference message
0= No reference message requested
1= Application requested start of reference message</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TMG</name>
                  <description>Time Mark Gap
0= Reset by each reference message
1= Next reference message started when Register Time Mark interrupt TTIR.RTMI is activated</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NIG</name>
                  <description>Next is Gap
This bit can only be set when the M_TTCAN is the actual Time Master and when it is configured for
external event-synchronized time-triggered operation (TTOCF.GEN = '1')
0= No action, reset by reception of any reference message
1= Transmit next reference message with Next_is_Gap = '1'</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ESCN</name>
                  <description>External Synchronization Control
If enabled the M_TTCAN synchronizes its cycle time phase to an external event signaled by a rising
edge at pin m_ttcan_evt (see Section 4.11).
0= External synchronization disabled
1= External synchronization enabled</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LCKC</name>
                  <description>TT Operation Control Register Locked
Set by a write access to register TTOCN. Reset when the updated configuration has been
synchronized into the CAN clock domain.
0= Write access to TTOCN enabled
1= Write access to TTOCN locked</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTGTP</name>
              <description>TT Global Time Preset</description>
              <addressOffset>0x118</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TP</name>
                  <description>N/A</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CTP</name>
                  <description>Cycle Time Target Phase
CTP is write-protected while TTOCN.ESCN or TTOST.SPL are set (see Section 4.11).
0x0000-FFFF Defines target value of cycle time when a rising edge of m_ttcan_evt is expected</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTTMK</name>
              <description>TT Time Mark</description>
              <addressOffset>0x11C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x807FFFFF</resetMask>
              <fields>
                <field>
                  <name>TM_</name>
                  <description>Time Mark
0x0000-FFFF Time Mark</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TICC</name>
                  <description>Time Mark Cycle Code
Cycle count for which the time mark is valid.
0b000000x valid for all cycles
0b000001c valid every second cycle at cycle count mod2 = c
0b00001cc valid every fourth cycle at cycle count mod4 = cc
0b0001ccc valid every eighth cycle at cycle count mod8 = ccc
0b001cccc valid every sixteenth cycle at cycle count mod16 = cccc
0b01ccccc valid every thirty-second cycle at cycle count mod32 = ccccc
0b1cccccc valid every sixty-fourth cycle at cycle count mod64 = cccccc</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LCKM</name>
                  <description>TT Time Mark Register Locked
Always set by a write access to registers TTOCN. Set by write access to register TTTMK when
TTOCN.TMC != '00'. Reset when the registers have been synchronized into the CAN clock domain.
0= Write access to TTTMK enabled
1= Write access to TTTMK locked</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTIR</name>
              <description>TT Interrupt Register</description>
              <addressOffset>0x120</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>SBC</name>
                  <description>Start of Basic Cycle
0= No Basic Cycle started since bit has been reset
1= Basic Cycle started</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SMC</name>
                  <description>Start of Matrix Cycle
0= No Matrix Cycle started since bit has been reset
1= Matrix Cycle started</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSM_</name>
                  <description>Change of Synchronization Mode
0= No change in master to slave relation or schedule synchronization
1= Master to slave relation or schedule synchronization changed,
also set when TTOST.SPL is reset</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SOG</name>
                  <description>Start of Gap
0= No reference message seen with Next_is_Gap bit set
1= Reference message with Next_is_Gap bit set becomes valid</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTMI</name>
                  <description>Register Time Mark Interrupt
Set when time referenced by TTOCN.TMC (cycle, local, or global) equals TTTMK.TM, independent
of the synchronization state.
0= Time mark not reached
1= Time mark reached</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTMI</name>
                  <description>Trigger Time Mark Event Internal
Internal time mark events are configured by trigger memory element TMIN (see Section 2.4.7). Set
when the trigger memory element becomes active, and the M_TTCAN is in synchronization state
In_Gap or In_Schedule.
0= Time mark not reached
1= Time mark reached (Level 0: cycle time TTOCF.IRTO * 0x200)</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWE</name>
                  <description>Stop Watch Event
0= No rising/falling edge at stop watch trigger pin m_ttcan_swt detected
1= Rising/falling edge at stop watch trigger pin m_ttcan_swt detected</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTW</name>
                  <description>Global Time Wrap
0= No global time wrap occurred
1= Global time wrap from 0xFFFF to 0x0000 occurred</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTD</name>
                  <description>Global Time Discontinuity
0= No discontinuity of global time
1= Discontinuity of global time</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTE</name>
                  <description>Global Time Error
Synchronization deviation SD exceeds limit specified by TTOCF.LDSDL, TTCAN Level 0,2 only.
0= Synchronization deviation within limit
1= Synchronization deviation exceeded limit</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXU</name>
                  <description>Tx Count Underflow
0= Number of Tx Trigger as expected
1= Less Tx trigger than expected in one matrix cycle</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXO</name>
                  <description>Tx Count Overflow
0= Number of Tx Trigger as expected
1= More Tx trigger than expected in one matrix cycle</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE1</name>
                  <description>Scheduling Error 1
0= No scheduling error 1
1= Scheduling error 1 occurred</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE2</name>
                  <description>Scheduling Error 2
0= No scheduling error 2
1= Scheduling error 2 occurred</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELC</name>
                  <description>Error Level Changed
Not set when error level changed during initialization.
0= No change in error level
1= Error level changed</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IWT</name>
                  <description>Initialization Watch Trigger
The initialization is restarted by resetting IWT.
0= No missing reference message during system startup
1= No system startup due to missing reference message</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WT</name>
                  <description>Watch Trigger
0= No missing reference message
1= Missing reference message (Level 0: cycle time 0xFF00)</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AW</name>
                  <description>Application Watchdog
0= Application watchdog served in time
1= Application watchdog not served in time</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CER</name>
                  <description>Configuration Error
Trigger out of order.
0= No error found in trigger list
1= Error found in trigger list</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTIE</name>
              <description>TT Interrupt Enable</description>
              <addressOffset>0x124</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>SBCE</name>
                  <description>Start of Basic Cycle Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SMCE</name>
                  <description>Start of Matrix Cycle Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSME</name>
                  <description>Change of Synchronization Mode Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SOGE</name>
                  <description>Start of Gap Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTMIE</name>
                  <description>Register Time Mark Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTMIE</name>
                  <description>Trigger Time Mark Event Internal Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWEE</name>
                  <description>Stop Watch Event Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTWE</name>
                  <description>Global Time Wrap Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTDE</name>
                  <description>Global Time Discontinuity Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTEE</name>
                  <description>Global Time Error Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXUE</name>
                  <description>Tx Count Underflow Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXOE</name>
                  <description>Tx Count Overflow Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE1E</name>
                  <description>Scheduling Error 1 Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE2E</name>
                  <description>Scheduling Error 2 Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELCE</name>
                  <description>Change Error Level Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IWTE</name>
                  <description>Initialization Watch Trigger Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WTE</name>
                  <description>Watch Trigger Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AWE_</name>
                  <description>Application Watchdog Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CERE</name>
                  <description>Configuration Error Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTILS</name>
              <description>TT Interrupt Line Select</description>
              <addressOffset>0x128</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>SBCL</name>
                  <description>Start of Basic Cycle Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SMCL</name>
                  <description>Start of Matrix Cycle Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSML</name>
                  <description>Change of Synchronization Mode Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SOGL</name>
                  <description>Start of Gap Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTMIL</name>
                  <description>Register Time Mark Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTMIL</name>
                  <description>Trigger Time Mark Event Internal Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWEL</name>
                  <description>Stop Watch Event Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTWL</name>
                  <description>Global Time Wrap Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTDL</name>
                  <description>Global Time Discontinuity Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTEL</name>
                  <description>Global Time Error Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXUL</name>
                  <description>Tx Count Underflow Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXOL</name>
                  <description>Tx Count Overflow Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE1L</name>
                  <description>Scheduling Error 1 Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE2L</name>
                  <description>Scheduling Error 2 Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELCL</name>
                  <description>Change Error Level Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IWTL</name>
                  <description>Initialization Watch Trigger Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WTL</name>
                  <description>Watch Trigger Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AWL_</name>
                  <description>Application Watchdog Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CERL</name>
                  <description>Configuration Error Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTOST</name>
              <description>TT Operation Status</description>
              <addressOffset>0x12C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x80</resetValue>
              <resetMask>0xFFC0FFFF</resetMask>
              <fields>
                <field>
                  <name>EL</name>
                  <description>Error Level
00= Severity 0 - No Error
01= Severity 1 - Warning
10= Severity 2 - Error
11= Severity 3 - Severe Error</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MS</name>
                  <description>Master State
00= Master_Off, no master properties relevant
01= Operating as Time Slave
10= Operating as Backup Time Master
11= Operating as current Time Master</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SYS</name>
                  <description>Synchronization State
00= Out of Synchronization
01= Synchronizing to TTCAN communication
10= Schedule suspended by Gap (In_Gap)
11= Synchronized to schedule (In_Schedule)</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>QGTP</name>
                  <description>Quality of Global Time Phase
Only relevant in TTCAN Level 0 and Level 2, otherwise fixed to '0'.
0= Global time not valid
1= Global time in phase with Time Master</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>QCS</name>
                  <description>Quality of Clock Speed
Only relevant in TTCAN Level 0 and Level 2, otherwise fixed to '1'.
0= Local clock speed not synchronized to Time Master clock speed
1= Synchronization Deviation &lt;= SDL</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RTO</name>
                  <description>Reference Trigger Offset
The Reference Trigger Offset value is a signed integer with a range from -127 (0x81) to 127 (0x7F).
There is no notification when the lower limit of -127 is reached. In case the M_TTCAN becomes
Time Master (MS[1:0] = '11'), the reset of RTO is delayed due to synchronization between Host and
CAN clock domain. For time slaves the value configured by TTOCF.IRTO is read.
0x00-FF Actual Reference Trigger offset value</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WGTD</name>
                  <description>Wait for Global Time Discontinuity
0= No global time preset pending
1= Node waits for the global time preset to take effect. The bit is reset when the node has transmitted
a reference message with Disc_Bit = '1' or after it received a reference message.</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GFI</name>
                  <description>Gap Finished Indicator
Set when the CPU writes TTOCN.FGP, or by a time mark interrupt if TMG = '1', or via input pin
m_ttcan_evt if TTOCN.GCS = '1'. Not set by Ref_Trigger_Gap or when Gap is finished by another
node sending a reference message.
0= Reset at the end of each reference message
1= Gap finished by M_TTCAN</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TMP</name>
                  <description>Time Master Priority
0x0-7 Priority of actual Time Master</description>
                  <bitRange>[26:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GSI</name>
                  <description>Gap Started Indicator
0= No Gap in schedule, reset by each reference message and for all time slaves
1= Gap time after Basic Cycle has started</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WFE</name>
                  <description>Wait for Event
0= No Gap announced, reset by a reference message with Next_is_Gap = '0'
1= Reference message with Next_is_Gap = '1' received</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>AWE</name>
                  <description>Application Watchdog Event
The application watchdog is served by reading TTOST. When the watchdog is not served in time,
bit AWE is set, all TTCAN communication is stopped, and the M_TTCAN is set into Bus Monitoring
Mode.
0= Application Watchdog served in time
1= Failed to serve Application Watchdog in time</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WECS</name>
                  <description>Wait for External Clock Synchronization
0= No external clock synchronization pending
1= Node waits for external clock synchronization to take effect. The bit is reset at the start of the
next basic cycle.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SPL</name>
                  <description>Schedule Phase Lock
The bit is valid only when external synchronization is enabled (TTOCN.ESCN = '1'). In this case it
signals that the difference between cycle time configured by TTGTP.CTP and the cycle time at the
rising edge at pin m_ttcan_evt is less or equal 9 NTU (see Section 4.11).
0= Phase outside range
1= Phase inside range</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TURNA</name>
              <description>TUR Numerator Actual</description>
              <addressOffset>0x130</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x10000</resetValue>
              <resetMask>0x3FFFF</resetMask>
              <fields>
                <field>
                  <name>NAV</name>
                  <description>N/A</description>
                  <bitRange>[17:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTLGT</name>
              <description>TT Local &amp; Global Time</description>
              <addressOffset>0x134</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LT</name>
                  <description>Local Time
Non-fractional part of local time, incremented once each local NTU (see Section 4.5).
0x0000-FFFF Local time value of TTCAN node</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GT</name>
                  <description>Global Time
Non-fractional part of the sum of the node's local time and its local offset (see Section 4.5).
0x0000-FFFF Global time value of TTCAN network</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTCTC</name>
              <description>TT Cycle Time &amp; Count</description>
              <addressOffset>0x138</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x3F0000</resetValue>
              <resetMask>0x3FFFFF</resetMask>
              <fields>
                <field>
                  <name>CT</name>
                  <description>Cycle Time
Non-fractional part of the difference of the node's local time and Ref_Mark (see Section 4.5).
0x0000-FFFF Cycle time value of TTCAN Basic Cycle</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CC</name>
                  <description>Cycle Count
0x00-3F Number of actual Basic Cycle in the System Matrix</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTCPT</name>
              <description>TT Capture Time</description>
              <addressOffset>0x13C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF003F</resetMask>
              <fields>
                <field>
                  <name>CCV</name>
                  <description>Cycle Count Value
Cycle count value captured together with SWV.
0x00-3F Captured cycle count value</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SWV</name>
                  <description>Stop Watch Value
On a rising/falling edge (as configured via TTOCN.SWP) at the Stop Watch Trigger pin m_ttcan_swt, when TTOCN.SWS is != '00' and TTIR.SWE is '0', the actual time value as selected
by TTOCN.SWS (cycle, local, global) is copied to SWV and TTIR.SWE will be set to '1'. Capturing of the next stop watch value is enabled by resetting TTIR.SWE.
0x0000-FFFF Captured Stop Watch value</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTCSM</name>
              <description>TT Cycle Sync Mark</description>
              <addressOffset>0x140</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>CSM</name>
                  <description>Cycle Sync Mark
The Cycle Sync Mark is measured</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
          <register>
            <name>RXFTOP_CTL</name>
            <description>Receive FIFO Top control</description>
            <addressOffset>0x180</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>F0TPE</name>
                <description>FIFO 0 Top Pointer Enable. 
This enables the FIFO top pointer logic to set the FIFO Top Address (FnTA) and message word counter.
This logic is also disabled when the IP is being reconfigured (CCCR.CCE=1).
When this logic is disabled a Read from RXFTOP0_DATA is undefined.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>F1TPE</name>
                <description>FIFO 1 Top Pointer Enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP0_STAT</name>
            <description>Receive FIFO 0 Top Status</description>
            <addressOffset>0x1A0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>F0TA</name>
                <description>Current FIFO 0 Top Address.
This is a pointer to the next word in the message buffer defined by the FIFO Start Address (FnSA), Get Index (FnGI), the FIFO message size (FnDS) and the message word counter (FnMWC)
FnTA = FnSA + FnGI * msg_size[FnDS] + FnMWC</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP0_DATA</name>
            <description>Receive FIFO 0 Top Data</description>
            <addressOffset>0x1A8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>F0TD</name>
                <description>When enabled (F0TPE=1) read data from MRAM at location FnTA. This register can have a read side effect if the following conditions are met:
- M_TTCAN not being reconfigured (CCCR.CCE=0)
- FIFO Top Pointer logic is enabled (FnTPE=1)
- FIFO is not empty (FnFL!=0)
The read side effect is as follows:
- if FnMWC pointed to the last word of the message (as indicated by FnDS) then the corresponding message index (FnGI) is automatically acknowledge by a write to FnAI
- FnMWC is incremented (or restarted if FnMWC pointed to the last word of the message)
- the FIFO top address FnTA is incremented (with FIFO wrap around) 
When this logic is disabled (F0TPE=0) a Read from this register returns undefined data.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP1_STAT</name>
            <description>Receive FIFO 1 Top Status</description>
            <addressOffset>0x1B0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>F1TA</name>
                <description>See F0TA description</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP1_DATA</name>
            <description>Receive FIFO 1 Top Data</description>
            <addressOffset>0x1B8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>F1TD</name>
                <description>See F0TD description</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>CTL</name>
          <description>Global CAN control register</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x800000FF</resetMask>
          <fields>
            <field>
              <name>STOP_REQ</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MRAM_OFF</name>
              <description>MRAM off
0= Default MRAM on (with MRAM retained in DeepSleep).
1= Switch MRAM off (not retained) to save power. Before setting this bit all the CAN channels have to be powered down using the STOP_REQ/ACK bits.
When the MRAM is off any access attempt to it is considered an address error (as if MRAM_SIZE=0).
After switching the MRAM on again software needs to allow for a certain power up time before MRAM can be used, i.e. before STOP_REQ can be de-asserted. The power up time is equivalent to the system SRAM power up time specified in the CPUSS.RAM_PWR_DELAY_CTL register.

MRAM_OFF should be set to 0 prior to transitioning to Hibernate mode.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Global CAN status register</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>STOP_ACK</name>
              <description>Clock Stop Acknowledge for each TTCAN IP.
These bits are directly driven by m_ttcan_clkstop_ack of each TTCAN IP.
When this bit is set the corresponding TTCAN IP clocks will be gated off, except HCLK will enabled for each AHB write</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR0_CAUSE</name>
          <description>Consolidated interrupt0 cause register</description>
          <addressOffset>0x1010</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>INT0</name>
              <description>Show pending m_ttcan_int0 of each channel</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR1_CAUSE</name>
          <description>Consolidated interrupt1 cause register</description>
          <addressOffset>0x1014</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>INT1</name>
              <description>Show pending m_ttcan_int1 of each channel</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TS_CTL</name>
          <description>Time Stamp control register</description>
          <addressOffset>0x1020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000FFFF</resetMask>
          <fields>
            <field>
              <name>PRESCALE</name>
              <description>Time Stamp counter prescale value. 
When enabled divide the Host clock (HCLK) by PRESCALE+1 to create Time Stamp clock ticks.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Counter enable bit
0 = Count disabled. Stop counting up and keep the counter value
1 = Count enabled. Start counting up from the current value</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TS_CNT</name>
          <description>Time Stamp counter value</description>
          <addressOffset>0x1024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>The counter value of the Time Stamp Counter.
When enabled this counter will count Time Stamp clock ticks from the pre-scaler.
When written this counter and the pre-scaler will reset to 0 (write data is ignored).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x1080</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10000</resetMask>
          <fields>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC for CANFD SRAM
When disabled also all error injection functionality is disabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_ERR_INJ</name>
          <description>ECC error injection</description>
          <addressOffset>0x1084</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFC</resetValue>
          <resetMask>0x7F10FFFC</resetMask>
          <fields>
            <field>
              <name>ERR_ADDR</name>
              <description>Specifies the address of the word where an error will be injected on write or an non-correctable error will be suppressed.
When the ERR_EN bit is set an error parity (ERR_PAR) is injected when any write, from bus or a CAN channel, is done to this address.
When the ERR_EN bit is set and the access address matches ERR_ADDR then a non-correctable ECC error or an Address error will NOT result in a bus error or CAN channel shutdown.
Note that error reporting to the fault structure cannot be suppressed.</description>
              <bitRange>[15:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_EN</name>
              <description>Enable error injection (ECC_EN must be 1).
When this bit is set the error parity (ERR_PAR) will be used when an AHB write is done to the ERR_ADDR address.
When the error word is read a single or double error will be reported to the fault structure just like for a real ECC error (even if this bit is no longer set).
When this bit is set (and ECC_EN=1) a non-correctable error (ECC or address error) for the ERR_ADDR will not be reported back to the CAN channel or  AHB bus.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_PAR</name>
              <description>ECC Parity bits to use for ECC error injection at address ERR_ADDR.</description>
              <bitRange>[30:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TDM0</name>
      <description>TDM</description>
      <headerStructName>TDM</headerStructName>
      <baseAddress>0x405A0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <name>TDM_STRUCT</name>
          <description>TDM structure</description>
          <addressOffset>0x00008000</addressOffset>
          <cluster>
            <name>TDM_TX_STRUCT</name>
            <description>TDM TX structure</description>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>TX_CTL</name>
              <description>TX control</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x10000</resetValue>
              <resetMask>0x8001300F</resetMask>
              <fields>
                <field>
                  <name>WORD_SIZE</name>
                  <description>N/A</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SIZE_8</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_10</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_12</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_14</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_16</name>
                      <description>N/A</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_18</name>
                      <description>N/A</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_20</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_24</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_32</name>
                      <description>N/A</description>
                      <value>8</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>FORMAT</name>
                  <description>N/A</description>
                  <bitRange>[13:12]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>LEFT_DELAYED</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LEFT</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RIGHT_DELAYED</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RIGHT</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>MS</name>
                  <description>Master/slave setting:
'0': Slave.
- Externally driven signals: 'tdm_tx_sck_in' and frame sync 'tdm_tx_fsync_in'
'1': Master.
- Interface clock 'clk_if' is used to generate transmitter 'tdm_tx_sck_out' and transmitter 'tdm_tx_fsync_out'.</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SLAVE</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>MASTER</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>ENABLED</name>
                  <description>Transmitter (TX) enable:
'0': Disabled. All non-retained MMIO registers (e.g. the TX_FIFO_STATUS and INTR_TX registers) have their fields reset to their default value.
'1': Enabled.

Note: when all transmitters and receivers are disabled, the SRAMs are driven into low power mode, if supported by the SRAM. When exiting such low power mode software needs to allow for a certain power up time before SRAM can be used, i.e. before ACTIVE can be asserted.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TX_IF_CTL</name>
              <description>TX interface control</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1F018707</resetValue>
              <resetMask>0x9F1FB7FF</resetMask>
              <fields>
                <field>
                  <name>CLOCK_DIV</name>
                  <description>Interface clock divider (legal range [1, 255]). The TDM interface 'tdm_tx_sck_out' output signal is defined as clk_if / (CLOCK_DIV + 1). CLOCK_DIV should be set to an odd value ({1, 3, 5, ..., 255}), to ensure a 50/50 percent duty cycle  clock.

Note: Used in master configuration only.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CLOCK_SEL</name>
                  <description>Interface clock 'clk_if' selection:
'0': SRSS clock clk_if_srss[0].
'1': SRSS clock clk_if_srss[1].
'2': SRSS clock clk_if_srss[2].
'3': SRSS clock clk_if_srss[3].
'4': Master interface clock 'tdm_tx_mck_in'.
'5'-'7': undefined.

Note: the application is always required to program this field to a value different from the default.</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SEL_SRSS_CLOCK0</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SEL_SRSS_CLOCK1</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SEL_SRSS_CLOCK2</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SEL_SRSS_CLOCK3</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SEL_TDM_TX_MCK_IN</name>
                      <description>N/A</description>
                      <value>4</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>SCK_POLARITY</name>
                  <description>Clock polarity:
'0': Clock signal is used 'as is'.
'1': Clock signal is inverted.

Note: Used in BOTH master and slave configurations.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FSYNC_POLARITY</name>
                  <description>Channel synchronization polarity:
'0': Channel synchronization signal is used 'as is'.
'1': Channel synchronization signal is inverted.

Note: Used in BOTH master and slave configurations.</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FSYNC_FORMAT</name>
                  <description>Channel synchronization pulse format:
'0': Duration of a single bit period.
'1': Duration of the first channel.</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>BIT_PERIOD</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CH_PERIOD</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CH_NR</name>
                  <description>Number of channels in the frame:
'0': Undefined/illegal.
'1': 2 channels.
'2': 3 channels.
...
'31': 32 channels.

Note: the field value should be less than CH_NR (the number of support channels).

Note: the TX_CH_CTL.CH_EN fields can be used to enable/disable indvidual channels.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CH_SIZE</name>
                  <description>Channel size:
'0'-'2': Undefined/illegal.
'3': 4 bits.
...
'31': 32 bits.

Note: if TX_CTL.WORD_SIZE is greater than CH_SIZE, the more significant bits of the word are transmitted and the lesser significant bits of the word are dropped.</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SIZE_1</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_2</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_32</name>
                      <description>N/A</description>
                      <value>31</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>I2S_MODE</name>
                  <description>I2S mode setting:
'0': TDM mode.
'1': I2S mode.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>TDM</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>I2S</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>TX_CH_CTL</name>
              <description>TX channel control</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CH_EN</name>
                  <description>Channel enables: channel i is controlled by CH_EN[i].
'0': Disabled. The TX FIFO does not produce channel i words and the transmitted channel i words on the interface are not driven (the output enable of the 'tdm_tx_sd_out' output signal is not driven).
'1': Enabled.

Note: Only bit 0 through TX_IF_CTL.CH_NR may be set to '1'; i.e. only channels that are present in the frame can be enabled.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TX_TEST_CTL</name>
              <description>TX test control</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x80000000</resetMask>
              <fields>
                <field>
                  <name>ENABLED</name>
                  <description>Test mode enable.
'0': Disabled. Functional mode.
- Transmitter tx_sck_in = IOSS tdm_tx_sck_in.
- Transmitter tx_fsync_in = IOSS tdm_tx_fsync_in.
- Receiver rx_sd_in = IOSS tdm_rx_sd_in.
'1': Enabled. Test mode (intended to be used with (slave transmitter, master receiver) configuration).
- Transmitter tx_sck_in = Receiver tdm_rx_sck_out.
- Transmitter tx_fsync_in = Receiver tdm_rx_fsync_out.
- Receiver rx_sd_in = Transmitter tdm_tx_sd_out.

Note: TX_TEST_CTL.ENABLED and RX_TEST_CTL.ENABLED should not be set to '1' simultaneously.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>FUNCTIONAL</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TEST</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>TX_ROUTE_CTL</name>
              <description>TX route control</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>MODE</name>
                  <description>Controls routing to the TX slave signalling inputs (FSYNC/SCK):
'0': TX slave signaling indipendent from RX signaling:
- Transmitter tx_sck_in = IOSS tdm_tx_sck_in
- Transmitter tx_fsync_in = IOSS tdm_tx_fsync_in
'1': TX slave signalling inputs driven by RX Slave:
- Transmitter tx_sck_in = IOSS tdm_rx_sck_in
- Transmitter tx_fsync_in = IOSS tdm_rx_fsync_in
'2': TX slave signalling inputs driven by RX Master:
- Transmitter tx_sck_in = receiver tdm_rx_sck_out
- Transmitter tx_fsync_in = receiver tdm_rx_fsync_out

Note: MODE=0 is the default behaviour. MODE=1 or 2 is intended to allow the TX slave to share the same signaling used by the RX. This feature can be used to reduce the number of IO pins necessary to connect to an external codec supporting common TX/RX signaling. 

Note: when MODE=1 or 2, TX_TEST_CTL.ENABLED and RX_TEST_CTL.ENABLED should not be set to '1'.</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>TX_IN_DRIVEN_BY_IOSS_TX_IN</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TX_IN_DRIVEN_BY_IOSS_RX_IN</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TX_IN_DRIVEN_BY_RX_OUT</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>TX_FIFO_CTL</name>
              <description>TX FIFO control</description>
              <addressOffset>0x80</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xF007F</resetMask>
              <fields>
                <field>
                  <name>TRIGGER_LEVEL</name>
                  <description>Trigger level. When the TX FIFO has less entries than the number of this field, a transmitter trigger event is generated:
- INTR_TX.FIFO_TRIGGER = (# FIFO entries &lt; TRIGGER_LEVEL)</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUTE</name>
                  <description>Mute functionality:
'0': HW uses TX FIFO data.
'1': HW uses a constant PCM data value of '0'. Mute does advance the FIFO read pointer.

Note: HW ensures that mute functionality synchronizes on the first channel of a frame to ensure that either all or none of the frame's channels are muted.</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FREEZE</name>
                  <description>Freeze functionality:
'0': HW uses TX FIFO data and advances the FIFO read pointer.
'1': HW uses a constant PCM data value of '0' or the previous channel PCM data is replayed. Freeze does not advance the FIFO read pointer (the FIFO data is not used).

Note: HW ensures that freeze functionality synchronizes on the first channel of a frame to ensure that PCM data of one channel is not misassigned to another channel. As a result, the freeze functionality can be activated at any time.

Note: This functionality is intended for debugging purposes.</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ACTIVE</name>
                  <description>Activate functionality:
'0': Transmitter off. The FIFO_UNDERFLOW interrupt cause will not be activated.
'1': Transmitter on. The FIFO_UNDERFLOW interrupt may be activated (when an underflow event occurs).

Note: This functionality is intended for startup purposes.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REPLAY</name>
                  <description>Replay functionality (used when FREEZE is '1' or in case of a FIFO underflow event):
'0': HW uses a constant PCM data value of '0'.
'1': HW uses the previous PCM data value.</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TX_FIFO_STATUS</name>
              <description>TX FIFO status</description>
              <addressOffset>0x84</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F7F00FF</resetMask>
              <fields>
                <field>
                  <name>USED</name>
                  <description>Number of used/occupied entries in the TX FIFO. The field value is in the range [0, 128]. When '0', the FIFO is empty. When '128', the FIFO is full.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RD_PTR</name>
                  <description>TX FIFO read pointer: FIFO location from which a data is read.

Note: This functionality is intended for debugging purposes.</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WR_PTR</name>
                  <description>TX FIFO write pointer: FIFO location at which a new data is written by the hardware.

Note: This functionality is intended for debugging purposes.</description>
                  <bitRange>[30:24]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TX_FIFO_WR</name>
              <description>TX FIFO write</description>
              <addressOffset>0x88</addressOffset>
              <size>32</size>
              <access>write-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DATA</name>
                  <description>Data (PCM sample) written to the TX FIFO. Writing adds the data to the TX FIFO; i.e. behavior is similar to that of a PUSH operation (TX_FIFO_STATUS.WR_PTR is incremented and TX_FIFO_STATUS.USED is incremented). The write data (DATA) should be right aligned when it is written to the FIFO entry (data[31:0]):
- 8 bit, data[31:0] = DATA[7:0] &lt;&lt; 24.
- 10 bit, data[31:0] = DATA[9:0] &lt;&lt; 22.
- 12 bit, data[31:0] = DATA[11:0] &lt;&lt; 20.
- 14 bit, data[31:0] = DATA[13:0] &lt;&lt; 18.
- 16 bit, data[31:0] = DATA[15:0] &lt;&lt; 16.
- 18 bit, data[31:0] = DATA[17:0] &lt;&lt; 14.
- 20 bit, data[31:0] = DATA[19:0] &lt;&lt; 12.
- 24 bit, data[31:0] = DATA[23:0] &lt;&lt; 8.
- 32 bit, data[31:0] = DATA[31:0].

Note: Writing to a full TX FIFO activates INTR.TX_FIFO_OVERFLOW.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>write-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_TX</name>
              <description>Interrupt</description>
              <addressOffset>0xC0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x107</resetMask>
              <fields>
                <field>
                  <name>FIFO_TRIGGER</name>
                  <description>HW sets this field to '1', when a TX trigger is generated.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIFO_OVERFLOW</name>
                  <description>HW sets this field to '1', when writing to a full TX FIFO (TX_FIFO_STATUS.USED is '128').</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIFO_UNDERFLOW</name>
                  <description>HW sets this field to '1', when reading from an (almost) empty TX FIFO (TX_FIFO_STATUS.USED &lt; 'number of enabled channels per frame'). This is referred to as an underflow event.

Note: HW ensures that either all or none of the frame's channels are transmitted. In a TX FIFO underflow situation, HW replays previous PCM data or uses a constant PCM data value of '0'.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IF_UNDERFLOW</name>
                  <description>HW sets this field to '1', when PCM samples are not generated in time for the interface logic (interface underflow). This may be an indication that the IP system frequency is too low wrt. the interface frequency (a SW configuration error). The interface underflow is a non-recoverable error and requires SW disabling of the channel (a SW write to INTR_TX.IF_UNDERFLOW does not resolve the interface underflow). 

Note: This functionality is intended for debug purposes.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_TX_SET</name>
              <description>Interrupt set</description>
              <addressOffset>0xC4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x107</resetMask>
              <fields>
                <field>
                  <name>FIFO_TRIGGER</name>
                  <description>Write this field with '1' to set corresponding INTR_TX field (a write of '0' has no effect).</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIFO_OVERFLOW</name>
                  <description>Write this field with '1' to set corresponding INTR_TX field (a write of '0' has no effect).</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIFO_UNDERFLOW</name>
                  <description>Write this field with '1' to set corresponding INTR_TX field (a write of '0' has no effect).</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IF_UNDERFLOW</name>
                  <description>Write this field with '1' to set corresponding INTR_TX field (a write of '0' has no effect).</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_TX_MASK</name>
              <description>Interrupt mask</description>
              <addressOffset>0xC8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x107</resetMask>
              <fields>
                <field>
                  <name>FIFO_TRIGGER</name>
                  <description>Mask for corresponding field in INTR_TX register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIFO_OVERFLOW</name>
                  <description>Mask for corresponding field in INTR_TX register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIFO_UNDERFLOW</name>
                  <description>Mask for corresponding field in INTR_TX register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IF_UNDERFLOW</name>
                  <description>Mask for corresponding field in INTR_TX register.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_TX_MASKED</name>
              <description>Interrupt masked</description>
              <addressOffset>0xCC</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x107</resetMask>
              <fields>
                <field>
                  <name>FIFO_TRIGGER</name>
                  <description>Logical AND of corresponding INTR_TX and INTR_TX_MASK fields.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FIFO_OVERFLOW</name>
                  <description>Logical AND of corresponding INTR_TX and INTR_TX_MASK fields.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FIFO_UNDERFLOW</name>
                  <description>Logical AND of corresponding INTR_TX and INTR_TX_MASK fields.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>IF_UNDERFLOW</name>
                  <description>Logical AND of corresponding INTR_TX and INTR_TX_MASK fields.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
          <cluster>
            <name>TDM_RX_STRUCT</name>
            <description>TDM RX structure</description>
            <addressOffset>0x00000100</addressOffset>
            <register>
              <name>RX_CTL</name>
              <description>RX control</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x100</resetValue>
              <resetMask>0x8001310F</resetMask>
              <fields>
                <field>
                  <name>WORD_SIZE</name>
                  <description>N/A</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SIZE_8</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_10</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_12</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_14</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_16</name>
                      <description>N/A</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_18</name>
                      <description>N/A</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_20</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_24</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_32</name>
                      <description>N/A</description>
                      <value>8</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>WORD_SIGN_EXTEND</name>
                  <description>N/A</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>ZERO_EXTEND</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIGN_EXTEND</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>FORMAT</name>
                  <description>N/A</description>
                  <bitRange>[13:12]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>LEFT_DELAYED</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LEFT</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RIGHT_DELAYED</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RIGHT</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>MS</name>
                  <description>Master/slave setting:
'0': Slave.
- Externally driven signas: clock 'tdm_rx_sck_in' and frame sync 'tdm_rx_fsync_in'.
'1': Master.
- Interface clock 'clk_if' is used to generate receiver 'tdm_rx_sck_out' and receiver 'tdm_rx_fsync_out'.</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SLAVE</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>MASTER</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>ENABLED</name>
                  <description>Receiver (RX) enable:
'0': Disabled. All non-retained MMIO registers (e.g. the RX_FIFO_STATUS and INTR_RX registers) have their fields reset to their default value.
'1': Enabled.

Note: when all transmitters and receivers are disabled, the SRAMs are driven into low power mode, if supported by the SRAM. When exiting such low power mode software needs to allow for a certain power up time before SRAM can be used, i.e. before ACTIVE can be asserted.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RX_IF_CTL</name>
              <description>RX interface control</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1F018707</resetValue>
              <resetMask>0xFF1FF7FF</resetMask>
              <fields>
                <field>
                  <name>CLOCK_DIV</name>
                  <description>Interface clock divider (legal range [1, 255]). The TDM interface 'tdm_rx_sck_out' output signals is defined as clk_if / (CLOCK_DIV + 1). CLOCK_DIV should be set to an odd value ({1, 3, 5, ..., 255}), to ensure a 50/50 percent duty cycle  clock.

Note: Used in master configuration only.

Note: Due to delays in the IO SubSystem (specifically the IO cells), the maximum TDM interface clock 'tdm_rx_sck_out' may be restricted. As a result, the maximum bitrate is less than the theoretical maximum (32 channels, 32 bits per channel and a high Fs of e.g. 48 kHz). This restriction is most applicable to the master, receiver configuration.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CLOCK_SEL</name>
                  <description>Interface clock 'clk_if' selection:
'0': SRSS clock clk_if_srss[0].
'1': SRSS clock clk_if_srss[1].
'2': SRSS clock clk_if_srss[2].
'3': SRSS clock clk_if_srss[3].
'4': Master interface clock 'tdm_rx_mck_in'.
'5'-'7': undefined. 

Note: the application is always required to program this field to a value different from the default.</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SEL_SRSS_CLOCK0</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SEL_SRSS_CLOCK1</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SEL_SRSS_CLOCK2</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SEL_SRSS_CLOCK3</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SEL_TDM_RX_MCK_IN</name>
                      <description>N/A</description>
                      <value>4</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>SCK_POLARITY</name>
                  <description>Clock polarity:
'0': Clock signal is used 'as is'.
'1': Clock signal is inverted.

Note: Used in BOTH master and slave configurations.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FSYNC_POLARITY</name>
                  <description>Channel synchronization polarity:
'0': Channel synchronization signal is used 'as is'.
'1': Channel synchronization signal is inverted.

Note: Used in BOTH master and slave configurations.</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LATE_SAMPLE</name>
                  <description>Interface late sample sample delay:
Slave configuration (RX_CTL.MS is '0').
'0': Sample PCM bit value on rising edge (SCK_POLARITY is '0') or falling edge (SCK_POLARITY is '1') of receiver 'rx_sck_in'.
'1': Sample PCM bit value on falling edge  (SCK_POLARITY is '0') or rising edge (SCK_POLARITY is '1') of receiver 'rx_sck_in' (half a cycle delay).

Master configuration (RX_CTL.MS is '1').
'0': Sample PCM bit value on rising edge (SCK_POLARITY is '0') or falling edge (SCK_POLARITY is '1') of receiver 'rx_sck_out'.
'1': Sample PCM bit value on falling edge  (SCK_POLARITY is '0') or rising edge (SCK_POLARITY is '1') of receiver 'rx_sck_out' (half a cycle delay).

Note: This field can be set to '1' when the roundtrip delay is large (typically) in a master receiver configuration.</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>FSYNC_FORMAT</name>
                  <description>Channel synchronization pulse format:
'0': Duration of a single bit period.
'1': Duration of the first channel.</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>BIT_PERIOD</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CH_PERIOD</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CH_NR</name>
                  <description>Number of channels in the frame:
'0': Undefined/illegal.
'1': 2 channels.
'2': 3 channels.
...
'31': 32 channels.

Note: the field value chould be less than CH_NR (the number of support channels).

Note: the RX_CH_CTL.CH_EN fields can be used to enable/disable indvidual channels.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CH_SIZE</name>
                  <description>Channel size:
'0'-'2': Undefined/illegal.
'3': 4 bits.
...
'31': 32 bits.

Note: if RX_CTL.WORD_SIZE is greater than CH_SIZE, the lesser significant bits of the word are filled with '0's.</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SIZE_1</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_2</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIZE_32</name>
                      <description>N/A</description>
                      <value>31</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>LATE_CAPTURE</name>
                  <description>Extra delay (in 'rx_sck_out' cycles) for capturing 'tdm_rx_sd_in':
'0': no extra delay
'1': 1 cycle extra delay
'2': 2 cycles extra delay
'3': 3 cycles extra delay

Note: the value of this field pushes further out the capturing edges used by the receiver to sample 'tdm_rx_sd_in'. This function is intended to support very large round-trip delays in a master receiver configuration, where the delay at the receiver between 'tdm_rx_fsync_out' and the arrival of the first bit on 'tdm_rx_sd_in' is multiple clock cycles.</description>
                  <bitRange>[30:29]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>EXTRA_DELAY_0</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>EXTRA_DELAY_1</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>EXTRA_DELAY_2</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>EXTRA_DELAY_3</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>I2S_MODE</name>
                  <description>I2S mode setting:
'0': TDM mode.
'1': I2S mode.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>TDM</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>I2S</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>RX_CH_CTL</name>
              <description>RX channel control</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CH_EN</name>
                  <description>Channel enables: channel i is controlled by CH_EN[i].
'0': Disabled. The RX FIFO does not consume channel i words and the received channel i words on the interface are discarded.
'1': Enabled..

Note: Only bit 0 through RX_IF_CTL.CH_NR may be set to '1'; i.e. only channels that are present in the frame can be enabled.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RX_TEST_CTL</name>
              <description>RX test control</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x80000000</resetMask>
              <fields>
                <field>
                  <name>ENABLED</name>
                  <description>Test mode enable.
'0': Disabled. Functional mode.
- Receiver rx_sck_in = IOSS tdm_rx_sck_in.
- Receiver rx_fsync_in = IOSS tdm_rx_fsync_in.
- Receiver rx_sd_in = IOSS tdm_rx_sd_in.
'1': Enabled. Test mode (intended to be used with (master transmitter, slave receiver) configuration).
- Receiver rx_sck_in = Transmitter tdm_tx_sck_out.
- Receiver rx_fsync_in = Transmitter tdm_tx_fsync_out.
- Receiver rx_sd_in = Transmitter tdm_tx_sd_out.

Note: TX_TEST_CTL.ENABLED and RX_TEST_CTL.ENABLED should not be set to '1' simultaneously.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>FUNCTIONAL</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TEST</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>RX_ROUTE_CTL</name>
              <description>RX route control</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>MODE</name>
                  <description>Controls routing to the RX slave signalling inputs (FSYNC/SCK):
'0': RX slave signaling indipendent from TX signaling:
- Receiver rx_sck_in = IOSS tdm_rx_sck_in
- Receiver rx_fsync_in = IOSS tdm_rx_fsync_in
'1': RX slave signalling inputs driven by TX Slave:
- Receiver rx_sck_in = IOSS tdm_tx_sck_in
- Receiver rx_fsync_in = IOSS tdm_tx_fsync_in
'2': RX slave signalling inputs driven by TX Master:
- Receiver rx_sck_in = transmitter tdm_tx_sck_out
- Receiver rx_fsync_in = transmitter tdm_tx_fsync_out

Note: MODE=0 is the default behaviour. MODE=1 or 2 is intended to allow the RX slave to share the same signaling used by the TX. This feature can be used to reduce the number of IO pins necessary to connect to an external codec supporting common TX/RX signaling. 

Note: when MODE=1 or 2, TX_TEST_CTL.ENABLED and RX_TEST_CTL.ENABLED should not be set to '1'.</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RX_IN_DRIVEN_BY_IOSS_RX_IN</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RX_IN_DRIVEN_BY_IOSS_TX_IN</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RX_IN_DRIVEN_BY_TX_OUT</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>RX_FIFO_CTL</name>
              <description>RX FIFO control</description>
              <addressOffset>0x80</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x6007F</resetMask>
              <fields>
                <field>
                  <name>TRIGGER_LEVEL</name>
                  <description>Trigger level. When the RX FIFO has more entries than the number of this field, a receiver trigger event is generated:
- INTR_RX.FIFO_TRIGGER = (# FIFO entries &gt; TRIGGER_LEVEL)</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FREEZE</name>
                  <description>Freeze functionality:
'0': HW writes to the RX FIFO and advances the FIFO write pointer.
'1': HW writes from the RX FIFO have no effect: freeze will not advance the FIFO write pointer.

Note: HW ensures that freeze functionality synchronizes on the first channel of a frame to ensure that PCM data of one channel is not misassigned to another channel. As a result, the freeze functionality can be activated at any time.

Note: This functionality is intended for debugging purposes.</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ACTIVE</name>
                  <description>Activate functionality:
'0': Receiver off. The FIFO_OVERFLOW interrupt cause will not be activated.
'1': Receiver on. The FIFO_OVERFLOW interrupt may be activated (when an overflow event occurs).

Note: This functionality is intended for stopping purposes.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RX_FIFO_STATUS</name>
              <description>RX FIFO status</description>
              <addressOffset>0x84</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F7F00FF</resetMask>
              <fields>
                <field>
                  <name>USED</name>
                  <description>Number of used/occupied entries in the RX FIFO. The field value is in the range [0, 128]. When '0', the FIFO is empty. When '128', the FIFO is full.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RD_PTR</name>
                  <description>RX FIFO read pointer: FIFO location from which a data is read.

Note: This functionality is intended for debugging purposes.</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WR_PTR</name>
                  <description>RX FIFO write pointer: FIFO location at which a new data is written by the hardware.

Note: This functionality is intended for debugging purposes.</description>
                  <bitRange>[30:24]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RX_FIFO_RD</name>
              <description>RX FIFO read</description>
              <addressOffset>0x88</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DATA</name>
                  <description>Data (PCM sample) read from the RX FIFO. Reading removes the data from the RX FIFO; i.e. behavior is similar to that of a POP operation (RX_FIFO_STATUS.RD_PTR is incremented and RX_FIFO_STATUS.USED is decremented). The read data (DATA) is right aligned (unused bit positions follow the specified sign extension per RX_CTL.WORD_SIGN_EXTEND) when it is read from the FIFO entry (data[31:0]):
- 8 bit, DATA[7:0] = data[31:24].
- 10 bit, DATA[9:0] = data[31:22].
- 12 bit, DATA[11:0] = data[31:20].
- 14 bit, DATA[13:0] = data[31:18].
- 16 bit, DATA[15:0] = data[31:16].
- 18 bit, DATA[17:0] = data[31:14].
- 20 bit, DATA[19:0] = data[31:12].
- 24 bit, DATA[23:0] = data[31:8].
- 32 bit, DATA[31:0] = data[31:0].

Note: Reading from an empty RX FIFO activates INTR_RX.FIFO_UNDERFLOW.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RX_FIFO_RD_SILENT</name>
              <description>RX FIFO silent read</description>
              <addressOffset>0x8C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DATA</name>
                  <description>N/A</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_RX</name>
              <description>Interrupt</description>
              <addressOffset>0xC0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x107</resetMask>
              <fields>
                <field>
                  <name>FIFO_TRIGGER</name>
                  <description>HW sets this field to '1', when a RX trigger is generated.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIFO_OVERFLOW</name>
                  <description>HW sets this field to '1', when writing to a (almost) full RX FIFO (128 -RX_FIFO_STATUS.USED &lt; 'number of enabled channels per frame'). This is referred to as an overflow event.

Note: HW ensures that either all or none of the frame's channels are received. In a RX FIFO overflow situation, HW discards received PCM data values.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIFO_UNDERFLOW</name>
                  <description>HW sets this field to '1', when reading from an empty RX FIFO (RX_FIFO_STATUS.USED is '0').</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IF_OVERFLOW</name>
                  <description>HW sets this field to '1', when PCM samples are generated too fast by the interface logic (interface overflow). This may be an indication that the IP system frequency is too low wrt. the interface frequency (a SW configuration error). The interface overflow is a non-recoverable error and requires SW disabling of the channel (a SW write to INTR_RX.IF_OVERFLOW does not resolve the interface underflow).

Note: This functionality is intended for debug purposes.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_RX_SET</name>
              <description>Interrupt set</description>
              <addressOffset>0xC4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x107</resetMask>
              <fields>
                <field>
                  <name>FIFO_TRIGGER</name>
                  <description>Write this field with '1' to set corresponding INTR_RX field (a write of '0' has no effect).</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIFO_OVERFLOW</name>
                  <description>Write this field with '1' to set corresponding INTR_RX field (a write of '0' has no effect).</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIFO_UNDERFLOW</name>
                  <description>Write this field with '1' to set corresponding INTR_RX field (a write of '0' has no effect).</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IF_OVERFLOW</name>
                  <description>Write this field with '1' to set corresponding INTR_RX field (a write of '0' has no effect).</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_RX_MASK</name>
              <description>Interrupt mask</description>
              <addressOffset>0xC8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x107</resetMask>
              <fields>
                <field>
                  <name>FIFO_TRIGGER</name>
                  <description>Mask for corresponding field in INTR_RX register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIFO_OVERFLOW</name>
                  <description>Mask for corresponding field in INTR_RX register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIFO_UNDERFLOW</name>
                  <description>Mask for corresponding field in INTR_RX register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IF_OVERFLOW</name>
                  <description>Mask for corresponding field in INTR_RX register.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_RX_MASKED</name>
              <description>Interrupt masked</description>
              <addressOffset>0xCC</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x107</resetMask>
              <fields>
                <field>
                  <name>FIFO_TRIGGER</name>
                  <description>Logical AND of corresponding INTR_RX and INTR_RX_MASK fields.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FIFO_OVERFLOW</name>
                  <description>Logical AND of corresponding INTR_RX and INTR_RX_MASK fields.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FIFO_UNDERFLOW</name>
                  <description>Logical AND of corresponding INTR_RX and INTR_RX_MASK fields.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>IF_OVERFLOW</name>
                  <description>Logical AND of corresponding INTR_RX and INTR_RX_MASK fields.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>MAIN_REG</name>
      <description>HBWSS Main Registers</description>
      <baseAddress>0x40640000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Main Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1100010</resetValue>
          <resetMask>0x8FF30133</resetMask>
          <fields>
            <field>
              <name>DMA_SRC_SEL</name>
              <description>AXI clock source selection
00: 480Mhz from USB2
01: Not used
10: PHY CLOCK from USB3; 312.5Mhz in Gen2 and 125MHz in Gen 1
11: HF Clk #4 from SRSS</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_DIV_SEL</name>
              <description>Divides AXI source clock to generate lower frequencies
00 - Divide by 1 (Not Supported when DMA_SRC_SEL = 00)
01 - Divide by 2
10 - Divide by 3
11 - Divide by 4</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUFFSIZE_64KB_EN</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVICT_SLOW_AHB_RD_CACHE</name>
              <description>SW sets this field to '1' to clear the contents of the Slow AHB Read cache before the beginning of a read from the HBWSS SRAM. Hardware will set this bit to '0' after clearing the cache.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVICT_FAST_AHB_RD_CACHE</name>
              <description>SW sets this field to '1' to clear the contents of the Fast AHB Read cache before the beginning of a read from the HBWSS SRAM. Hardware will set this bit to '0' after clearing the cache.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NUM_SLOW_AHB_STALL_CYCLES</name>
              <description>Number of stall cycles between every Slow AHB write if 'STALL_SLOW_AHB_WRITE' is enabled.</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALL_SLOW_AHB_WRITE</name>
              <description>When this bit is set, stall cycles programmed in register 'NUM_SLOW_AHB_STALL_CYCLES' is introduced between every Slow AHB write when LVDS ingress and egress or USB32 ingress interfaces are trying to access the same SRAM bank.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NUM_FAST_AHB_STALL_CYCLES</name>
              <description>Number of stall cycles between every Slow AHB write if 'STALL_SLOW_AHB_WRITE' is enabled.</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STALL_FAST_AHB_WRITE</name>
              <description>When this bit is set, stall cycles programmed in register 'NUM_FAST_AHB_STALL_CYCLES' is introduced between every Fast AHB write LVDS ingress and egress or USB32 ingress interfaces are trying to access the same SRAM bank.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IP_ENABLED</name>
              <description>0: IP is disabled, Resets the IP, this reset is an async reset.
1: IP is enabled.
Note that when the IP is disabled, all the interrupt sources are also disabled.
All the clocks that their source is clk_hf will be turned off when IP is disabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HBWSS_SPARE</name>
          <description>SPARE Config/Status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>SPARE_CFG</name>
              <description>Spare registers</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPCTRL</name>
          <description>SRAM Power Control Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x960F</resetValue>
          <resetMask>0x3FF0F</resetMask>
          <fields>
            <field>
              <name>PWR_MODE_MACRO_0</name>
              <description>Power Mode Control for SRAM MACROs 0,1,2,3.  0x3 - Enabled, 0x2 - Retained, 0x1 - Reset, 0x0 - Off</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWR_MODE_MACRO_1</name>
              <description>Power Mode Control for SRAM MACROs 4,5,6,7.  0x3 - Enabled, 0x2 - Retained, 0x1 - Reset, 0x0 - Off</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWRUP_DELAY</name>
              <description>Power Up Time</description>
              <bitRange>[17:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CMD</name>
          <description>Trigger command</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF00000FF</resetMask>
          <fields>
            <field>
              <name>TR_SEL</name>
              <description>Specifies the activated trigger when ACTIVATE is '1'. If the specified trigger is not present, the trigger activation has no effect.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRA_MINTENAB</name>
              <description>Trigger Assist logic Master Interrupt Enable</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_EDGE</name>
              <description>Specifies if the activated  trigger is treated as a level sensitive or edge sensitive  trigger.
'0': level sensitive. The trigger reflects TR_CMD.ACTIVATE.
'1': edge sensitive trigger. The trigger is activated for two clk_peri cycles.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUT_SEL</name>
              <description>Specifies whether trigger activation is for a specific input or output trigger of the trigger multiplexer. Activation of a specific input trigger, will result in activation of all output triggers that have the specific input trigger selected through their TR_OUT_CTL.TR_SEL  field. Activation of a specific output trigger, will result in activation of the specified TR_SEL output trigger only.
'0': TR_SEL selection and trigger activation is for an input trigger to the trigger multiplexer.
'1': TR_SEL selection and trigger activation is for an output trigger from the trigger multiplexer.

Note: this field is not used for trigger 1-to-1 groups.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACTIVATE</name>
              <description>SW sets this field to '1' to activate (set to '1') a trigger as identified by TR_SEL, TR_EDGE and OUT_SEL. HW sets this field to '0' for edge sensitive triggers AFTER the selected trigger is activated for two clk_peri cycles.

Note: when ACTIVATE is '1', SW should not modify the other register fields.
SW MUST NOT set ACTIVATE bit to '1' while updating the other register bits simultaneously. At first the SW MUST update the other register bits as needed, and then set ACTIVATE to '1' with a new register write.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRA_CO_INTR</name>
          <description>CDMA output tr_assist Interrupt Status</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>OINTR_BITS</name>
              <description>Trigger Assist Interrupt per trigger</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRA_CO_INTR_SET</name>
          <description>CDMA output tr_assist Interrupt Set</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>OINTRS_BITS</name>
              <description>Trigger Assist Interrupt Set per trigger</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRA_CO_INTR_MASK</name>
          <description>CDMA output tr_assist Interrupt Mask</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>OINTRM_BITS</name>
              <description>Trigger Assist Interrupt Mask per trigger</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRA_CO_INTR_MASKED</name>
          <description>CDMA output tr_assist Interrupt Masked</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>OINTRMD_BITS</name>
              <description>Trigger Assist Interrupt Masked per trigger</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDFT_MUX</name>
          <description>DDFT0/1 mux selection Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOP_DDFT0_SEL</name>
              <description>This register selects the following inputs to be routed to DDFT0.
0: USB32 DDFT0
1: USB32 DDFT1
2: LVDS DDFT0
3: LVDS DDFT1
4-TBD: HBWSS DDFT0</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TOP_DDFT1_SEL</name>
              <description>This register selects the following inputs to be routed to DDFT1.
0: USB32 DDFT0
1: USB32 DDFT1
2: LVDS DDFT0
3: LVDS DDFT1
4-TBD: HBWSS DDFT0</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HS_DDFT0_SEL</name>
              <description>This register selects the following inputs to be routed to HS DDFT0
0: USB32 PHY0 DDFT0
1: USB32 PHY1 DDFT0
2: USB32 PHY0 DDFT1
3: USB32 PHY1 DDFT1</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HS_DDFT1_SEL</name>
              <description>This register selects the following inputs to be routed to HS DDFT1
0: USB32 PHY0 DDFT0
1: USB32 PHY1 DDFT0
2: USB32 PHY0 DDFT1
3: USB32 PHY1 DDFT1</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <name>TR_GR</name>
          <description>Trigger group</description>
          <addressOffset>0x00000400</addressOffset>
          <register>
            <dim>64</dim>
            <dimIncrement>4</dimIncrement>
            <name>TR_CTL[%s]</name>
            <description>Trigger control register</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x8FFFFFFF</resetMask>
            <fields>
              <field>
                <name>TR_SEL0</name>
                <description>Specifies input trigger source 0. This field is typically set during the setup of a chip use case scenario. Changing this field while activated triggers are present on the input triggers may result in unpredictable behavior. Note that input trigger 0 (default value) is typically connected to a constant signal level of '0', and as a result will not cause HW activation of the output trigger. The trigger source numbers are assigned as follows (Use this to calculate the value to be programmed in the TR_SEL register. 0-31 is Unused):                                                                                                                                                                                                                                                                                                                      USB Ingress    	(0x20-0x2f)
USB Egress    	(0x30-0x3f)
LVDS Ingress  	(0x40-0x4f)
LVDS Egress  	(0x50-0x5f)
Central DMA   	(0x60-0x6f)</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_SEL1</name>
                <description>Specifies input trigger source 1. This field is typically set during the setup of a chip use case scenario. Changing this field while activated triggers are present on the input triggers may result in unpredictable behavior. Note that input trigger 0 (default value) is typically connected to a constant signal level of '0', and as a result will not cause HW activation of the output trigger. The trigger source numbers are assigned as follows (Use this to calculate the value to be programmed in the TR_SEL register. 0-31 is Unused):                                                                                                                                                                                                                                                                                                                      USB Ingress    	(0x20-0x2f)
USB Egress    	(0x30-0x3f)
LVDS Ingress  	(0x40-0x4f)
LVDS Egress  	(0x50-0x5f)
Central DMA   	(0x60-0x6f)</description>
                <bitRange>[13:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_SEL2</name>
                <description>Specifies input trigger source 2. This field is typically set during the setup of a chip use case scenario. Changing this field while activated triggers are present on the input triggers may result in unpredictable behavior. Note that input trigger 0 (default value) is typically connected to a constant signal level of '0', and as a result will not cause HW activation of the output trigger. The trigger source numbers are assigned as follows (Use this to calculate the value to be programmed in the TR_SEL register. 0-31 is Unused):                                                                                                                                                                                                                                                                                                                      USB Ingress    	(0x20-0x2f)
USB Egress    	(0x30-0x3f)
LVDS Ingress  	(0x40-0x4f)
LVDS Egress  	(0x50-0x5f)
Central DMA   	(0x60-0x6f)</description>
                <bitRange>[20:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_SEL3</name>
                <description>Specifies input trigger source 3. This field is typically set during the setup of a chip use case scenario. Changing this field while activated triggers are present on the input triggers may result in unpredictable behavior. Note that input trigger 0 (default value) is typically connected to a constant signal level of '0', and as a result will not cause HW activation of the output trigger. The trigger source numbers are assigned as follows (Use this to calculate the value to be programmed in the TR_SEL register. 0-31 is Unused):                                                                                                                                                                                                                                                                                                                      USB Ingress    	(0x20-0x2f)
USB Egress    	(0x30-0x3f)
LVDS Ingress  	(0x40-0x4f)
LVDS Egress  	(0x50-0x5f)
Central DMA   	(0x60-0x6f)</description>
                <bitRange>[27:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DBG_FREEZE_EN</name>
                <description>Specifies if the output trigger is blocked in debug mode. When set high tr_dbg_freeze will block the output trigger generation.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>16</dim>
            <dimIncrement>4</dimIncrement>
            <name>TR_CDMA_CTL[%s]</name>
            <description>Central DMA Trigger control register</description>
            <addressOffset>0x180</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80063FFF</resetMask>
            <fields>
              <field>
                <name>TR_SEL0</name>
                <description>Specifies input trigger. This field is typically set during the setup of a chip use case scenario. Changing this field while activated triggers are present on the input triggers may result in unpredictable behavior. Note that input trigger 0 (default value) is typically connected to a constant signal level of '0', and as a result will not cause HW activation of the output trigger.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_SEL1</name>
                <description>Specifies input trigger. This field is typically set during the setup of a chip use case scenario. Changing this field while activated triggers are present on the input triggers may result in unpredictable behavior. Note that input trigger 0 (default value) is typically connected to a constant signal level of '0', and as a result will not cause HW activation of the output trigger.</description>
                <bitRange>[13:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_INV</name>
                <description>Specifies if the output trigger is inverted.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_EDGE</name>
                <description>Specifies if the (inverted) output trigger is treated as a level sensitive or edge sensitive  trigger.
'0': level sensitive.
'1': edge sensitive trigger. The (inverted) output trigger duration needs to be at least 2 cycles on the consumer clock. the(inverted) output trigger is synchronized to the consumer clock and a two cycle pulse is generated on the consumer clock.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DBG_FREEZE_EN</name>
                <description>Specifies if the output trigger is blocked in debug mode. When set high tr_dbg_freeze will block the output trigger generation</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>TR_ASSIST_GR</name>
          <description>Trigger Assist - for CDMA triggers</description>
          <addressOffset>0x00000800</addressOffset>
          <register>
            <dim>16</dim>
            <dimIncrement>4</dimIncrement>
            <name>TRA_CTRL[%s]</name>
            <description>Trigger Assist Control Registers</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3131FFFF</resetMask>
            <fields>
              <field>
                <name>TRA_DSCR_NUM</name>
                <description>Specifies the first descriptor number coressponding to HBWSS producer or consumer</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRA_STREAM_EN</name>
                <description>Enable bit for the stream - '1' to enable the stream, '0' to disable stream. Hardware can disable stream for linear descriptor chain and end of descriptor chain in Packet Mode and when Wrap Up Skt is asserted in Stream Mode.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRA_HBWSS_IS_CONS</name>
                <description>Specifies if HBWSS is Consumer or Producer - '1' for Consumer and '0' for producer</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRA_PKT_MODE</name>
                <description>Specifies data transfer mode - '1' for packet mode and '0' for streaming mode</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRA_WRAP_UP_SKT</name>
                <description>Specifies end of transfer in streaming mode</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRA_SUPPR_1ST_TR</name>
                <description>Suppress first trigger</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRA_SUPPR_1ST_INT</name>
                <description>Suppress first interrupt</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>16</dim>
            <dimIncrement>4</dimIncrement>
            <name>TRA_SLP_CTRL[%s]</name>
            <description>Trigger Assist Short Length Packet / Zero Length Packet Control</description>
            <addressOffset>0x100</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF0001</resetMask>
            <fields>
              <field>
                <name>TRA_SHORT_CONFIG</name>
                <description>Specifies whether SLP/ ZLP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRA_BYTE_COUNT</name>
                <description>Specifes byte count of SLP/ZLP</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>16</dim>
            <dimIncrement>4</dimIncrement>
            <name>TRA_STAT[%s]</name>
            <description>Trigger Assist Status Registers</description>
            <addressOffset>0x200</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>TRA_STATE</name>
                <description>tr_assist internal state</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>USB32DEV</name>
      <description>USB32 IP Registers</description>
      <baseAddress>0x40680000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>196608</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <name>USB32DEV</name>
          <description>USB32DEV Registers</description>
          <addressOffset>0x00000000</addressOffset>
          <cluster>
            <name>USB32DEV_MAIN</name>
            <description>USB32 Main Register</description>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>CTRL</name>
              <description>Main Control Register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xC00001FD</resetMask>
              <fields>
                <field>
                  <name>SSDEV_ENABLE</name>
                  <description>Enables the Super Speed  device function.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DISABLE_SRAM</name>
                  <description>Disable all the SRAMS in this IP</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>USB2_BUS_RESET</name>
                  <description>0: There is no USB2 Bus Reset
1: There is a   USB2 Bus Reset</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CLK_EN</name>
                  <description>Steps to enable the Clock for USB3.2 function:

//////////////////////////////////////////////////////////////
A: Power-up
    0: PCLK not available
    1: Program CTRL.IP_ENABLED to 1
    2: Program CTRL.SSDEV_ENABLE to 1
    3: Program CTRL.PCLK_SRC to 1 (Select PCLK from PHY-SS)
        Link will change USB3_POWERDOWN_O PIPE-IF from 3 to 2
    4: Wait for USB3_POWERDOWN_O from 3 to 2 interrupt
    5: FW enables the PHY-SS
    6: Once PCLK is avilable (Interrupt): Program CTRL.CLK_EN to 1
//////////////////////////////////////////////////////////////
B: U0 --&gt; U3
    1: Program CTRL.CLK_EN to 0
    2: Then power down the PHY.
//////////////////////////////////////////////////////////////
C: U3 -&gt; U0 (Host intiated 12 ms timeout)
    1: PHY-SS generates the elecidle wakeup interrupt (Takes about 30usec to wakeup)
    2: Program CTRL.PCLK_SRC to 2 (Use Peri Clock)
    3: Program CTRL.CLK_EN to 1 (Link will do RX LFPS detection)
    4: Wait for USB3_POWERDOWN_O from 3 to 0 interrupt
    5: Program CTRL.PCLK_SRC to 0
    6: FW enables the PHY-SS
    7: Wait for PHY-SS PLL lock interrupt (2 ms)
    8: Program CTRL.PCLK_SRC to 1 (Use PHY-SS PCLK)
//////////////////////////////////////////////////////////////</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PCLK_SRC</name>
                  <description>Clock source for the USB function:
0: No selection (clock will be zero to controller)
1: USB3 PHY 312.5/125MHz (Spread Spectrum Clock)
2: Peri clock
3: clk_lf_i (typ 32KHz)</description>
                  <bitRange>[6:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EN_RST_CLOCK_MUX</name>
                  <description>0: Disable reseting the CLOCK-MUX logic when CLK_EN de-asserts
1: Enable  reseting the CLOCK-MUX logic when CLK_EN de-asserts
   When CLK_EN de-asserts, the CLOCK-MUX resets for one-clock cycle of Peri Clock.</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EN_EGRS_RQ_HALF_DATA_RATE</name>
                  <description>This register controls the rate that data is being read from egress DMA.

Gen1X1: This should be set to 0. AXI clock can be either 160 Mhz or 240 Mhz.
Gen2X1: This should be set to 0 when AXI clock is 240 Mhz or higher otherwise this should be set to 1
Gen1X2: This should be set to 0 when AXI clock is 240 Mhz or higher otherwise this should be set to 1 
Gen2X2: This should be set to 0 and AXI clock should always be 240 MHz

0: The data read from DMA is every cycle when data available
1: The data read from DMA is once every two cycles when data available</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CONFIG_LANE</name>
                  <description>Configuration Lane register. This register needs to be programmed before Link LTSSM move out from SS.DISABLED.
CONFIG_LANE programmed before LTSSM move out from SS.DISABLED.
0: Lane0 is the configuration lane
1: Lane1 is the configuration lane</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IP_ENABLED</name>
                  <description>0: IP is disabled, Resets the IP, this reset is an async reset.
1: IP is enabled.
Note that when the IP is disabled, all the interrupt sources are also disabled.
All the clocks that their source is clk_hf will be turned off when IP is disabled.
Note: This bit should set to '0' and then '1' (soft reset) when LTSSM goes to
1) SS.disabled
2) Warm reset
3) SS.Inactive</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR</name>
              <description>Main Active Interrupt Register</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3EF</resetMask>
              <fields>
                <field>
                  <name>LINK</name>
                  <description>SuperSpeedPlus Link Controller Interrupt</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PROT</name>
                  <description>SuperSpeedPlus Protocol Layer Interrupt</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PROT_EP</name>
                  <description>SuperSpeedPlus Device Endpoint Interrupt</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EPM_URUN</name>
                  <description>SuperSpeedPlus Egress EPM under run/T1&amp;T2 activation Interrupt. IEPM_CS.EPM_FLUSH should be used to flush the EPM.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>P3P0</name>
                  <description>SuperSpeedPlus Ingress EPM full condition</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>P3P1</name>
                  <description>USB3_Powerdown_o PIPE-IF signal changed from 3 to 1</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>P3P2</name>
                  <description>USB3_Powerdown_o PIPE-IF signal changed from 3 to 2</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY0</name>
                  <description>SuperSpeedPlus PHY0 Interrupt</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PHY1</name>
                  <description>SuperSpeedPlus PHY1 Interrupt</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_SET</name>
              <description>Main Active Interrupt Set Register</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3EF</resetMask>
              <fields>
                <field>
                  <name>LINK</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PROT</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PROT_EP</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EPM_URUN</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>P3P0</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>P3P1</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>P3P2</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY0</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY1</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_MASK</name>
              <description>Main Active Interrupt Mask Register</description>
              <addressOffset>0xC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3EF</resetMask>
              <fields>
                <field>
                  <name>LINK_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PROT_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PROT_EP_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EPM_URUN_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>P3P0_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>P3P1_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>P3P2_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY0_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY1_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_MASKED</name>
              <description>Main Active Interrupt Masked Register</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3EF</resetMask>
              <fields>
                <field>
                  <name>LINK_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PROT_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PROT_EP_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EPM_URUN_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>P3P0_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>P3P1_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>P3P2_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PHY0_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PHY1_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DDFT_MUX</name>
              <description>DDFT0/1 mux selection Register</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>DDFT0_SEL</name>
                  <description>This register selects the following inputs to be routed to DDFT0.
0: PHY-SS[0] DDFT0
1: PHY-SS[0] DDFT1
2: PHY-SS[1] DDFT0
3: PHY-SS[1] DDFT1
19:4: Egress Socket Active
35:20 Ingress Socket Active
51:36 T1 SCH ready
67:52 T2 SCH ready
68 prot_ptm_value_valid_o
82:69 prot_ptm_bic_value_o
98:83 t1_q_rb_vals (type1 SKT_NUM retry buffer based on DEBUG_CONFIG_SKT_NUM value)
114:99 t2_q_rb_vals (type1 SKT_NUM retry buffer based on DEBUG_CONFIG_SKT_NUM value)
115: loopback_ddft
116: link_hs_sig 
117: proto_typ2_txheaderfull 
118: proto_txheaderfull 
119: lcw_ready 
120: dpp_retry 
121: proto_rxheaderempty 
122: usb3_txelecidle 
123: usb3_txdetectrx_loopback 
124: usb3_rxvalid 
125: usb3_rxelecidle 
126: usb3_rate 
127: usb3_powerdown_1 
128: usb3_powerdown_0 
129: usb3_powerpresent 
130: ltssm_cp 
131: ltssm_u3 
132: ltssm_u2 
133: ltssm_u1 
134: ltssm_u0 
135: ltssm_loopback_exit 
136: ltssm_loopback_active 
137: ltssm_hot_reset_exit 
138: ltssm_hot_reset_active 
139: ltssm_recovery_idle 
140: ltssm_recovery_configuration 
141: ltssm_recovery_active 
142: ltssm_polling_idle 
143: ltssm_polling_configuration
144: ltssm_polling_active
145: ltssm_polling_rxeq
146: ltssm_polling_port_config
147: ltssm_polling_port_match
148: ltssm_polling_lfps_plus
149: ltssm_polling_lfps
150: ltssm_rx_detect_active
151: debug_write_st
152: Debug_end_st</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DDFT1_SEL</name>
                  <description>This register selects the following inputs to be routed to DDFT1.
0: PHY-SS[0] DDFT0
1: PHY-SS[0] DDFT1
2: PHY-SS[1] DDFT0
3: PHY-SS[1] DDFT1
19:4: Egress Socket Active
35:20 Ingress Socket Active
51:36 T1 SCH ready
67:52 T2 SCH ready
68 prot_ptm_value_valid_o
82:69 prot_ptm_bic_value_o
98:83 t1_q_rb_vals (type1 SKT_NUM retry buffer based on DEBUG_CONFIG_SKT_NUM value)
114:99 t2_q_rb_vals (type1 SKT_NUM retry buffer based on DEBUG_CONFIG_SKT_NUM value)
115: loopback_ddft
116: link_hs_sig 
117: proto_typ2_txheaderfull 
118: proto_txheaderfull 
119: lcw_ready 
120: dpp_retry 
121: proto_rxheaderempty 
122: usb3_txelecidle 
123: usb3_txdetectrx_loopback 
124: usb3_rxvalid 
125: usb3_rxelecidle 
126: usb3_rate 
127: usb3_powerdown_1 
128: usb3_powerdown_0 
129: usb3_powerpresent 
130: ltssm_cp 
131: ltssm_u3 
132: ltssm_u2 
133: ltssm_u1 
134: ltssm_u0 
135: ltssm_loopback_exit 
136: ltssm_loopback_active 
137: ltssm_hot_reset_exit 
138: ltssm_hot_reset_active 
139: ltssm_recovery_idle 
140: ltssm_recovery_configuration 
141: ltssm_recovery_active 
142: ltssm_polling_idle 
143: ltssm_polling_configuration
144: ltssm_polling_active
145: ltssm_polling_rxeq
146: ltssm_polling_port_config
147: ltssm_polling_port_match
148: ltssm_polling_lfps_plus
149: ltssm_polling_lfps
150: ltssm_rx_detect_active
151: debug_write_st
152: Debug_end_st</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIO_DDFT_MUX</name>
              <description>GPIO DDFT0/1 mux selection Register</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>DDFT0_SEL</name>
                  <description>This register selects the following inputs to be routed to GPIO-DDFT0.
0: PHY-SS[0] DDFT0
1: PHY-SS[0] DDFT1
2: PHY-SS[1] DDFT0
3: PHY-SS[1] DDFT1
19:4: Egress Socket Active
35:20 Ingress Socket Active
51:36 T1 SCH ready
67:52 T2 SCH ready
68 prot_ptm_value_valid_o
82:69 prot_ptm_bic_value_o
98:83 t1_q_rb_vals (type1 SKT_NUM retry buffer based on DEBUG_CONFIG_SKT_NUM value)
114:99 t2_q_rb_vals (type1 SKT_NUM retry buffer based on DEBUG_CONFIG_SKT_NUM value)
115: loopback_ddft
116: hight speed link ddtf signal
117: proto_typ2_txheaderfull
118: proto_txheaderfull
119: lcw_ready
120: dpp_retry
121: proto_rxheaderempty
129-122: pipe interface
150-130: ltssm
151: debug_write_st
152: Debug_end_st</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DDFT1_SEL</name>
                  <description>This register selects the following inputs to be routed to GPIO-DDFT1.
0: PHY-SS[0] DDFT0
1: PHY-SS[0] DDFT1
2: PHY-SS[1] DDFT0
3: PHY-SS[1] DDFT1
19:4: Egress Socket Active
35:20 Ingress Socket Active
51:36 T1 SCH ready
67:52 T2 SCH ready
68 prot_ptm_value_valid_o
82:69 prot_ptm_bic_value_o
98:83 t1_q_rb_vals (type1 SKT_NUM retry buffer based on DEBUG_CONFIG_SKT_NUM value)
114:99 t2_q_rb_vals (type1 SKT_NUM retry buffer based on DEBUG_CONFIG_SKT_NUM value)
115: loopback_ddft
116: hight speed link ddtf signal
117: proto_typ2_txheaderfull
118: proto_txheaderfull
119: lcw_ready
120: dpp_retry
121: proto_rxheaderempty
129-122: pipe interface
150-130: ltssm
151: debug_write_st
152: Debug_end_st</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DEBUG_CONFIG</name>
              <description>Debug Configuration Register</description>
              <addressOffset>0x1C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x60000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DEBUG_EN</name>
                  <description>This register enables the debug function. The debug function can capture 512 cycles worth of controll/data.Where each cycles contains 128-bits.
If DEBUG_EN is '0' , FW can set it to '1' and debug function starts based on the FUNC_SEL.. 
When DEBUG_EN is 1:
HW will capture the activities into the Ingress Packet-FIFO type2 (8K storage) and keeps pushing the data into ingress-socket#3 until the end of debug cycle.
FW must clear the DEBUG_EN after EOT for next debug capture.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STOP_EN</name>
                  <description>FW can used this to stop the capturing the event only when DEBUG_EN=1.
Once set, FW must cleared it after every debug cycle (DEBUG_EN 1==&gt;0).</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FUNC_SEL</name>
                  <description>This register controls when the activities are captrued and when the captring stops.
An activity means there was a toggle in the 128-bits of data selected based on DEBUG_MUX_SEL.  
0: Start writting activities based on START_EVENT_SEL and End based on END_EVENT_SEL + after detecting NUM_OF_ACITIVITIES
1: Start writting activities based on START_EVENT_SEL and End based on END_EVENT_SEL
2: Start writting activities based on START_EVENT_SEL and End after detecting NUM_OF_ACITIVITIES
3: Start writting activities and End based on END_EVENT_SEL
4: Start writting activities and End based on END_EVENT_SEL + detecting NUM_OF_ACITIVITIES
5: Start writting activities and End based on STOP_EN
    Note: FW can set STOP_EN to 0 for all option just in case if the END_EVENT didn't occur.</description>
                  <bitRange>[4:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>START_EVENT_SEL</name>
                  <description>This register selects the Start-event
0: egress socket # (based on the SKT_NUM register)
1: Egress am_cq_push_o
2: Egress a_cq_push_o to DMA
3: c_activate_i (based on the SKT_NUM register) to egress EPM from protcol
4: link_epm_egrs_addr_valid_i to Egress EPM
5: t1_sw_buffer_ready_o to Link
6: t2_sw_buffer_ready_o to Link
7: c_read_type1_i positive edge
8: c_read_type2_i  positive edge
9: c_read_type1_i negative edge
10: c_read_type2_i  negative edge
11: Egress Under-Run detected
12: Egress retry detected
13: ingress socket # (based on the SKT_NUM register)
14: Ingress activate
15: Ingress commit
16: Ingress c_ready_o (based on the SKT_NUM register)
17: Ingress DMA EOP
18: Ingress DMA EOT
19: Link_event_0
20: Link_event_1
21: Link_event_2
22: Link_event_3
23: Link_event_4
24: Link_event_5
25: Link_event_6
26: Link_event_7</description>
                  <bitRange>[10:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>END_EVENT_SEL</name>
                  <description>This register selects the End-event
0: egress socket # (based on the SKT_NUM register)
1: Egress am_cq_push_o
2: Egress a_cq_push_o to DMA
3: c_activate_i (based on the SKT_NUM register) to egress EPM from protcol
4: link_epm_egrs_addr_valid_i to Egress EPM
5: t1_sw_buffer_ready_o to Link
6: t2_sw_buffer_ready_o to Link
7: c_read_type1_i positive edge
8: c_read_type2_i  positive edge
9: c_read_type1_i negative edge
10: c_read_type2_i  negative edge
11: Egress Under-Run detected
12: Egress retry detected
13: ingress socket # (based on the SKT_NUM register)
14: Ingress activate
15: Ingress commit
16: Ingress c_ready_o (based on the SKT_NUM register)
17: Ingress DMA EOP
18: Ingress DMA EOT
19: Link_event_0
20: Link_event_1
21: Link_event_2
22: Link_event_3
23: Link_event_4
24: Link_event_5
25: Link_event_6
26: Link_event_7</description>
                  <bitRange>[16:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NUM_OF_ACTIVITIES</name>
                  <description>This register is used based on the FUNC_SEL register.
Number of activities, where an activity means when any of the 128-bit of data based on the DEBUG_MUX_SEL changes.</description>
                  <bitRange>[24:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SKT_NUM</name>
                  <description>This register selects the socket# where the corresponding activities are captured.</description>
                  <bitRange>[28:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEBUG_SKT_NUM</name>
                  <description>This register selects the socket# where the debug information is pushed to SRAM.</description>
                  <bitRange>[31:29]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DEBUG_MUX_SEL</name>
              <description>Debug MUX selection Configuration Register</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>BIT_31_0_SEL</name>
                  <description>This register selects what activitity should be the [31:0]. The below is defined in the debug signal sheet.
0: Protocol-Link-EPM
1: Egress DMA C1
2: Egress DMA C0
3 : Egress Link-EPM read
4: Type1 Egress Link-EPM state machine
5: Type2 Egress Link-EPM state machine
6: Protocol Egress EPM part1
7: SCH
8: Protocol-Ingress-EPM
9: Ingress-EPM Part1
10: Ingress-EPM Part2
11: Ingress DMA C1
12: Ingress DMA C0
13: PIPE00
14: DMA debug a_rq_rdata[31:0]
15: LINK Deug data0</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BIT_63_32_SEL</name>
                  <description>This register selects what activitity should be the [63:32].  The below is defined in the debug signal sheet.
0: Protocol-Link-EPM
1: Egress DMA C1
2: Egress DMA C0
3 : Egress Link-EPM read
4: Type1 Egress Link-EPM state machine
5: Type2 Egress Link-EPM state machine
6: Protocol Egress EPM part1
7: SCH
8: Protocol-Ingress-EPM
9: Ingress-EPM Part1
10: Ingress-EPM Part2
11: Ingress DMA C1
12: Ingress DMA C0
13: PIPE01
14: DMA debug a_rq_rdata[63:32]
15: LINK Deug data1</description>
                  <bitRange>[7:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BIT_95_64_SEL</name>
                  <description>This register selects what activitity should be the [95:64].  The below is defined in the debug signal sheet.
0: Protocol-Link-EPM
1: Egress DMA C1
2: Egress DMA C0
3 : Egress Link-EPM read
4: Type1 Egress Link-EPM state machine
5: Type2 Egress Link-EPM state machine
6: Protocol Egress EPM part1
7: SCH
8: Protocol-Ingress-EPM
9: Ingress-EPM Part1
10: Ingress-EPM Part2
11: Ingress DMA C1
12: Ingress DMA C0
13: PIPE10
14: DMA debug a_rq_rdata[95:64]
15: LINK Deug data2</description>
                  <bitRange>[11:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BIT_127_96_SEL</name>
                  <description>This register selects what activitity should be the [127:96].  The below is defined in the debug signal sheet.
0: Protocol-Link-EPM
1: Egress DMA C1
2: Egress DMA C0
3 : Egress Link-EPM read
4: Type1 Egress Link-EPM state machine
5: Type2 Egress Link-EPM state machine
6: Protocol Egress EPM part1
7: SCH
8: Protocol-Ingress-EPM
9: Ingress-EPM Part1
10: Ingress-EPM Part2
11: Ingress DMA C1
12: Ingress DMA C0
13: PIPE11
14: DMA debug a_rq_rdata[127:96]
15: LINK Deug data3</description>
                  <bitRange>[15:12]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LOOPBACK</name>
              <description>LOOPBACK Configuration Register</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1</resetValue>
              <resetMask>0xE001FFFF</resetMask>
              <fields>
                <field>
                  <name>EP_NUM</name>
                  <description>The end point number</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NUMP</name>
                  <description>Number of packets</description>
                  <bitRange>[8:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TT_FIELD</name>
                  <description>TT field for superspeed+</description>
                  <bitRange>[11:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SEQ_NUM</name>
                  <description>Starting Seq#</description>
                  <bitRange>[16:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SINGLE_XFER</name>
                  <description>Once set, controller sends an ACK(Like host) per above registers requesting NUMP packet to be transmitted (Egress).
The controller sends #NUMP packets from egress DMA to ingress DMA.</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BURN_IN_EN</name>
                  <description>N/A</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PIPE_LOOPBACK_EN</name>
                  <description>Pipe Burn-in Mode: Loopback (Using PERI-Clock)
1: program the USB32DEV_USB32DEV_MAIN_CONFIG_WOUND bits
   [18] - b'1 for Gen2x1
2: Program the USB32DEV_USB32DEV_MAIN_CTRL register bits
     [6:5] - 2'b10 for programming PCLK clock (Peri Clock)
3: Program the USB32DEV_USB32DEV_MAIN_LOOPBACK bits 
   [ 3: 0] - for selecting endpoint number (Program 1)
   [ 8: 4] - For fixing the numP (Program 'd16)
   [11: 9] - TT field  (Program 6 for BULK)
   [16:12] - for sequence number (Program 0)
4: DMA needs to be programmed for both ingress &amp; Egress End-point #1,2,3,4 with 16k.
5: Program the USB32DEV_USB32DEV_MAIN_LOOPBACK bits
   [31] - 1'b1 for enable the pipe_loop_back_en 
6: Program the USB32DEV_USB32DEV_MAIN_LOOPBACK bits  
      [30] = 1'b1  For BURN-IN

Pipe Burn-in Mode: Loopback (Using PHY-Clock)
1: Enable PHY-SS to have PCLK as 312.5 MHz
2: program the USB32DEV_USB32DEV_MAIN_CONFIG_WOUND bits
   [18] - b'1 for Gen2x1
3: Program the USB32DEV_USB32DEV_MAIN_CTRL register bits
     [6:5] - 2'b01 for programming PCLK clock  (PHY-SS Clock)
4: Program the USB32DEV_USB32DEV_MAIN_LOOPBACK bits 
   [ 3: 0] - for selecting endpoint number (Program 1)
   [ 8: 4] - For fixing the numP (Program 'd16)
   [11: 9] - TT field  (Program 6 for BULK)
   [16:12] - for sequence number (Program 0)
5: DMA needs to be programmed for both ingress &amp; Egress End-point #1,2,3,4 with 16k.
6: Program the USB32DEV_USB32DEV_MAIN_LOOPBACK bits
   [31] - 1'b1 for enable the pipe_loop_back_en 
7: Program the USB32DEV_USB32DEV_MAIN_LOOPBACK bits  
      [30] = 1'b1  For BURN-IN

PHY+Controller Burn-in Mode: USB-IF Loopback (Using PHY-Clock)
1. Wait until LTSSM entry to U0 state
2: Progmam the PIPE_LOOPBACK register fields
   (EP_NUM, NUMP, TT_FIELD,SEQ_NUM,SEND_ACK)
   Setting SEND_ACK will cause controller to send an ACK'</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>BUG_FIX</name>
              <description>BUG Fix Configuration Register</description>
              <addressOffset>0x2C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1F03</resetValue>
              <resetMask>0xFFFF7F03</resetMask>
              <fields>
                <field>
                  <name>EPM_T1_T2_COLLISION_EN</name>
                  <description>See JIRA: USB32-7 for more detail</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EPM_READ_END_RST_EN</name>
                  <description>See JIRA: USB32-80 case1 for more detail</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PROT_RTY_COLLISION_EN</name>
                  <description>See JIRA: USB32-4 for more detail</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PROT_B2B_EN</name>
                  <description>See JIRA: USB32-5 for more detail</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PROT_ISO_BRST_0_EN</name>
                  <description>See JIRA: USB32-174 for more detail</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PROT_RX_COLLISION_EN</name>
                  <description>Ingress Packet + Zero-IDLE + SETUP</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PROT_RX_SKP_NO_WRITE_EN</name>
                  <description>No write when len is '0' more than one cycle</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RESET_PROT_STATE</name>
                  <description>Setting this bit will reset protocol state machine</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RESET_SKT_HAS_EOB_FUNC</name>
                  <description>Setting this bit will reset SKT_EOB function for all the Egress End Points.</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DPH_WITH_EOB_CLEARED</name>
                  <description>This is for Egress End Points.
0: Device detected an ACK for a DPH with EOB sent to host.
1: Device has not detected an ACK for a DPH with EOB sent to host.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
          <cluster>
            <name>USB32DEV_EPM</name>
            <description>USB32 Controller End Point Manager Registers</description>
            <addressOffset>0x00001000</addressOffset>
            <register>
              <name>EEPM_CS</name>
              <description>Egress EPM Retry Buffer Status</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x5</resetValue>
              <resetMask>0xF3FC001F</resetMask>
              <fields>
                <field>
                  <name>A_RQ_EMPTY_DLY</name>
                  <description>The a_rq_empty_i is masked for # of clock cycles after the first a_rq_empty_i getting de-asserted
This field is applicable if this field in not '0'.</description>
                  <bitRange>[4:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>URUN_T1_EP_NUM</name>
                  <description>The Type1 End Point that the under-run occurred.</description>
                  <bitRange>[21:18]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>URUN_T2_EP_NUM</name>
                  <description>The Type2 End Point that the under-run occurred.</description>
                  <bitRange>[25:22]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EG_EPNUM</name>
                  <description>Active Endpoint Number</description>
                  <bitRange>[31:28]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IEPM_CS</name>
              <description>Ingress EPM Control and Status</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x9FFF0FFF</resetMask>
              <fields>
                <field>
                  <name>READ_PTR</name>
                  <description>Number of bytes in packet.</description>
                  <bitRange>[11:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WRITE_PTR</name>
                  <description>End of Transfer. Set for short packets.</description>
                  <bitRange>[27:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EPM_FLUSH</name>
                  <description>This will flush both the Egress and Ingress EPM.</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DISABLE_IEPM_CLK_GT</name>
                  <description>Setting this bit will disable the power saving clock gate for ingress EPM memories</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IEPM_MULT</name>
              <description>Ingress EPM MULT function Control</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x8000</resetValue>
              <resetMask>0x3FFFFFF</resetMask>
              <fields>
                <field>
                  <name>MULT_EN</name>
                  <description>Mult Enable for EP1-15.</description>
                  <bitRange>[14:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MULT_THRSHOLD</name>
                  <description>This field is used to when evaluate the mult signal from ingress adapter.
If number of packet space available in the buffer goes down by this field, then 
mult signal from adapter will be evaluated and if it is set the original buffer space(number of packets) is added to NUM_PACKETS in the IEPM_ENDPOINT register.
The descriptor must be more than 1K.</description>
                  <bitRange>[25:15]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>16</dim>
              <dimIncrement>4</dimIncrement>
              <name>EEPM_ENDPOINT[%s]</name>
              <description>Egress EPM per Endpoint Control and Status</description>
              <addressOffset>0x40</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x400</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>PACKET_SIZE</name>
                  <description>Maximum packet size for this end-point.  Typically this value is 1024, 512.
For ISO and Interrupt where Maximum packet size is 1-1024 bytes, only the the following values supported:
1: Powers of 2 (2,4,8,16,32,64,128,512,1024) bytes
2: 96, 144, 192 and 288 bytes
For ISO with MaxPacketIsze of '0', DMA Socket for that Endpoint should be disabled casuing controller to issue ZLP when host sends an ACK for that Endpoint.</description>
                  <bitRange>[10:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EEPM_BYTE_COUNT</name>
                  <description>Number of bytes in the current buffer.</description>
                  <bitRange>[26:11]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ZLP</name>
                  <description>ZLP present in the current buffer</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MSB_EEPM_BYTE_COUNT</name>
                  <description>This bit is used when in 64k mode.</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EPM_EMPTY</name>
                  <description>This controls the egress empty signals to protocol layer.
0: Interal egress empty function of EPM is used for empty detection
1: It will indicate egress is empty for this Socket as long as this register is set.</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EEPM_EP_READY</name>
                  <description>The EPM condition used by USB block.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SOCKET_FLUSH</name>
                  <description>This bit will flush the corresponding Socket.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>16</dim>
              <dimIncrement>4</dimIncrement>
              <name>IEPM_ENDPOINT[%s]</name>
              <description>Ingress EPM Per Endpoint Control and Status</description>
              <addressOffset>0x80</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x400</resetValue>
              <resetMask>0xFF7FFFFF</resetMask>
              <fields>
                <field>
                  <name>PACKET_SIZE</name>
                  <description>Maximum packet size for this end-point.  Typically this value is 1024, 512, 64, 1023 (last 2 for USB2 only).</description>
                  <bitRange>[10:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NUM_IN_PACKETS</name>
                  <description>Number of packets that are guaranteed to fit in the remaining buffer space of the current and next buffers.  If the computed number of packets available is larger than 16, this number will be assumed to be 16 in the protocol block.</description>
                  <bitRange>[21:11]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EP_READY</name>
                  <description>The EPM condition used by USB block.</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ODD_MAX_NUM_PKTS</name>
                  <description>Number of odd byte packets that can fit in the DMA buffer. Only valid if ODD_MAX_PKT_SIZE_EN is set.</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ODD_MAX_PKT_SIZE_EN</name>
                  <description>If this bit is enabled, then at the time of calculation of number of packets space in current DMA buffer, OddMaxNumPkts will over-ride the hardware calculation.</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EOT_EOP</name>
                  <description>Spare</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SOCKET_FLUSH</name>
                  <description>This bit will flush the data sitting in the corresponding Socket.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IEPM_FIFO</name>
              <description>Ingress EPM FIFO Entry</description>
              <addressOffset>0xC0</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1FFFF</resetMask>
              <fields>
                <field>
                  <name>BYTES</name>
                  <description>Number of bytes in the packet.</description>
                  <bitRange>[10:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EOT</name>
                  <description>End of Transfer. Set for by the protocol layer short and zero length packets; forwarded to DMA Adapter.</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>IN_EPNUM</name>
                  <description>Endpoint number for this packet</description>
                  <bitRange>[15:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EP_VALID</name>
                  <description>Entry is valid</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>EEPM_VALID</name>
              <description>Egress EPM Retry Buffer Valid packet</description>
              <addressOffset>0xC4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF000F</resetMask>
              <fields>
                <field>
                  <name>SKT_NUM</name>
                  <description>The socket# used for providing the VALID_PACKETS value</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>VALID_PACKETS</name>
                  <description>The pending retry-packet per SKT_NUM register
Bit vector indicating which of the 16 retry buffer contain a valid packet.
In SuperSpeed mode, this buffer functions as a circular buffer trailing packets that can be retried behind the WRITE_PTR.
These bits are cleared when the Protocol Layer 'activates' an End Point (as opposed to 'reactivating' it).  In SuperSpeed mode all bits are cleared at once.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>16</dim>
              <dimIncrement>4</dimIncrement>
              <name>EEPM_RETRY_OFFSET[%s]</name>
              <description>Egress EPM Retry Buffer EndPoint offset</description>
              <addressOffset>0x104</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFF</resetMask>
              <fields>
                <field>
                  <name>START_OFFSET</name>
                  <description>The Offset is used for Write/Read Address of the 64K Retry-Memory for each End Point.
A 64k memory allows retry for 64 packet with size of 1k. EP0 requirs only 512 Byte.
There is no need to allocate space for ISO End Points.
The 64k is shared between all the 16 EndPoints.
This register is used to indicate where the stating address
The offset has to be N*256,  (0&lt;=N&lt;63 ) and it has to start from offset 0 and the rest
per below calculation without any gap between the offsets.
Note: 4-1K single port sram of 128-bit wide is used to create the 64k memory. 
Example for calculating the start_offset in decimal:
Assume the folloiwng available EndPoint and their MaxBurst size:
EP1: EP1-MaxBurst=2
EP2: EP2-MaxBurst=5
EP6: EP6-MaxBurst=8
EP4: EP4-MaxBurst=16
Assume the following structure for retry buffer, where EP2 is at the bottom, then EP1, EP4,EP6:
EP2: EP2-Start_Offset= 0
EP1: EP1-Start_Offset= EP2-Start_Offset+EP2-MaxBurst*256 = 0+256*5 =1280
EP4: EP4-Start_offset = EP1-Start_Offset+EP1-MaxBurst*256 = 1280+256*2 =1792
EP6: EP6-Start_offset = EP4-Start_Offset+EP4-MaxBurst*256 = 1792+256*16= 5888</description>
                  <bitRange>[13:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>16</dim>
              <dimIncrement>4</dimIncrement>
              <name>EEPM_INJECT_CRC32_ERROR[%s]</name>
              <description>Egress EPM CRC32 Error injection control</description>
              <addressOffset>0x144</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FF</resetMask>
              <fields>
                <field>
                  <name>EN_CRC32_ERROR_ON_SW_BUF</name>
                  <description>0: Don't inject CRC32 on data read from switch buffer
1: Inject CRC32 on data read from switch buffer
This will be set by FW and clear by HW once the packet with wrong CRC32 is sent.
Once set by FW, HW will start counting the packets read from switch buffer and inject CRC32 based on the SW_BUF_PKT_NUM and then it clears this bit.
The packet counter resets when FW sets this bit</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EN_CRC32_ERROR_ON_RETRY</name>
                  <description>0: Don't inject CRC32 on data read from retry buffer
1: Inject CRC32 on data read from retry buffer
This will be set by FW and clear by HW once the packet with wrong CRC32 is sent.
Once set by FW, HW will start counting the packets read from retry buffer and inject CRC32 based on the RETRY_BUF_PKT_NUM and then it clears this bit.
The packet counter resets when FW sets this bit</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SW_BUF_PKT_NUM</name>
                  <description>if EN_CRC32_ERROR_ON_SW_BUF is '1', Which Packet should have CRC32 Error.
The #SW_BUF_PKT_NUM pkt read from switch-buffer will have a CRC32 error.
0: 1st PKT
1: 2nd PKT
.
.
.
15: 16th PKT</description>
                  <bitRange>[5:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RETRY_BUF_PKT_NUM</name>
                  <description>if EN_CRC32_ERROR_ON_RETRY is '1', Which Packet should have CRC32 Error.
The #RETRY_BUF_PKT_NUM pkt read from retry-buffer will have a CRC32 error.
0: 1st PKT
1: 2nd PKT
.
.
.
15: 16th PKT</description>
                  <bitRange>[9:6]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
          <cluster>
            <name>USB32DEV_LNK</name>
            <description>USB32 SuperSpeedPlus Device Controller Link Layer Registers</description>
            <addressOffset>0x00002000</addressOffset>
            <register>
              <name>LNK_CONF</name>
              <description>Link Configuration Register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xF0040</resetValue>
              <resetMask>0xFF3FFFC3</resetMask>
              <fields>
                <field>
                  <name>TX_ARBITRATION</name>
                  <description>Link Arbitration Scheme
    0=Link Commands wins
    1=HP wins
    2=Round Robin</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LCW_IGNORE_RSVD</name>
                  <description>N/A</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEBUG_FEATURE_ENABLE</name>
                  <description>Enable LNK State Debug Override</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FORCE_POWER_PRESENT</name>
                  <description>Force PowerPresent from PHY On</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDN_DETECTION</name>
                  <description>Enable host LDN detection (see USB ECN#001)</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CREDIT_ADV_HOLDOFF</name>
                  <description>Hold-off Credit Advertisement until Sequence Number Advertisement Received</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GEN1X2_SKP_RULE_SEL</name>
                  <description>SKP Rule Selection
0: Number of SKP = (Y/354) * (No_of_retimers + 1) 
1: Number of SKP = (Y/354) * (No_of_retimers)  ; valid only for no_of_retimers &gt; 0.</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EPM_FIRST_DELAY</name>
                  <description>This is to give the DMA network time to warmup the data pipeline.
0: Only the switch-buffer ready is used to issue read to switch-buffer
Other: Switch-buffer ready + this counter is qualified in Link to issue read to switch-buffer
Gen1x1: 
         This register must be programmed to 7.
         Delay sending of first Header in a egress burst in PCLK cycles (125MHz).
SuperSpeedPlus:
         Delay sending of first Header in a egress burst in PCLK cycles (125MHz/312.5MHz)
         HW will use the mutiplied by 2 of the default value.</description>
                  <bitRange>[15:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GEN1X1_INVALID_OS_DET_EN</name>
                  <description>This bit enables the logic to detect invalid TS1/TS2/TSEQ OS for gen1x1</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GEN1X1_CP_TXDETECT_RXLPBK_EN</name>
                  <description>This bit enable the logic to deassert TXDETECT_RXLOOPBACK when entering Compliance Mode for gen1x1</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GEN1X1_LOOPBACK_MASTER_SKP_EN</name>
                  <description>This bit enable the SKP insertion during Loopback Master Mode for gen1x1</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DC_BAL_ALL_OS</name>
                  <description>0: DC Balance only calculate TS1, TS2 and TSEQ
1: DC Balance calculate SYNC, SKP, TS1, TS2 and TSEQ</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DC_BAL_NON_OS_RESET</name>
                  <description>0: DC Balance Counter will be reset once Data Block detected
1: DC Balance Counter will be reset once Data Block detected and TSEQ/TS1/TS2 not sending</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SKP_IN_RXEQ_OFF</name>
                  <description>0: Normal Mode
1: No SKP OS send during LTSSM Polling.RxEQ</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DC_BAL_EN</name>
                  <description>Enable DC Balance calculation for Gen2 TS1/TS2 Symbol 14 and Symbol15</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_DPP_ERR_GO_RECOVERY_EN</name>
                  <description>Enable the logic which detects the DPP data length error and goes to Recovery if error(s) detected</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SKEW_VAL</name>
                  <description>Skew Value
0: 0 skew
1: Lane0 ahead of Lane1 by 1 Clock
2: Lane0 ahead of Lane1 by 2 Clock
3: Lane0 ahead of Lane1 by 3 Clock
4: Lane0 ahead of Lane1 by 4 Clock
5: Lane0 ahead of Lane1 by 5 Clock
6: Lane0 ahead of Lane1 by 6 Clock
7: Lane0 ahead of Lane1 by 7 Clock
8: Lane0 ahead of Lane1 by 8 Clock (not used)
9: Lane0 ahead of Lane1 by 9 Clock (not used)
10: Lane0 ahead of Lane1 by 10 Clock (not used)
11: Lane1 ahead of Lane0 by 1 Clock
12: Lane1 ahead of Lane0 by 2 Clock
13: Lane1 ahead of Lane0 by 3 Clock
14: Lane1 ahead of Lane0 by 4 Clock
15: Lane1 ahead of Lane0 by 5 Clock
16: Lane1 ahead of Lane0 by 6 Clock
17: Lane1 ahead of Lane0 by 7 Clock
18: Lane1 ahead of Lane0 by 8 Clock (not used)
19: Lane1 ahead of Lane0 by 9 Clock (not used)
20: Lane1 ahead of Lane0 by 10 Clock (not used)
others: not used</description>
                  <bitRange>[30:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DESKEW_CTRL_SEL</name>
                  <description>De-skew Control Selection 
0: H/W control; By logic to detect the de-skew values 
1: F/W control ; By programming LNK_CONF[28:26] to select the de-skew values</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_INTR</name>
              <description>Link Interrupts</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1FFFFF</resetMask>
              <fields>
                <field>
                  <name>LTSSM_STATE_CHG</name>
                  <description>LTSSM State Change Interrupt</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LGOOD</name>
                  <description>LGOOD Received Interrupt</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LRTY</name>
                  <description>LRTY Received Interrupt</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LBAD</name>
                  <description>LBAD Received Interrupt</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LCRD</name>
                  <description>LCRD Recevied Interrupt</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LGO_U1</name>
                  <description>LGO_U1 Received Interrupt</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LGO_U2</name>
                  <description>LGO_U2 Received Interrupt</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LGO_U3</name>
                  <description>LGO_U3 Received Interrupt</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LAU</name>
                  <description>LAU Received Interrupt</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LXU</name>
                  <description>LXU Received Interrupt</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LPMA</name>
                  <description>LPMA Received Interrupt</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BAD_LCW</name>
                  <description>Unknown Link Command Word received (see LNK_COMMAND_WORD for details)</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LINK_ERROR</name>
                  <description>Link Error Count Threshold Reached
Not supported.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY_ERROR</name>
                  <description>PHY Error Count Threshold Reached
Not supported.</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>U2_INACTIVITY_TIMEOUT</name>
                  <description>U2 Inactivity Timeout Interrupt</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LTSSM_CONNECT</name>
                  <description>LTSSM Transition to Polling - indicating successful SuperSpeed far-end receiver termination detection</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LTSSM_DISCONNECT</name>
                  <description>LTSSM Transitions to SS.Disabled</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LTSSM_RESET</name>
                  <description>LTSSM Reset Received (Hot or Warm)</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DATA_RATE_CHANGE</name>
                  <description>Data Rate Changed</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LTSSM_U3_ENTRY</name>
                  <description>LTSSM U3 State interrupt
Note that the transmitter will not send LFPS for U3 exit handshake befor this bit cleared.</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_PING_LFPS</name>
                  <description>Ping.LFPS Received Interrupt</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_INTR_SET</name>
              <description>Link Interrupts Set</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1FFFFF</resetMask>
              <fields>
                <field>
                  <name>LTSSM_STATE_CHG</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LGOOD</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LRTY</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LBAD</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LCRD</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LGO_U1</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LGO_U2</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LGO_U3</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LAU</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LXU</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LPMA</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BAD_LCW</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LINK_ERROR</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY_ERROR</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>U2_INACTIVITY_TIMEOUT</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LTSSM_CONNECT</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LTSSM_DISCONNECT</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LTSSM_RESET</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DATA_RATE_CHANGE</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LTSSM_U3_ENTRY</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_PING_LFPS</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_INTR_MASK</name>
              <description>Link Interrupts Mask</description>
              <addressOffset>0xC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1FFFFF</resetMask>
              <fields>
                <field>
                  <name>LTSSM_STATE_CHG_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LGOOD_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LRTY_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LBAD_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LCRD_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LGO_U1_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LGO_U2_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LGO_U3_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LAU_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LXU_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LPMA_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BAD_LCW_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LINK_ERROR_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY_ERROR_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>U2_INACTIVITY_TIMEOUT_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LTSSM_CONNECT_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LTSSM_DISCONNECT_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LTSSM_RESET_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DATA_RATE_CHANGE_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LTSSM_U3_ENTRY_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_PING_LFPS</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_INTR_MASKED</name>
              <description>Link Interrupts Masked</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1FFFFF</resetMask>
              <fields>
                <field>
                  <name>LTSSM_STATE_CHG_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LGOOD_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LRTY_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LBAD_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LCRD_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LGO_U1_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LGO_U2_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LGO_U3_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LAU_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LXU_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LPMA_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>BAD_LCW_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LINK_ERROR_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PHY_ERROR_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>U2_INACTIVITY_TIMEOUT_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LTSSM_CONNECT_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LTSSM_DISCONNECT_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LTSSM_RESET_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DATA_RATE_CHANGE_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LTSSM_U3_ENTRY_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RX_PING_LFPS</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_ERROR_CONF</name>
              <description>Link Error Counter Configuration</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x7FFF</resetValue>
              <resetMask>0x7FFF</resetMask>
              <fields>
                <field>
                  <name>HP_TIMEOUT_EN</name>
                  <description>PENDING_HP_TIMER Timeout Count Enable
Header Packet acknowledgement has not been received by PENDING_HP_TIMEOUT.
[USB 3.0:  7.2.4.1.10, p 7-21]</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_SEQ_NUM_ERR_EN</name>
                  <description>Rx Header Sequence Number Error Count Enable
Received Rx Header Sequence Number does not match what is expected.
[USB 3.0:  7.3.3.3, p 7-28]</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_HP_FAIL_EN</name>
                  <description>Receive Header Packet Fail Count Enable
Link Layer Block has failed to receive a Header Packet for three consecutive times.  Failures are CRC errors or spurious K-symbols.
[USB 3.0:  7.3.3.2, p 7-28]</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MISSING_LGOOD_EN</name>
                  <description>Not used</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MISSING_LCRD_EN</name>
                  <description>Missing LCRD_x Detection Count Enable
LCRD_x Sequence does not match what is expected.
[USB 3.0:  7.3.4, p 7-29]</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CREDIT_HP_TIMEOUT_EN</name>
                  <description>CREDIT_HP_TIMER Timeout Count Enable
Remote Rx Header Buffer Credit has not been received by CREDIT_HP_TIMEOUT.
[USB 3.0:  7.2.4.1.10, p 7-21...7-22]</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PM_LC_TIMEOUT_EN</name>
                  <description>PM_LC_TIMER Timeout Count Enable
This indicates that an LGO_Ux, LAU, or LXU Link Command has been missed.
[USB 3.0:  7.3.4, p 7-29]</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TX_SEQ_NUM_ERR_EN</name>
                  <description>ACK Tx Header Sequence Number Error Count Enable
Received LGOOD_n does not match ACK Tx Header Sequence Number.
[USB 3.0: 7.3.5, p 7-30]</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HDR_ADV_TIMEOUT_EN</name>
                  <description>Header Sequence Number Advertisement PENDING_HP_TIMER Timeout Count Enable
PENDING_HP_TIMER timeout before receipt of Header Sequence Number LGOOD_n Link Command
[USB 3.0:  7.3.6, p 7-30]</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HDR_ADV_HP_EN</name>
                  <description>Header Sequence Number Advertisement HP Received Error Count Enable
Header Packet received during Header Sequence Number Advertisement
[USB 3.0: 7.3.6, p 7-30]</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HDR_ADV_LCRD_EN</name>
                  <description>Header Sequence Number Advertisement LCRD_x Received Error Count Enable
LCRD_x Link Command received during Header Sequence Number Advertisement
[USB 3.0: 7.3.6, p 7-30]</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HDR_ADV_LGO_EN</name>
                  <description>Header Sequence Number Advertisement LGO_Ux Received Error Count Enable
LGO_Ux Link Command received during Header Sequence Number Advertisement
[USB 3.0:  7.3.6, p 7-30]</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CREDIT_ADV_TIMEOUT_EN</name>
                  <description>Rx Header Buffer Credit Advertisement CREDIT_HP_TIMER Timeout Count Enable
CREDIT_HP_TIMER timeout before receipt of LCRD_x Link Command during Rx Header Buffer Credit Advertisement
[USB 3.0:  7.3.7, p 7-30...7-31]</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CREDIT_ADV_HP_EN</name>
                  <description>Rx Header Buffer Credit Advertisement HP Received Error Count Enable
Header Packet received during Rx Header Buffer Credit Advertisement.
[USB 3.0:  7.3.7, p 7-30...7-31]</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CREDIT_ADV_LGO_EN</name>
                  <description>Rx Header Buffer Credit Advertisement LGO_Ux Received Error Count Enable
LGO_Ux Link Command received during Rx Header Buffer Credit Advertisement.
[USB 3.0:  7.3.7, p 7-30...7-31]</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_ERROR_STATUS</name>
              <description>Link Error Status Register</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFF</resetMask>
              <fields>
                <field>
                  <name>HP_TIMEOUT_EV</name>
                  <description>Indicates this error (see LNK_ERROR_CONF for description) occurred since this bit was last cleared by firmware.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_SEQ_NUM_ERR_EV</name>
                  <description>Indicates this error (see LNK_ERROR_CONF for description) occurred since this bit was last cleared by firmware.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_HP_FAIL_EV</name>
                  <description>Indicates this error (see LNK_ERROR_CONF for description) occurred since this bit was last cleared by firmware.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MISSING_LGOOD_EV</name>
                  <description>Not used</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MISSING_LCRD_EV</name>
                  <description>Indicates this error (see LNK_ERROR_CONF for description) occurred since this bit was last cleared by firmware.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CREDIT_HP_TIMEOUT_EV</name>
                  <description>Indicates this error (see LNK_ERROR_CONF for description) occurred since this bit was last cleared by firmware.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PM_LC_TIMEOUT_EV</name>
                  <description>Indicates this error (see LNK_ERROR_CONF for description) occurred since this bit was last cleared by firmware.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TX_SEQ_NUM_ERR_EV</name>
                  <description>Indicates this error (see LNK_ERROR_CONF for description) occurred since this bit was last cleared by firmware.</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HDR_ADV_TIMEOUT_EV</name>
                  <description>Indicates this error (see LNK_ERROR_CONF for description) occurred since this bit was last cleared by firmware.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HDR_ADV_HP_EV</name>
                  <description>Indicates this error (see LNK_ERROR_CONF for description) occurred since this bit was last cleared by firmware.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HDR_ADV_LCRD_EV</name>
                  <description>Indicates this error (see LNK_ERROR_CONF for description) occurred since this bit was last cleared by firmware.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HDR_ADV_LGO_EV</name>
                  <description>Indicates this error (see LNK_ERROR_CONF for description) occurred since this bit was last cleared by firmware.</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CREDIT_ADV_TIMEOUT_EV</name>
                  <description>Indicates this error (see LNK_ERROR_CONF for description) occurred since this bit was last cleared by firmware.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CREDIT_ADV_HP_EV</name>
                  <description>Indicates this error (see LNK_ERROR_CONF for description) occurred since this bit was last cleared by firmware.</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CREDIT_ADV_LGO_EV</name>
                  <description>Indicates this error (see LNK_ERROR_CONF for description) occurred since this bit was last cleared by firmware.</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_ERROR_COUNT</name>
              <description>Error Counter Register</description>
              <addressOffset>0x1C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LINK_ERROR_COUNT</name>
                  <description>The Link Error Count keeps track of the number of errors for which the Link Layer Block had to transition to the Recovery State before resuming normal operation.  Each error class is enablable (default on) to allow for debugging purposes.
Not supported</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PHY_ERROR_COUNT</name>
                  <description>Count of receive errors from the USB 3.0 PHY.  This is for debug purposes.
Not supported</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_ERROR_COUNT_THRESHOLD</name>
              <description>Error Count Thresholds</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LINK_ERROR_THRESHOLD</name>
                  <description>Link Error Count Threshold for Interrupt Generation</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY_ERROR_THRESHOLD</name>
                  <description>PHY Error Count Threshold for Interrupt Generation</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_PHY_CONF</name>
              <description>USB 3.0 PHY Configuration</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x202005</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>PHY_MODE</name>
                  <description>PHY Operation Mode
    01 = USB Super Speed</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ELASTICIY_BUFFER_MODE</name>
                  <description>PHY Elasticity Buffer Operation Mode
    0 = half full
    1 = empty</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXDETECTRX_LB_OVR</name>
                  <description>PHY TxDetectRx/Loopback Override</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXDETECTRX_LB_OVR_VAL</name>
                  <description>PHY TxDetectRx/Loopback Override Value</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXELECIDLE_OVR</name>
                  <description>PHY TxElecIdle Override</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXELECIDLE_OVR_VAL</name>
                  <description>PHY TxElecIdle Override Value</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXCOMPLIANCE_OVR</name>
                  <description>PHY TxCompliance Override</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TXCOMPLIANCE_OVR_VAL</name>
                  <description>PHY TxCompliance Override Value</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TXONESZEROS_OVR</name>
                  <description>PHY TxOnesZeros Override</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXONESZEROS_OVR_VAL</name>
                  <description>PHY TxOnesZeros Override Value</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RXPOLARITY_OVR</name>
                  <description>PHY RxPolarity Override</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RXPOLARITY_OVR_VAL</name>
                  <description>PHY RxPolarity Override Value</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RXEQ_TRAINING_OVR</name>
                  <description>PHY RxEqTraining Override</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RXEQ_TRAINING_OVR_VAL</name>
                  <description>PHY RxEqTraining Override Value</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY_RESET_N_OVR</name>
                  <description>PHY PIPE RESET# Override</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY_RESET_N_OVR_VAL</name>
                  <description>PHY PIPE RESET# Override Value</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY_POWERDOWN_OVR</name>
                  <description>PHY PowerDown Override</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY_POWERDOWN_OVR_VAL</name>
                  <description>PHY PowerDown Override Value</description>
                  <bitRange>[19:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY_RATE_OVR</name>
                  <description>PHY Rate Override</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY_RATE_OVR_VAL</name>
                  <description>PHY Rate Override Value</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY_TX_DEEMPH_OVR</name>
                  <description>PHY Transmitter De-emphasis Override</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY_TX_DEEMPH_OVR_VAL</name>
                  <description>PHY Transmitter De-emphasis Override Value</description>
                  <bitRange>[24:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY_TX_MARGIN</name>
                  <description>PHY Transmitter Voltage Levels</description>
                  <bitRange>[27:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXSWING</name>
                  <description>PHY Transmitter Voltage Swing Level 0=full swing 1=low swing</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_TERMINATION_OVR</name>
                  <description>PHY Receiver Termination Override</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_TERMINATION_OVR_VAL</name>
                  <description>PHY Receiver Termination Override Value 0=removed 1=present</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_TERMINATION_ENABLE</name>
                  <description>PHY Receiver Termination Enable</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_PHY_STATUS</name>
              <description>USB 3.0 PHY Status</description>
              <addressOffset>0x28</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FF</resetMask>
              <fields>
                <field>
                  <name>RXVALID</name>
                  <description>PHY Receive Valid (symbol lock and valid data)</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PHY_STATUS</name>
                  <description>PHY Status (operation complete)</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RX_ELEC_IDLE</name>
                  <description>Receiver Detection of an Electrical Idle (LFPS Signalling)</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RXSTATUS</name>
                  <description>PHY Receiver Status and Error Codes
    000  Receive Data OK
    001  1 SKP Ordered Set added (USB SuperSpeed Mode)
    010  1 SKP Ordered Set removed (USB SuperSpeed Mode)
    011  Receiver Detected (during Receiver Detection Sequence)
    100  8b/10b (128b/132b) Decode Error or Receive Disparity Error
    101  Elastic Buffer overflow
    110  Elastic Buffer underflow
    111  Receive Disparity Error</description>
                  <bitRange>[5:3]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>POWER_PRESENT</name>
                  <description>Presence of VBUS</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DATA_BUS_WIDTH</name>
                  <description>Data Bus Width
    00: 32-bit mode</description>
                  <bitRange>[8:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RXCONNECT</name>
                  <description>Rx Connect/Disconnect - Far-end Receiver Termination Detection
Stored result from last Rx.Detect Sequence</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_PHY_ERROR_CONF</name>
              <description>PHY Error Counter Configuration</description>
              <addressOffset>0x48</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1FF</resetValue>
              <resetMask>0x1FF</resetMask>
              <fields>
                <field>
                  <name>PHY_ERROR_DECODE_EN</name>
                  <description>Enable Counting of 8b/10b Decode Errors
    (RxStatus == 3'b100)</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY_ERROR_EB_OVR_EN</name>
                  <description>Enable Counting of Elastic Buffer Overflow
    (RxStatus == 3'b101)</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY_ERROR_EB_UND_EN</name>
                  <description>Enable Counting of Elastic Buffer Underflow
    (RxStatus == 3'b110)</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY_ERROR_DISPARITY_EN</name>
                  <description>Enable Counting of Receive Disparity Error
    (RxStatus == 3'b111)</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_ERROR_CRC5_EN</name>
                  <description>Enable Counting of Receive CRC-5 Error</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_ERROR_CRC16_EN</name>
                  <description>Enable Counting of Receive CRC-16 Error</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_ERROR_CRC32_EN</name>
                  <description>Enable Counting of Receive CRC-32 Error</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TRAINING_ERROR_EN</name>
                  <description>Enable Counting of Training Sequence Error</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY_LOCK_EN</name>
                  <description>Enable Counting of PHY Lock Loss
   Lock Indicator To Be Determined</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_PHY_ERROR_STATUS</name>
              <description>PHY Error Status Register</description>
              <addressOffset>0x4C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1FF</resetMask>
              <fields>
                <field>
                  <name>PHY_ERROR_DECODE_EV</name>
                  <description>Indicates this error (see LNK_ERROR_CONF for description) occurred since this bit was last cleared by firmware.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY_ERROR_EB_OVR_EV</name>
                  <description>Indicates this error (see LNK_ERROR_CONF for description) occurred since this bit was last cleared by firmware.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY_ERROR_EB_UND_EV</name>
                  <description>Indicates this error (see LNK_ERROR_CONF for description) occurred since this bit was last cleared by firmware.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY_ERROR_DISPARITY_EV</name>
                  <description>Indicates this error (see LNK_ERROR_CONF for description) occurred since this bit was last cleared by firmware.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_ERROR_CRC5_EV</name>
                  <description>Indicates this error (see LNK_ERROR_CONF for description) occurred since this bit was last cleared by firmware.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_ERROR_CRC16_EV</name>
                  <description>Indicates this error (see LNK_ERROR_CONF for description) occurred since this bit was last cleared by firmware.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_ERROR_CRC32_EV</name>
                  <description>Indicates this error (see LNK_ERROR_CONF for description) occurred since this bit was last cleared by firmware.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TRAINING_ERROR_EV</name>
                  <description>Indicates this error (see LNK_ERROR_CONF for description) occurred since this bit was last cleared by firmware.</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY_LOCK_EV</name>
                  <description>Indicates this error (see LNK_ERROR_CONF for description) occurred since this bit was last cleared by firmware.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_PHY_TRAINING_HOLDOFF</name>
              <description>PHY Training Hold Off</description>
              <addressOffset>0x50</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x249F0EA6</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>GEN1_HOLDOFF</name>
                  <description>Hold off period before PHY training begins to prevent termination reflection errors.
Default is 30 us, period is measured in 125MHz clocks.
[USB 3.0:  7.5.4.4.1, p 7-44]</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GEN2_HOLDOFF</name>
                  <description>Hold off period before PHY training, assertion of the rxequalization of PIPE  begins to prevent termination reflection errors.
Default is 30 us, period is measured in 312.5MHz clocks.
[USB 3.2:  7.5.4.7.1]</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_COMMAND_WORD</name>
              <description>Link Command Word (received)</description>
              <addressOffset>0x54</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FF</resetMask>
              <fields>
                <field>
                  <name>COMMAND</name>
                  <description>Link Command Word</description>
                  <bitRange>[10:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_DEVICE_POWER_CONTROL</name>
              <description>USB 3.0 Device Power State Control</description>
              <addressOffset>0x58</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFC0303F7</resetMask>
              <fields>
                <field>
                  <name>TX_U1</name>
                  <description>Transmit LGO_U1 - Request to go to U1 Power State (send LGO_U1)
This bit is cleared by h/w when the LCW is transmitted.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TX_U2</name>
                  <description>Transmit LGO_U2 - Request to go to U2 Power State (send LGO_U2)
This bit is cleared by h/w when the LCW is transmitted.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TX_U3</name>
                  <description>Transmit LGO_U3 - Request to go to U3 Power State (send LGO_U3)
This bit is cleared by h/w when the LCW is transmitted.
Note that an upstream port is not allowed to initiate entry to U3, so this should not be used for device mode.
[USB 3.0:  7.2.4.2.4, p 7-25]</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_U1</name>
                  <description>LGO_U1 Received - Request to go to U1 Power State
This bit is cleared by h/w concurrent with TX_LAU/TX_LXU being cleared.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RX_U2</name>
                  <description>LGO_U2 Received - Request to go to U2 Power State, clear to NAK (send LXU)
This bit is cleared by h/w concurrent with TX_LAU/TX_LXU being cleared.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RX_U3</name>
                  <description>LGO_U3 Received - Request to go to U3 Power State, clear to NAK (send LXU)
This bit is cleared by h/w concurrent with TX_LAU/TX_LXU being cleared.
Note that an upstream port is not allowed to reject entry to U3.
[USB 3.0:  7.2.4.2.4, p 7-25]</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TX_LAU</name>
                  <description>Transmit LAU (ACK) in response to RX_U1/RX_U2/RX_U3.
Transition to requested power state (LTSSM)
This bit is cleared when the acknowledgement is sent.</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TX_LXU</name>
                  <description>Transmit LXU (NAK) in response to RX_U1/RX_U2/RX_U3.
Do not transition to requested power state (LTSSM)
This bit is cleared when the acknowledgement is sent.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EXIT_LP</name>
                  <description>Exit Low Power State
This bit is cleared by h/w when the Link Layer has exited U1/U2/U3.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>U3_EXIT_ON_HOLD</name>
                  <description>The U3 Exit LFPS handshake will not start when this bit is set.</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>U3_EXIT_ON_HOLD_EN</name>
                  <description>Enable U3 Exit handshake on hold bit
Note that this bit shall be reset when U3 Exit initiating by Device.</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AUTO_U1</name>
                  <description>When host requests transition to U1, automatically accept (send LAU) or rejects (send LXU) depending on pending activity.  The interrupt RX_U1 is still raised for firmware to monitor, take additional power saving actions.</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AUTO_U2</name>
                  <description>When host requests transition to U2, automatically accept (send LAU) or rejects (send LXU) depending on pending activity. The interrupt RX_U2 is still raised for firmware to monitor, take additional power saving actions.</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NO_U1</name>
                  <description>When host requests transition to U1, automatically reject (send LXU).
The interrupt RX_U1 is still raised for firmware to monitor, take additional actions.
This bit must be cleared by firmware when FORCE_PM_ACCEPT is received from host.</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NO_U2</name>
                  <description>When host requests transition to U2, automatically reject (send LXU).
The interrupt RX_U2 is still raised for firmware to monitor, take additional actions. This bit must be cleared by firmware when FORCE_PM_ACCEPT is received from host.</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>YES_U1</name>
                  <description>When host requests transition to U1, automatically accept (send LAU).
The interrupt RX_U1 is still raised for firmware to monitor, take additional power saving actions.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>YES_U2</name>
                  <description>When host requests transition to U2, automatically accept (send LAU).
The interrupt RX_U2 is still raised for firmware to monitor, take additional power saving actions.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_STATE</name>
              <description>Link Training Status State Machine (LTSSM) State</description>
              <addressOffset>0x5C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x8003FFFF</resetMask>
              <fields>
                <field>
                  <name>LTSSM_STATE</name>
                  <description>LTSSM State
See USB3LNK_LTSSM Tab for more details.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LTSSM_OVERRIDE_VALUE</name>
                  <description>LTSSM State from FW (if LTSSM_OVERRIDE_ENABLE == 1 or LTSSM_OVERRIDE_GO == 1)</description>
                  <bitRange>[11:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LTSSM_OVERRIDE_EN</name>
                  <description>FW Control of LTSSM State
Setting this bit will cause the LTSSM State Machine to transition to the state in LTSSM_OVERRIDE_VALUE and remain there.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LTSSM_OVERRIDE_GO</name>
                  <description>FW Setting of LTSSM State
Setting this bit will cause the LTSSM State Machine to transition to the value given in LTSSM_OVERRIDE_VALUE, but the state machine will not be held there and may transition to other states as dictated by the logic
To enable the U0 force entry:
// This is for Powerdown as 0
      regacc.regrd_n('USB32DEV_LNK_LNK_PHY_CONF', rd_data);
      wr_data = rd_data ;
      wr_data[17] = 'd1 ;
      wr_data[19:18] = 'd0  ;
      regacc.regwr_n('USB32DEV_LNK_LNK_PHY_CONF', wr_data);
// This is for U0 LTSSM
      regacc.regrd_n('USB32DEV_LNK_LNK_LTSSM_STATE', rd_data);
      wr_data = rd_data ;
      wr_data[11:6] = 'd16 ;
      wr_data[12]   = 'd1  ;
      regacc.regwr_n('USB32DEV_LNK_LNK_LTSSM_STATE', wr_data);
// Wait
      #0.5us ;
// Here enable is de-asserted and go is asserted 
      regacc.regrd_n('USB32DEV_LNK_LNK_LTSSM_STATE', rd_data);
      wr_data = rd_data ;
      wr_data[11:6] = 'd16 ;
      wr_data[12]   = 'd0  ;
      wr_data[13]   = 'd1  ;
      regacc.regwr_n('USB32DEV_LNK_LNK_LTSSM_STATE', wr_data);</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LOOPBACK_MASTER</name>
                  <description>Loopback Master Enable
When transmitting TS2 ordered sets in Polling or Recovery State, the Link Layer Block will enter the Loopback State as the Loopback Master if this bit is set.  The Link Layer Block will then exit the Loopback State when this bit is cleared.
[USB 3.0:  7.5.4.6.1, p 7-45;  7.5.10.5.2, p 7-55]</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DISABLE_SCRAMBLING</name>
                  <description>Scrambling Disable
When transmitting TS2 ordered sets in Polling or Recovery State, the Link Layer Block will set the Disable Scrambling bit.
[USB 3.0:  7.5.4.6.1, p 7-45]</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LOOPBACK_ERROR</name>
                  <description>Loopback Master Error Detected</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LOOPBACK_GOOD</name>
                  <description>Loopback Master Good
Transmit sequence is being received correctly.</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LTSSM_FREEZE</name>
                  <description>Freeze LTSSM to allow FW to inspect its current state.
Setting this bit will cease all header packet transmission.  Incoming header packets will still be received and acknowledged but no more header packets will be accepted for transmission from the protocol layer.  It is expected that soon after this bit is set RX a queue will fill up and become stable for firmware to inspect.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LOOPBACK_INIT</name>
              <description>Loopback LFSR Initial Value</description>
              <addressOffset>0x60</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>INIT</name>
                  <description>Initial value for Loopback LFSR Transmitter</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LOOPBACK_GENERATOR</name>
              <description>Loopback LFSR Transmitter Generator Polynomial</description>
              <addressOffset>0x64</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xC0000030</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>GENERATOR</name>
                  <description>Generator Polynomial for Loopback LFSR Transmitter</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_OBSERVE</name>
              <description>Link Training Status State Machine (LTSSM) Observation</description>
              <addressOffset>0x68</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x4080</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RX_DETECT_MISS_CNT</name>
                  <description>Number of RxDetect events where no termination was detected since last RxDetect event</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RX_DETECT_MISS_LIMIT</name>
                  <description>Number of RxDetect attempts before giving up (default 8x as per spec)</description>
                  <bitRange>[7:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RECOVERY_CNT</name>
                  <description>Number of Recovery attempts from U0 since last entering U0</description>
                  <bitRange>[11:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RECOVERY_LIMIT</name>
                  <description>Number of Recovery attempts before going to SS.Inactive from U0 (default 4x as per spec).</description>
                  <bitRange>[15:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TS1_RCVD_CNT</name>
                  <description>Number of TS1 Ordered Sets received since last Polling state entry</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TS2_RCVD_CNT</name>
                  <description>Number of TS2 Ordered Sets received since last Polling/HotReset state entry</description>
                  <bitRange>[23:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>IDLE_RCVD_CNT</name>
                  <description>Number of Idle Symbols Received since last HotReset entry</description>
                  <bitRange>[27:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>POLLING_LFPS_COMPLETED</name>
                  <description>Indicates whether a Polling.LFPS sequence has ever been completed since the last Block Reset or VBUS Off/On event</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RX_DISABLE_SCRAMBLING</name>
                  <description>Received DISABLE_SCRAMBLING Bit in Link Functionality Symbol</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DATA_RATE_CONFIG</name>
                  <description>00: GEN1x1
01: GEN1x2
10: GEN2x1
11: GEN2x2</description>
                  <bitRange>[31:30]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_OBSERVE</name>
              <description>LFPS Receiver Observability</description>
              <addressOffset>0x6C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FF0FFF</resetMask>
              <fields>
                <field>
                  <name>POLLING_DET</name>
                  <description>LFPS Sequence detected since last cleared by CPU</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PING_DET</name>
                  <description>LFPS Sequence detected since last cleared by CPU</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RESET_DET</name>
                  <description>LFPS Sequence detected since last cleared by CPU</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>U1_EXIT_DET</name>
                  <description>LFPS Sequence detected since last cleared by CPU</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>U2_EXIT_DET</name>
                  <description>LFPS Sequence detected since last cleared by CPU</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>U3_EXIT_DET</name>
                  <description>LFPS Sequence detected since last cleared by CPU</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LOOPBACK_DET</name>
                  <description>tied to '0'. Not used</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SCD1_DET</name>
                  <description>LFPS Sequence detected since last cleared by CPU</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SCD2_DET</name>
                  <description>LFPS Sequence detected since last cleared by CPU</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY_CAP_LBPM_10G_DET</name>
                  <description>LFPS Sequence detected since last cleared by CPU</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY_CAP_LBPM_5G_DET</name>
                  <description>LFPS Sequence detected since last cleared by CPU</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHY_READY_LBPM_DET</name>
                  <description>LFPS Sequence detected since last cleared by CPU</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>POLLING_LFPS_RCVD</name>
                  <description>Number of LFPS Polling Bursts Received since last Polling.LFPS entry</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>POLLING_LFPS_SENT</name>
                  <description>Number of LFPS Polling Bursts Sent since last Polling.LFPS entry</description>
                  <bitRange>[25:21]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_POLLING_BURST</name>
              <description>LFPS Polling Transmit Configuration</description>
              <addressOffset>0x70</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x7D</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST16</name>
                  <description>Clock periods for LFPS Burst, when LFPS signalling is transmitted  (default:  1.0us)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_POLLING_REPEAT</name>
              <description>LFPS Polling Transmit Configuration</description>
              <addressOffset>0x74</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x4E2</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>REPEAT16</name>
                  <description>Clock periods for LFPS Repeat, the time between LFPS Bursts  (default:  10.0 us)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_PING_BURST</name>
              <description>LFPS Ping Transmit Configuration</description>
              <addressOffset>0x78</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xF</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST16</name>
                  <description>Clock periods for Ping.LFPS Burst signalling transmission  (default:  120 ns)
SS: range of (40ns, 200ns)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_PING_REPEAT</name>
              <description>LFPS Ping Transmit Configuration</description>
              <addressOffset>0x7C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x17D7840</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>REPEAT32</name>
                  <description>Clock periods for LFPS Repeat</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_U1_EXIT</name>
              <description>LFPS U1_EXIT Transmit Configuration</description>
              <addressOffset>0x80</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x71</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST24</name>
                  <description>Number of clock periods for LFPS Burst transmission  (default:  904 ns)
Note: There is an uncertainty of the exact duration (+/- one clock cycle period) due to synchronization latency.  The suggested value to be programmed should avoid from the boundary.</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_U2_EXIT</name>
              <description>LFPS U2_EXIT Transmit Configuration</description>
              <addressOffset>0x84</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x2710</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST24</name>
                  <description>Minimum number of clock periods for LFPS Burst transmission  (default:  80 us)
Note: There is an uncertainty of the exact duration (+/- one clock cycle period) due to synchronization latency.  The suggested value to be programmed should avoid from the boundary.</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_U3_EXIT</name>
              <description>LFPS U3 Exit Transmit Configuration</description>
              <addressOffset>0x88</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x2710</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST24</name>
                  <description>Minimum number of clock periods for LFPS Burst transmission (default: 80 us)
Note: There is an uncertainty of the exact duration (+/- one clock cycle period) due to synchronization latency.  The suggested value to be programmed should avoid from the boundary.</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_POLLING_BURST</name>
              <description>LFPS Polling Detect Configuration</description>
              <addressOffset>0x8C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xAF004B</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST_MIN</name>
                  <description>Minimum number of clock periods for detection of Polling.LFPS Burst  (default:  0.6 us)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BURST_MAX</name>
                  <description>Maximum number of clock periods for detection of Polling.LFPS Burst  (default:  1.4 us)</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_POLLING_REPEAT</name>
              <description>LFPS Polling Detect Configuration</description>
              <addressOffset>0x90</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x6D602EE</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>REPEAT_MIN</name>
                  <description>Minimum number of clock periods of idle (non-LFPS) time between LFPS Bursts for detection of Polling.LFPS signalling  (default:  6 us)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REPEAT_MAX</name>
                  <description>Maximum number of clock periods of idle (non-LFPS) time between LFPS Bursts for detection of Polling.LFPS signalling  (default:  14 us)</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_PING</name>
              <description>LFPS Ping Detect Configuration</description>
              <addressOffset>0x94</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x190005</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST_MIN</name>
                  <description>Minimum number of clock periods for detection of Ping.LFPS Burst  (default: 40 ns)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BURST_MAX</name>
                  <description>Maximum number of clock periods for detection of Ping.LFPS Burst  (default:  200 ns)</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_RESET</name>
              <description>LFPS Reset Detect Configuration</description>
              <addressOffset>0x98</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x989680</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST24</name>
                  <description>Minimum number of clock periods for detection
(default: 80ms)</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_U1_EXIT</name>
              <description>LFPS U1 Exit Detect Configuration</description>
              <addressOffset>0x9C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x26</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST24</name>
                  <description>Minimum number of clock periods for U1 Exit Burst detection  (default:  304 ns)
Note: There is an uncertainty of the exact duration (+/- one clock cycle period) due to synchronization latency.  The suggested value to be programmed should avoid from the boundary.</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_U2_EXIT</name>
              <description>LFPS U2 Exit Detect Configuration</description>
              <addressOffset>0xA0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x2710</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST24</name>
                  <description>Minimum number of clock periods for U2 Exit Burst detection  (default:  80 us)
Note: There is an uncertainty of the exact duration (+/- one clock cycle period) due to synchronization latency.  The suggested value to be programmed should avoid from the boundary.</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_U3_EXIT</name>
              <description>LFPS U3 Exit Detect Configuration</description>
              <addressOffset>0xA4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x2710</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST24</name>
                  <description>Minimum number of clock periods for detection
(default: 80us)
Note: There is an uncertainty of the exact duration (+/- one clock cycle period) due to synchronization latency.  The suggested value to be programmed should avoid from the boundary.</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_U1_HANDSHAKE</name>
              <description>LFPS U1 Exit Handshake Configuration</description>
              <addressOffset>0xA8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x26</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST24</name>
                  <description>Minimum number of clock periods for LFPS handshake detection (default: 304 ns)
Note: There is an uncertainty of the exact duration (+/- one clock cycle period) due to synchronization latency.  The suggested value to be programmed should avoid from the boundary.</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_U2_HANDSHAKE</name>
              <description>LFPS U2 Exit Handshake Configuration</description>
              <addressOffset>0xAC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x2710</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST24</name>
                  <description>Minimum number of clock periods for LFPS handshake detection (default: 80 us)
Note: There is an uncertainty of the exact duration (+/- one clock cycle period) due to synchronization latency.  The suggested value to be programmed should avoid from the boundary.</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_U3_HANDSHAKE</name>
              <description>LFPS U3 Exit Handshake Configuration</description>
              <addressOffset>0xB0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x2710</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST24</name>
                  <description>Minimum number of clock periods for LFPS handshake detection (default: 80 us)
Note: There is an uncertainty of the exact duration (+/- one clock cycle period) due to synchronization latency.  The suggested value to be programmed should avoid from the boundary.</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_LOOPBACK_EXIT</name>
              <description>LFPS Loopback Exit Detect Configuration</description>
              <addressOffset>0xB4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x2710</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST24</name>
                  <description>Minimum number of clock periods for detection
(default: 80us)
Note: There is an uncertainty of the exact duration (+/- one clock cycle period) due to synchronization latency.  The suggested value to be programmed should avoid from the boundary.</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_LOOPBACK_HANDSHAKE</name>
              <description>LFPS Loopback Exit Handshake Configuration</description>
              <addressOffset>0xB8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x2710</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST24</name>
                  <description>Minimum number of clock periods for LFPS handshake detection (default: 80 us)
Note: There is an uncertainty of the exact duration (+/- one clock cycle period) due to synchronization latency.  The suggested value to be programmed should avoid from the boundary.</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_IDLE</name>
              <description>LFPS Idle Time</description>
              <addressOffset>0xBC</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIME</name>
                  <description>Idle time before last LFPS burst</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_BURST</name>
              <description>LFPS Burst Length</description>
              <addressOffset>0xC0</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIME</name>
                  <description>Last LFPS burst length</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_TIME</name>
              <description>LFPS Idle Counter</description>
              <addressOffset>0xC4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIME</name>
                  <description>Time since end of last LFPS burst</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_PENDING_HP_TIMER</name>
              <description>Header Packet LGOOD/LBAD Timer</description>
              <addressOffset>0xC8</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMER16</name>
                  <description>PENDING_HP_TIMER Value</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_PENDING_HP_TIMEOUT</name>
              <description>Header Packet LGOOD/LBAD Timeout</description>
              <addressOffset>0xCC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x4E2</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT16</name>
                  <description>PENDING_HP_TIMER Timeout (default: 10 us)  [default:  table 7-7, p 7-22]
(0= Timer Disabled)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_CREDIT_HP_TIMER</name>
              <description>Header Packet LCRDx Timer</description>
              <addressOffset>0xD0</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMER</name>
                  <description>CREDIT_HP_TIMER Value</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_CREDIT_HP_TIMEOUT</name>
              <description>Header Packet LCRDx Timeout</description>
              <addressOffset>0xD4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x98968</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT</name>
                  <description>CREDIT_HP_TIMER Timeout (default: 5 ms)  [default:  table 7-7, p 7-22]
(0= Timer Disabled)</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_PM_TIMER</name>
              <description>Power Mode Timer</description>
              <addressOffset>0xD8</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMER</name>
                  <description>PM_TIMER Value</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_PM_LC_TIMEOUT</name>
              <description>Power Mode PM_LC_TIMER Timeout</description>
              <addressOffset>0xDC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1F4</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT16</name>
                  <description>PM_LC_TIMER Gen1x1 Timeout (default: 4 us)
(0= Timer Disabled)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_PM_ENTRY_TIMEOUT</name>
              <description>Power Mode PM_ENTRY_TIMER Timeout</description>
              <addressOffset>0xE0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x3E8</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT16</name>
                  <description>PM_ENTRY_TIMER Timeout (default: 8 us)   
(0= Timer Disabled)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_PM_UX_EXIT_TIMEOUT</name>
              <description>Power Mode Ux_EXIT_TIMER Timeout</description>
              <addressOffset>0xE4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xB71B0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT</name>
                  <description>Ux_EXIT_TIMER Timeout (default: 6 ms)  [default:  table 7-8, p 7-23]
(0= Timer Disabled)</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_TIMER</name>
              <description>LTSSM Timer Register</description>
              <addressOffset>0xE8</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMER</name>
                  <description>LTSSM State Transition Timer</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_TIMEOUT</name>
              <description>LTSSM Timeout Observability Register</description>
              <addressOffset>0xEC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFF</resetMask>
              <fields>
                <field>
                  <name>POLLING_LFPS</name>
                  <description>LTSSM Polling LFPS Timeout</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>POLLING_ACTIVE</name>
                  <description>LTSSM Polling Active Timeout</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>POLLING_IDLE</name>
                  <description>LTSSM Polling Idle Timeout</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>U1_EXIT</name>
                  <description>LTSSM U1 Exit Timeout</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>U2_EXIT</name>
                  <description>LTSSM U2 Exit Timeout</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>U3_EXIT</name>
                  <description>LTSSM U3 Exit Timeout</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HOT_RESET_ACTIVE</name>
                  <description>LTSSM Hot Reset Active Timeout</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HOT_RESET_EXIT</name>
                  <description>LTSSM Hot Reset Exit Timeout</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LOOPBACK_EXIT</name>
                  <description>LTSSM Loopback Exit Timeout</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RECOVERY_IDLE</name>
                  <description>LTSSM Recovery Idle Timeout</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RECOVERY_ACTIVE</name>
                  <description>LTSSM Recovery Active Timeout</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RECOVERY_CONFIG</name>
                  <description>LTSSM Recovery Configuration Timeout</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>POLLING_SCD_LFPS</name>
                  <description>LTSSM Polling SCD LFPS Timeout</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>POLLING_LBPM_LFPS</name>
                  <description>LTSSM Polling LBPM Timeout</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_RX_DETECT_PERIOD</name>
              <description>LTSSM RxDetect Period</description>
              <addressOffset>0xF8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x16E360</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD24</name>
                  <description>LTSSM RxDetect.Quiet Period (default: 12 ms)  [default:  table 7-12, p 7-36]
(0= Timer Disabled)</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_LUP_PERIOD</name>
              <description>LTSSM LUP Period</description>
              <addressOffset>0xFC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x4E2</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD24</name>
                  <description>LTSSM U0 LUP Transmision Interval (default: 10 us)  [default:  table7.5.6.1, p 7-48]
(0= Timer Disabled)</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_SS_INACTIVE_PERIOD</name>
              <description>LTSSM SS.Inactive Timeout</description>
              <addressOffset>0x100</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x16E360</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD24</name>
                  <description>LTSSM SS.Inactive.Quiet timeout (default: 12ms)
(0= Timer Disabled)</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_POLLING_LFPS_TIMEOUT</name>
              <description>LTSSM Polling LFPS Timeout</description>
              <addressOffset>0x104</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x2AEA540</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT</name>
                  <description>LTSSM Polling.LFPS Timeout (default: 360 ms)  [default:  table 7-12, p 7-36]
(0= Timer Disabled)</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_POLLING_ACTIVE_TIMEOUT</name>
              <description>LTSSM Polling Active Timeout</description>
              <addressOffset>0x108</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x16E360</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT24</name>
                  <description>LTSSM Polling.Active Timeout (default: 12 ms)  [default:  table 7-12, p 7-36]
(0= Timer Disabled)</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_POLLING_CONFIG_TIMEOUT</name>
              <description>LTSSM Polling Configuration Timeout</description>
              <addressOffset>0x10C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x16E360</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT24</name>
                  <description>LTSSM Polling.Configuration Timeout (default: 12 ms)  [default:  table 7-12, p 7-36]
(0= Timer Disabled)</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_POLLING_IDLE_TIMEOUT</name>
              <description>LTSSM Polling Idle Timeout</description>
              <addressOffset>0x110</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x3D090</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT24</name>
                  <description>LTSSM Polling.Idle Timeout (default: 2 ms)  [default:  table 7-12, p 7-36]
(0= Timer Disabled)</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_U1_EXIT_TIMEOUT</name>
              <description>LTSSM U1 Exit Timeout</description>
              <addressOffset>0x114</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x3D090</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT24</name>
                  <description>LTSSM U1 Timeout (default: 2 ms) for LFPS Handshake  [default:  table 7-12, p 7-36]
(0= Timer Disabled)</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_U2_EXIT_TIMEOUT</name>
              <description>LTSSM U2 Exit Timeout</description>
              <addressOffset>0x118</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x3D090</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT24</name>
                  <description>LTSSM U2 Timeout (default: 2 ms) for LFPS Handshake  [default:  table 7-12, p 7-36]
(0= Timer Disabled)</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_U3_EXIT_TIMEOUT</name>
              <description>LTSSM U3 Exit Timeout</description>
              <addressOffset>0x11C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1312D0</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT24</name>
                  <description>LTSSM U3 Timeout (default: 10 ms) for LFPS Handshake  [default:  table 7-12, p 7-36]
(0= Timer Disabled)</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_HOT_RESET_ACTIVE_TIMEOUT</name>
              <description>LTSSM Hot Reset Active Timeout</description>
              <addressOffset>0x120</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x16E360</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT24</name>
                  <description>LTSSM Hot Reset Acitve Timeout (default: 12 ms)  [default:  table 7-12, p 7-36]
(0= Timer Disabled)</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_HOT_RESET_EXIT_TIMEOUT</name>
              <description>LTSSM Hot Reset Exit Timeout</description>
              <addressOffset>0x124</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x3D090</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT24</name>
                  <description>LTSSM Hot Reset Exit Timeout (default: 2 ms)  [default:  table 7-12, p 7-36]
(0= Timer Disabled)</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_LOOPBACK_EXIT_TIMEOUT</name>
              <description>LTSSM Loopback Exit Timeout</description>
              <addressOffset>0x128</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x3D090</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT</name>
                  <description>LTSSM Loopback Exit Timeout (default: 2 ms)  [default:  table 7-12, p 7-36]
(0= Timer Disabled)</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_RECOVERY_IDLE_TIMEOUT</name>
              <description>LTSSM Recovery Idle Timeout</description>
              <addressOffset>0x12C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x3D090</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT24</name>
                  <description>LTSSM Recovery Idle Timeout (default: 2 ms)  [default:  table 7-12, p 7-36]
(0= Timer Disabled)</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_RECOVERY_ACTIVE_TIMEOUT</name>
              <description>LTSSM Recovery Active Timeout</description>
              <addressOffset>0x130</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x16E360</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT24</name>
                  <description>LTSSM Recovery Active Timeout (default: 12 ms)  [default:  table 7-12, p 7-36]
(0= Timer Disabled)</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_RECOVERY_CONFIG_TIMEOUT</name>
              <description>LTSSM Recovery.Configuration Timeout</description>
              <addressOffset>0x134</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xB71B0</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT24</name>
                  <description>LTSSM Recovery Configuration Timeout (default: 6 ms)  [default:  table 7-12, p 7-36]
(0= Timer Disabled)</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_LDN_TIMEOUT</name>
              <description>LTSSM LDN Received Timeout</description>
              <addressOffset>0x138</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1E848</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT24</name>
                  <description>LTSSM LDN Received Timeout (default: 1 ms)
(0= Timer Disabled)</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_LDN_TIMER</name>
              <description>LTSSM LDN Received Timer</description>
              <addressOffset>0x13C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMER24</name>
                  <description>LTSSM LDN Received Timeout (default: 1 ms)
(0= Timer Disabled)</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_COMPLIANCE_PATTERN_0</name>
              <description>Compliance Pattern CP0</description>
              <addressOffset>0x140</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x600</resetValue>
              <resetMask>0x1FFF</resetMask>
              <fields>
                <field>
                  <name>CP</name>
                  <description>Compliance Pattern</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>K_D</name>
                  <description>Symbol Type - 0: Data (D), 1: Symbol (K)</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SCRAMBLED</name>
                  <description>Scramble On/Off</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEEMPHASIS</name>
                  <description>De-emphasis On/Off</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LFPS</name>
                  <description>LFPS On/Off</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXONESZEROS</name>
                  <description>Enable TXONESZEROS (PIPE PHY Transmit Signal)</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_COMPLIANCE_PATTERN_1</name>
              <description>Compliance Pattern CP1</description>
              <addressOffset>0x144</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x44A</resetValue>
              <resetMask>0x1FFF</resetMask>
              <fields>
                <field>
                  <name>CP</name>
                  <description>Compliance Pattern</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>K_D</name>
                  <description>Symbol Type - 0: Data (D), 1: Symbol (K)</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SCRAMBLED</name>
                  <description>Scramble On/Off</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEEMPHASIS</name>
                  <description>De-emphasis On/Off</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LFPS</name>
                  <description>LFPS On/Off</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXONESZEROS</name>
                  <description>Enable TXONESZEROS (PIPE PHY Transmit Signal)</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_COMPLIANCE_PATTERN_2</name>
              <description>Compliance Pattern CP2</description>
              <addressOffset>0x148</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x478</resetValue>
              <resetMask>0x1FFF</resetMask>
              <fields>
                <field>
                  <name>CP</name>
                  <description>Compliance Pattern</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>K_D</name>
                  <description>Symbol Type - 0: Data (D), 1: Symbol (K)</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SCRAMBLED</name>
                  <description>Scramble On/Off</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEEMPHASIS</name>
                  <description>De-emphasis On/Off</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LFPS</name>
                  <description>LFPS On/Off</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXONESZEROS</name>
                  <description>Enable TXONESZEROS (PIPE PHY Transmit Signal)</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_COMPLIANCE_PATTERN_3</name>
              <description>Compliance Pattern CP3</description>
              <addressOffset>0x14C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x5BC</resetValue>
              <resetMask>0x1FFF</resetMask>
              <fields>
                <field>
                  <name>CP</name>
                  <description>Compliance Pattern</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>K_D</name>
                  <description>Symbol Type - 0: Data (D), 1: Symbol (K)</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SCRAMBLED</name>
                  <description>Scramble On/Off</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEEMPHASIS</name>
                  <description>De-emphasis On/Off</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LFPS</name>
                  <description>LFPS On/Off</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXONESZEROS</name>
                  <description>Enable TXONESZEROS (PIPE PHY Transmit Signal)</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_COMPLIANCE_PATTERN_4</name>
              <description>Compliance Pattern CP4</description>
              <addressOffset>0x150</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xC00</resetValue>
              <resetMask>0x1FFF</resetMask>
              <fields>
                <field>
                  <name>CP</name>
                  <description>Compliance Pattern</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>K_D</name>
                  <description>Symbol Type - 0: Data (D), 1: Symbol (K)</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SCRAMBLED</name>
                  <description>Scramble On/Off</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEEMPHASIS</name>
                  <description>De-emphasis On/Off</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LFPS</name>
                  <description>LFPS On/Off</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXONESZEROS</name>
                  <description>Enable TXONESZEROS (PIPE PHY Transmit Signal)</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_COMPLIANCE_PATTERN_5</name>
              <description>Compliance Pattern CP5</description>
              <addressOffset>0x154</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x5FC</resetValue>
              <resetMask>0x1FFF</resetMask>
              <fields>
                <field>
                  <name>CP</name>
                  <description>Compliance Pattern</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>K_D</name>
                  <description>Symbol Type - 0: Data (D), 1: Symbol (K)</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SCRAMBLED</name>
                  <description>Scramble On/Off</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEEMPHASIS</name>
                  <description>De-emphasis On/Off</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LFPS</name>
                  <description>LFPS On/Off</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXONESZEROS</name>
                  <description>Enable TXONESZEROS (PIPE PHY Transmit Signal)</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_COMPLIANCE_PATTERN_6</name>
              <description>Compliance Pattern CP6</description>
              <addressOffset>0x158</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1FC</resetValue>
              <resetMask>0x1FFF</resetMask>
              <fields>
                <field>
                  <name>CP</name>
                  <description>Compliance Pattern</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>K_D</name>
                  <description>Symbol Type - 0: Data (D), 1: Symbol (K)</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SCRAMBLED</name>
                  <description>Scramble On/Off</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEEMPHASIS</name>
                  <description>De-emphasis On/Off</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LFPS</name>
                  <description>LFPS On/Off</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXONESZEROS</name>
                  <description>Enable TXONESZEROS (PIPE PHY Transmit Signal)</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_COMPLIANCE_PATTERN_7</name>
              <description>Compliance Pattern CP7</description>
              <addressOffset>0x15C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1400</resetValue>
              <resetMask>0x1FFF</resetMask>
              <fields>
                <field>
                  <name>CP</name>
                  <description>Compliance Pattern</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>K_D</name>
                  <description>Symbol Type - 0: Data (D), 1: Symbol (K)</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SCRAMBLED</name>
                  <description>Scramble On/Off</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEEMPHASIS</name>
                  <description>De-emphasis On/Off</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LFPS</name>
                  <description>LFPS On/Off</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXONESZEROS</name>
                  <description>Enable TXONESZEROS (PIPE PHY Transmit Signal)</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_COMPLIANCE_PATTERN_8</name>
              <description>Compliance Pattern CP8</description>
              <addressOffset>0x160</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1800</resetValue>
              <resetMask>0x1FFF</resetMask>
              <fields>
                <field>
                  <name>CP</name>
                  <description>Compliance Pattern</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>K_D</name>
                  <description>Symbol Type - 0: Data (D), 1: Symbol (K)</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SCRAMBLED</name>
                  <description>Scramble On/Off</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEEMPHASIS</name>
                  <description>De-emphasis On/Off</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LFPS</name>
                  <description>ECO fix to AUTO_U3
When host requests transition to U3, automatically accept (send LAU) or rejects (send LXU) depending on pending activity. The interrupt RX_U3 is still raised for firmware to monitor, take additional power saving actions.</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXONESZEROS</name>
                  <description>Enable TXONESZEROS (PIPE PHY Transmit Signal)</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_DEBUG_BUFFER_CTRL</name>
              <description>Buffer direct access control</description>
              <addressOffset>0x164</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>MEM_PTR</name>
                  <description>0: Retry buffer locations 0x00-0xFF
1: Retry buffer locations 0x100-0x1FF
2: Retry buffer locations 0x200-0x2FF
3: Retry buffer locations 0x300-0x3FF
4: Debug features 0x00-0xFF</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_DATARATE_CHG_OBSERVE</name>
              <description>Dtat Rate Observability</description>
              <addressOffset>0x168</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1F</resetMask>
              <fields>
                <field>
                  <name>DATA_RATE_CHG_DET</name>
                  <description>Data rate change event detected : Note that the values will be only updated at the moment of data rate changed.
No further update if data rate has been changed.
0: PHY initialized in Gen2 (10G)
1: PHY initialized in Gen1 (5G )
2: G2-&gt;G1 switch due Polling.LFPS -&gt;Polling.RxEq
3: G2-&gt;G1 switch due to Polling.LFPSPlus -&gt;Polling.RxEq
4: G2-&gt;G1 switch due to receiving 5G-PHY capabiltiy LBPMs from partner in Polling.PortMatch state
5: G2-&gt;G1 switch due to Gen2-12ms timeout in Polling.Active 
(Polling.Active -&gt;Polling.PortMatch -&gt;Polling.PortConfig -&gt;Polling.RxEq)
6: G2-&gt;G1 switch due to Gen2-12ms timeout in Polling.Configuration 
(Polling.Configuration -&gt;Polling.PortMatch -&gt;Polling.PortConfig -&gt;Polling.RxEq)
7: G2-&gt;G1 switch due to Gen2-2ms timeout in Polling.Idle 
(Polling.Idle -&gt;Polling.PortMatch -&gt;Polling.PortConfig -&gt;Polling.RxEq)
8: G1G2 swithching in Compliance (CP pattern swithces to Gen2)
9: G2G1 swithching in Compliance (CP pattern swithces to Gen1)
10: G1G2 swithching in Compliance  due to receiving warm reset when the Gen2 link is transmitting Gen1 patterns
15:G1X2-&gt;G1X1/G2X2-&gt;G2X1</description>
                  <bitRange>[4:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_POLLING_BURST_GEN2</name>
              <description>LFPS Polling Transmit Gen2 Configuration</description>
              <addressOffset>0x16C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x139</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST16</name>
                  <description>Clock periods for LFPS Burst, when LFPS signalling is transmitted  (default:  ~1.0us)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_POLLING_REPEAT_GEN2</name>
              <description>LFPS Polling Transmit Gen2 Configuration</description>
              <addressOffset>0x170</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xC35</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>REPEAT16</name>
                  <description>Clock periods for LFPS Repeat, the time between LFPS Bursts  (default:  10.0 us)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_PING_BURST_GEN2</name>
              <description>LFPS Ping Transmit Gen2 Configuration</description>
              <addressOffset>0x174</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x20</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST16</name>
                  <description>Clock periods for Ping.LFPS Burst signalling transmission  (default:  ~100 ns)
SSP: range of (40ns, 160ns)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_PING_REPEAT_GEN2</name>
              <description>LFPS Ping Transmit Gen2 Configuration</description>
              <addressOffset>0x178</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x3B9ACA0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>REPEAT32</name>
                  <description>Clock periods for LFPS Repeat (default: 200 ms)</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_U1_EXIT_GEN2</name>
              <description>LFPS U1_EXIT Transmit Gen2 Configuration</description>
              <addressOffset>0x17C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x11B</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST24</name>
                  <description>Number of clock periods for LFPS Burst transmission  (default:  905.6 ns)
It is in the range of (900ns,2ms).</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_U2_EXIT_GEN2</name>
              <description>LFPS U2_EXIT Transmit Gen2 Configuration</description>
              <addressOffset>0x180</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x61A8</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST24</name>
                  <description>Minimum number of clock periods for LFPS Burst transmission  (default:  80 us)</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_U3_EXIT_GEN2</name>
              <description>LFPS U3 Exit Transmit Gen2 Configuration</description>
              <addressOffset>0x184</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x61A8</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST24</name>
                  <description>Minimum number of clock periods for LFPS Burst transmission (default: 80 us)</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_POLLING_BURST_GEN2</name>
              <description>LFPS Polling Detect Gen2 Configuration</description>
              <addressOffset>0x188</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1B500BC</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST_MIN</name>
                  <description>Minimum number of clock periods for detection of Polling.LFPS Burst  (default:  ~0.6 us)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BURST_MAX</name>
                  <description>Maximum number of clock periods for detection of Polling.LFPS Burst  (default:  ~1.4 us)</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_POLLING_REPEAT_GEN2</name>
              <description>LFPS Polling Detect Gen2 Configuration</description>
              <addressOffset>0x18C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x11170753</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>REPEAT_MIN</name>
                  <description>Minimum number of clock periods of idle (non-LFPS) time between LFPS Bursts for detection of Polling.LFPS signalling  (default:  6 us)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REPEAT_MAX</name>
                  <description>Maximum number of clock periods of idle (non-LFPS) time between LFPS Bursts for detection of Polling.LFPS signalling  (default:  14 us)</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_PING_GEN2</name>
              <description>LFPS Ping Detect Gen2 Configuration</description>
              <addressOffset>0x190</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x32000D</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST_MIN</name>
                  <description>Minimum number of clock periods for detection of Ping.LFPS Burst  (default: ~40 ns)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BURST_MAX</name>
                  <description>Maximum number of clock periods for detection of Ping.LFPS Burst  (default:  160 ns)</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_RESET_GEN2</name>
              <description>LFPS Reset Detect Gen2 Configuration</description>
              <addressOffset>0x194</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x17D7840</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST32</name>
                  <description>Minimum number of clock periods for detection
(default: 80 ms)</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_U1_EXIT_GEN2</name>
              <description>LFPS U1 Exit Detect Gen2 Configuration</description>
              <addressOffset>0x198</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x5E</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST24</name>
                  <description>Minimum number of clock periods for U1 Exit Burst detection  
A port is still required to detect U1 LFPS exit signal at a minimum of 300ns. The extra 300ns is provided as the guard band for successful U1 LFPS exit handshake.
(default: 300 ns)
Note: There is an uncertainty of the exact duration (+/- one clock cycle period) due to synchronization latency.  The suggested value to be programmed should avoid from the boundary.</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_U2_EXIT_GEN2</name>
              <description>LFPS U2 Exit Detect Gen2 Configuration</description>
              <addressOffset>0x19C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x61A8</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST24</name>
                  <description>Minimum number of clock periods for U2 Exit Burst detection  (default:  80 us)
Note: There is an uncertainty of the exact duration (+/- one clock cycle period) due to synchronization latency.  The suggested value to be programmed should avoid from the boundary.</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_U1_HANDSHAKE_GEN2</name>
              <description>LFPS U1 Exit Handshake Gen2 Configuration</description>
              <addressOffset>0x1A0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x5E</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST24</name>
                  <description>Minimum number of clock periods for LFPS handshake detection (default: 301 ns)
Note: There is an uncertainty of the exact duration (+/- one clock cycle period) due to synchronization latency.  The suggested value to be programmed should avoid from the boundary.</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_U2_HANDSHAKE_GEN2</name>
              <description>LFPS U2 Exit Handshake Gen 2 Configuration</description>
              <addressOffset>0x1A4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x61A8</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST24</name>
                  <description>Minimum number of clock periods for LFPS handshake detection (default: 80 us)
Note: There is an uncertainty of the exact duration (+/- one clock cycle period) due to synchronization latency.  The suggested value to be programmed should avoid from the boundary.</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_U3_HANDSHAKE_GEN2</name>
              <description>LFPS U3 Exit Handshake Gen 2 Configuration</description>
              <addressOffset>0x1A8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x61A8</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST24</name>
                  <description>Minimum number of clock periods for LFPS handshake detection (default: 80 us)
Note: There is an uncertainty of the exact duration (+/- one clock cycle period) due to synchronization latency.  The suggested value to be programmed should avoid from the boundary.</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_LOOPBACK_EXIT_GEN2</name>
              <description>LFPS Loopback Exit Detect Gen2 Configuration</description>
              <addressOffset>0x1AC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x61A8</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST24</name>
                  <description>Minimum number of clock periods for detection
(default: 80us)
Note: There is an uncertainty of the exact duration (+/- one clock cycle period) due to synchronization latency.  The suggested value to be programmed should avoid from the boundary.</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_LOOPBACK_HANDSHAKE_GEN2</name>
              <description>LFPS Loopback Exit Handshake Gen2 Configuration</description>
              <addressOffset>0x1B0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x61A8</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST24</name>
                  <description>Minimum number of clock periods for LFPS handshake detection (default: 80 us)
Note: There is an uncertainty of the exact duration (+/- one clock cycle period) due to synchronization latency.  The suggested value to be programmed should avoid from the boundary.</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_PENDING_HP_TIMEOUT_GEN2</name>
              <description>Header Packet LGOOD/LBAD Gen2 Timeout</description>
              <addressOffset>0x1B4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xC35</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT16</name>
                  <description>PENDING_HP_TIMER Timeout (default: 10 us) 
(0= Timer Disabled)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_CREDIT_HP_TIMEOUT_GEN2</name>
              <description>Header Packet LCRD_x Gen2 Timeout</description>
              <addressOffset>0x1C4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x17D784</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT</name>
                  <description>CREDIT_HP_TIMER Timeout (default: 5 ms)   
(0= Timer Disabled)</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_PM_LC_X2_TIMEOUT_GEN1</name>
              <description>Power Mode PM_LC_X2_TIMER Gen1 Timeout</description>
              <addressOffset>0x1C8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x3E8</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT16</name>
                  <description>PM_LC_TIMER Timeout (default: 8 us)  
(0= Timer Disabled)
It is used by initiating port.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_PM_LC_X1_TIMEOUT_GEN2</name>
              <description>Power Mode PM_LC_X1_TIMER Gen2 Timeout</description>
              <addressOffset>0x1CC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x4E2</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT16</name>
                  <description>PM_LC_TIMER Timeout (default: 4 us)  
(0= Timer Disabled)
It is used by initiating port.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_PM_LC_X2_TIMEOUT_GEN2</name>
              <description>Power Mode PM_LC_X2_TIMER Gen2 Timeout</description>
              <addressOffset>0x1D0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x9C4</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT16</name>
                  <description>PM_LC_TIMER Timeout (default: 8 us)  
(0= Timer Disabled)
It is used by initiating port.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_PM_ENTRY_X2_TIMEOUT_GEN1</name>
              <description>Power Mode PM_ENTRY_X2_TIMER Gen1 Timeout</description>
              <addressOffset>0x1D4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x7D0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT16</name>
                  <description>PM_ENTRY_TIMER Timeout (default: 16 us)  
(0= Timer Disabled)
It is used by the port receiving the request to enter the low power state.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_PM_ENTRY_X1_TIMEOUT_GEN2</name>
              <description>Power Mode PM_ENTRY_X1_TIMER Gen2 Timeout</description>
              <addressOffset>0x1D8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x9C4</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT16</name>
                  <description>PM_ENTRY_TIMER Timeout (default: 8 us)  
(0= Timer Disabled)
It is used by the port receiving the request to enter the low power state.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_PM_ENTRY_X2_TIMEOUT_GEN2</name>
              <description>Power Mode PM_ENTRY_X2_TIMER Gen2 Timeout</description>
              <addressOffset>0x1DC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1388</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT16</name>
                  <description>PM_ENTRY_TIMER Timeout (default: 16 us)  
(0= Timer Disabled)
It is used by the port receiving the request to enter the low power state.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_PM_UX_EXIT_TIMEOUT_GEN2</name>
              <description>Power Mode Ux_EXIT_TIMER Gen2 Timeout</description>
              <addressOffset>0x1E0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1C9C38</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT</name>
                  <description>Ux_EXIT_TIMER Timeout (default: 6 ms)   
(0= Timer Disabled)
It is used by the resume initiator.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_U1_MIN_RESIDENCY_TIMEOUT_GEN1</name>
              <description>Power Mode U1_MIN_RESIDENCY_TIMER Gen1 Timeout</description>
              <addressOffset>0x1E4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x177</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT16</name>
                  <description>U1_MIN_RESIDENCY_TIMER Timeout (default: 3 us)   
(0= Timer Disabled)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_U1_MIN_RESIDENCY_TIMEOUT_GEN2</name>
              <description>Power Mode U1_MIN_RESIDENCY_TIMER Gen2 Timeout</description>
              <addressOffset>0x1E8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x3AA</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT16</name>
                  <description>U1_MIN_RESIDENCY_TIMER Timeout (default: 3 us)   
(0= Timer Disabled)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_SCD_LOGIC0_REPEAT_GEN1</name>
              <description>LFPS SCD Transmit Logic 0 Gen1 Configuration</description>
              <addressOffset>0x1EC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x3AA</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>REPEAT16</name>
                  <description>tRepeat duration of SCD Logic-0 LFPS transmission in 8 ns  
(default 7.5 us)  tBURST+ElecIdle = 6 us - 9 us</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_SCD_LOGIC1_REPEAT_GEN1</name>
              <description>LFPS SCD Transmit Logic 1 Gen1 Configuration</description>
              <addressOffset>0x1F0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x61B</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>REPEAT16</name>
                  <description>tRepeat duration of SCD Logic-0 LFPS transmission in 8 ns  
(default 12.5 us)  tBURST+ElecIdle = 11 us - 14 us</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_SCD_END_REPEAT_GEN1</name>
              <description>LFPS SCD Transmit End Gen1 Configuration</description>
              <addressOffset>0x1F4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xEA6</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>REPEAT16</name>
                  <description>tRepeat duration of SCD Logic-0 LFPS transmission in 8 ns  
(default 30 us)  tBURST (0.6us ~1.4us) + ElecIdle (&gt;28 us)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_SCD_LOGIC0_REPEAT_GEN1</name>
              <description>LFPS SCD Receive Logic 0 Gen1 Gen1 Configuration</description>
              <addressOffset>0x1F8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x46502EE</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>REPEAT_MIN</name>
                  <description>Minimum number of clock periods for detection of Polling.LFPS based SCD Logic 0  (default:  6 us)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REPEAT_MAX</name>
                  <description>Maximum number of clock periods for detection of Polling.LFPS based SCD Logic 0 (default:  9 us)</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_SCD_LOGIC1_REPEAT_GEN1</name>
              <description>LFPS SCD Receive Logic 1 Gen1 Configuration</description>
              <addressOffset>0x1FC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x6D6055F</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>REPEAT_MIN</name>
                  <description>Minimum number of clock periods for detection of Polling.LFPS based SCD Logic 1  (default:  11 us)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REPEAT_MAX</name>
                  <description>Maximum number of clock periods for detection of Polling.LFPS based SCD Logic 1 (default:  14 us)</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_SCD_END_REPEAT_GEN1</name>
              <description>LFPS SCD Receive End Gen1 Configuration</description>
              <addressOffset>0x200</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xDF7</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>REPEAT_MIN</name>
                  <description>Minimum number of clock periods for detection of Polling.LFPS based SCD End  (default:  28.6 us)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_SCD_LOGIC0_REPEAT_GEN2</name>
              <description>LFPS SCD Transmit Logic 0 Gen2 Configuration</description>
              <addressOffset>0x204</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x930</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>REPEAT16</name>
                  <description>tRepeat duration of SCD Logic-0 LFPS transmission in 3.2 ns  
(default 7.5 us)  tBURST+ElecIdle = 6 us - 9 us</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_SCD_LOGIC1_REPEAT_GEN2</name>
              <description>LFPS SCD Transmit Logic 1 Gen2 Configuration</description>
              <addressOffset>0x208</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xF42</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>REPEAT16</name>
                  <description>tRepeat duration of SCD Logic-0 LFPS transmission in 3.2 ns  
(default 12.5 us)  tBURST+ElecIdle = 11 us - 14 us</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_SCD_END_REPEAT_GEN2</name>
              <description>LFPS SCD Transmit End Gen2 Configuration</description>
              <addressOffset>0x20C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x249F</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>REPEAT16</name>
                  <description>tRepeat duration of SCD Logic-0 LFPS transmission in 3.2ns  
(default 30 us)  tBURST (0.6us ~1.4us) + ElecIdle (&gt;28 us)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_SCD_LOGIC0_REPEAT_GEN2</name>
              <description>LFPS SCD Receive Logic 0 Gen2 Configuration</description>
              <addressOffset>0x210</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xAFC0753</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>REPEAT_MIN</name>
                  <description>Minimum number of clock periods for detection of Polling.LFPS based SCD Logic 0  (default:  6 us)
Note: There is an uncertainty of the exact duration (+/- one clock cycle period) due to synchronization latency.  The suggested value to be programmed should avoid from the boundary.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REPEAT_MAX</name>
                  <description>Maximum number of clock periods for detection of Polling.LFPS based SCD Logic 0 (default:  9 us)
Note: There is an uncertainty of the exact duration (+/- one clock cycle period) due to synchronization latency.  The suggested value to be programmed should avoid from the boundary.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_SCD_LOGIC1_REPEAT_GEN2</name>
              <description>LFPS SCD Receive Logic 1 Gen2 Configuration</description>
              <addressOffset>0x220</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x11170D6E</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>REPEAT_MIN</name>
                  <description>Minimum number of clock periods for detection of Polling.LFPS based SCD Logic 1  (default:  11 us)
Note: There is an uncertainty of the exact duration (+/- one clock cycle period) due to synchronization latency.  The suggested value to be programmed should avoid from the boundary.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REPEAT_MAX</name>
                  <description>Maximum number of clock periods for detection of Polling.LFPS based SCD Logic 1 (default:  14 us)
Note: There is an uncertainty of the exact duration (+/- one clock cycle period) due to synchronization latency.  The suggested value to be programmed should avoid from the boundary.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_SCD_END_REPEAT_GEN2</name>
              <description>LFPS SCD Receive End Gen2 Configuration</description>
              <addressOffset>0x224</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x22EA</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>REPEAT_MIN</name>
                  <description>Minimum number of clock periods for detection of Polling.LFPS based SCD End  (default:  28.6 us)
Note: There is an uncertainty of the exact duration (+/- one clock cycle period) due to synchronization latency.  The suggested value to be programmed should avoid from the boundary.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_LBPS_TPWM_GEN1</name>
              <description>LFPS LBPS Transmit tPWM Gen1 Configuration</description>
              <addressOffset>0x228</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x113</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>REPEAT16</name>
                  <description>tPWM duration of LFPS transmission in 8 ns  
(default 2.2 us)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_LBPS_TLFPS0_GEN1</name>
              <description>LFPS LBPS Transmit tLFPS-0 Gen1 Configuration</description>
              <addressOffset>0x238</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x52</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST16</name>
                  <description>tLFPS-0 duration of LFPS transmission in 8 ns  
(default 0.65 us)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_LBPS_TLFPS1_GEN1</name>
              <description>LFPS LBPS Transmit tLFPS-1 Gen1 Configuration</description>
              <addressOffset>0x23C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xC4</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST16</name>
                  <description>tLFPS-1 duration of LFPS transmission in 8 ns  
(default 1.565 us)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_LBPS_TPWM_GEN1</name>
              <description>LFPS LBPS Receive tPWM Gen1 Configuration</description>
              <addressOffset>0x240</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x12C00FA</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>REPEAT_MIN</name>
                  <description>Minimum number of clock periods for detection of tPWM of LFPS Based PWM Signaling (LBPS)  (default:  2.0 us)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REPEAT_MAX</name>
                  <description>Maximum number of clock periods for detection of tPWM of LFPS Based PWM Signaling (LBPS)  (default:  2.4 us)</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_LBPS_TLFPS0_GEN1</name>
              <description>LFPS LBPS Receive tLFPS-0 Gen1 Configuration</description>
              <addressOffset>0x244</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x6A0039</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST_MIN</name>
                  <description>Minimum number of clock periods for detection of tLFPS-0 of LFPS Based PWM Signaling (LBPS)  (default:  0.45 us)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BURST_MAX</name>
                  <description>Maximum number of clock periods for detection of tLFPS-0 of LFPS Based PWM Signaling (LBPS)  (default:  0.85 us)</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_LBPS_TLFPS1_GEN1</name>
              <description>LFPS LBPS Receive tLFPS-1 Gen1 Configuration</description>
              <addressOffset>0x248</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xE700A0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST_MIN</name>
                  <description>Minimum number of clock periods for detection of tLFPS-1 of LFPS Based PWM Signaling (LBPS)  (default:  1.28 us)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BURST_MAX</name>
                  <description>Maximum number of clock periods for detection of tLFPS-1 of LFPS Based PWM Signaling (LBPS)  (default:  1.85 us)</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_LBPS_TPWM_GEN2</name>
              <description>LFPS LBPS Transmit tPWM Gen2 Configuration</description>
              <addressOffset>0x24C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x2AF</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>REPEAT16</name>
                  <description>tPWM duration of LFPS transmission in 3.2 ns  
(default 2.2 us)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_LBPS_TLFPS0_GEN2</name>
              <description>LFPS LBPS Transmit tLFPS-0 Gen2 Configuration</description>
              <addressOffset>0x250</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xCB</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST16</name>
                  <description>tLFPS-0 duration of LFPS transmission in 3.2 ns  
(default 0.65 us)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_TX_LBPS_TLFPS1_GEN2</name>
              <description>LFPS LBPS Transmit tLFPS-1 Gen2 Configuration</description>
              <addressOffset>0x254</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1E9</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST16</name>
                  <description>tLFPS-1 duration of LFPS transmission in 3.2 ns  
(default 1.565 us)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_LBPS_TPWM_GEN2</name>
              <description>LFPS LBPS Receive tPWM Gen2 Configuration</description>
              <addressOffset>0x258</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x2EE0271</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>REPEAT_MIN</name>
                  <description>Minimum number of clock periods for detection of tPWM of LFPS Based PWM Signaling (LBPS)  (default:  2.0 us)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REPEAT_MAX</name>
                  <description>Maximum number of clock periods for detection of tPWM of LFPS Based PWM Signaling (LBPS)  (default:  2.4 us)</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_LBPS_TLFPS0_GEN2</name>
              <description>LFPS LBPS Receive tLFPS-0 Gen2 Configuration</description>
              <addressOffset>0x25C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x109008D</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST_MIN</name>
                  <description>Minimum number of clock periods for detection of tLFPS-0 of LFPS Based PWM Signaling (LBPS)  (default:  0.45 us)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BURST_MAX</name>
                  <description>Maximum number of clock periods for detection of tLFPS-0 of LFPS Based PWM Signaling (LBPS)  (default:  0.85 us)</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_RX_LBPS_TLFPS1_GEN2</name>
              <description>LFPS LBPS Receive tLFPS-1 Gen2 Configuration</description>
              <addressOffset>0x260</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x2420190</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BURST_MIN</name>
                  <description>Minimum number of clock periods for detection of tLFPS-1 of LFPS Based PWM Signaling (LBPS)  (default:  1.28 us)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BURST_MAX</name>
                  <description>Maximum number of clock periods for detection of tLFPS-1 of LFPS Based PWM Signaling (LBPS)  (default:  1.85 us)</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LFPS_SCD_PATTERN</name>
              <description>LFPS SCD Pattern Configuration</description>
              <addressOffset>0x264</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xD2</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>SCD1_PATTERN</name>
                  <description>SCD1 pattern (default: b0010) 
Only for Debug purpose and FW is not expected to modify</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SCD2_PATTERN</name>
                  <description>SCD2 pattern (default: b1101)
Only for Debug purpose and FW is not expected to modify</description>
                  <bitRange>[7:4]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_TSEQ_COUNT_GEN1</name>
              <description>TSEQ Count Gen1 Configuration</description>
              <addressOffset>0x268</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x10000</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>COUNT24</name>
                  <description>The port in Gen 1 operation shall transition to Polling.Active after 65,536 consecutive TSEQ ordered sets  
(default 65536)</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_TSEQ_COUNT_GEN2</name>
              <description>TSEQ Count Gen2 Configuration</description>
              <addressOffset>0x26C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x80000</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>COUNT24</name>
                  <description>The port in Gen 2 operation shall transition to Polling.Active after 65,536 consecutive TSEQ ordered sets  
(default 524288)</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_SCD1_GEN2_HSK</name>
              <description>SCD1 Handshake Gen2 Configuration</description>
              <addressOffset>0x270</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x2101</resetValue>
              <resetMask>0x7307</resetMask>
              <fields>
                <field>
                  <name>RX_SCDX_CNT</name>
                  <description>The port in SuperSpeedPlus operation shall transition to Polling.LFPSPlus if two SCD1 are transmitted after one SCD1 or SCD2 as defined in Section 6.9.4.2 is received.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ARX_SCDX_LIMIT</name>
                  <description>N/A</description>
                  <bitRange>[9:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TX_ARX_SCD1_CNT</name>
                  <description>N/A</description>
                  <bitRange>[14:12]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_SCD1_GEN2_TO_GEN1_HSK</name>
              <description>SCD1 Handshake Gen2_to_Gen1 Configuration</description>
              <addressOffset>0x274</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x10112410</resetValue>
              <resetMask>0x1F777F7F</resetMask>
              <fields>
                <field>
                  <name>SCDXCHK_RX_LFPS_CNT</name>
                  <description>If it has received sixteen or more consecutive Polling.LFPS bursts and the tPollingSCDLFPSTimeout timer has not expired, it shall switch to SuperSpeed operation and transmit Polling.LFPS with non-varying tRepeat after four  SCD1 are transmitted.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>G2G1_TX_SCD1_CNT</name>
                  <description>N/A</description>
                  <bitRange>[11:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>G2G1_RX_LFPS_CNT</name>
                  <description>The completion of SS Polling.LFPS with two consecutive Polling.LFPS bursts received and one SCD1 or four consecutive Polling.LFPS bursts transmitted after receiving one Polling.LFPS burst.</description>
                  <bitRange>[14:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>G2G1_ARX_LFPS_LIMIT</name>
                  <description>N/A</description>
                  <bitRange>[18:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>G2G1_TX_ARX_SCD1_CNT</name>
                  <description>N/A</description>
                  <bitRange>[22:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>G2G1_TX_LFPS_CNT</name>
                  <description>At least 16 consecutive Polling.LFPS bursts meeting the Polling.LFPS specification defined in Section 6.9 are sent.</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_SCD1_OBSERVE</name>
              <description>Polling.LFPS SCD1 Observability</description>
              <addressOffset>0x278</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xC0707077</resetMask>
              <fields>
                <field>
                  <name>RCVD_SCD2_CNT</name>
                  <description>Received SCD2 Count</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RCVD_SCD1_CNT</name>
                  <description>Received SCD1 Count</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SENT_SCD1_CNT_G2_ARX</name>
                  <description>Number of SCD1 sent after Receiving SCD1 in Gen2</description>
                  <bitRange>[14:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SENT_SCD1_CNT_G2G1_ARX</name>
                  <description>Number of SCD1 sent after Receiving SCD1 when Gen2 to Gen1</description>
                  <bitRange>[22:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>G2G1_LFPS_HSK_DONE</name>
                  <description>Gen2 to Gen1 LFPS Handshake Done since last cleared by CPU</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SCD1_HSK_DONE</name>
                  <description>SCD1 handshake Done since last cleared by CPU</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_SCD2_GEN2_HSK</name>
              <description>SCD2 Handshake Gen2 Configuration</description>
              <addressOffset>0x27C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x2101</resetValue>
              <resetMask>0x7307</resetMask>
              <fields>
                <field>
                  <name>RX_SCD2_CNT</name>
                  <description>The port in SuperSpeedPlus operation shall transition to Polling.PortMatch if two SCD2 are transmitted after one SCD2 as defined in Section 6.9.4.2 is received.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ARX_SCD2_LIMIT</name>
                  <description>N/A</description>
                  <bitRange>[9:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TX_ARX_SCD2_CNT</name>
                  <description>N/A</description>
                  <bitRange>[14:12]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_SCD2_GEN2_TO_GEN1_HSK</name>
              <description>SCD2 Handshake Gen2_to_Gen1 Configuration</description>
              <addressOffset>0x280</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x14000040</resetValue>
              <resetMask>0x1F00007F</resetMask>
              <fields>
                <field>
                  <name>SCD2CHK_RX_LFPS_CNT</name>
                  <description>The port in SuperSpeedPlus operation shall transmit SCD2 defined in Table 6-33. If SCD2 cannot be found in 64 consecutive Polling.LFPS received, it shall transmit Polling.LFPS with non-varying tRepeat instead of SCD2.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>G2G1_TX_LFPS_CNT</name>
                  <description>Twenty Polling.LFPS bursts with non-varying tRepeat are transmitted, after finding no SCD2 is detected.</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_SCD2_OBSERVE</name>
              <description>Polling.LFPSPlus SCD2 Observability</description>
              <addressOffset>0x284</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xC0000707</resetMask>
              <fields>
                <field>
                  <name>RCVD_SCD2_CNT</name>
                  <description>The port in SuperSpeedPlus operation shall transition to Polling.PortMatch if two SCD2 are transmitted after one SCD2 as defined in Section 6.9.4.2 is received.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SENT_SCD2_CNT_G2_ARX</name>
                  <description>N/A</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>G2G1_LFPS_HSK_DONE</name>
                  <description>Gen2 to Gen1 LFPS Handshake Done since last cleared by CPU</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SCD2_HSK_DONE</name>
                  <description>SCD2 handshake Done since last cleared by CPU
Note: This asserts before SCD_END  transmitting. After SCD_END transmitting completion, LTSSM moves to PORT_MATCH state.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_CAP_LBPM_HSK</name>
              <description>Polling.PortMatch LBPM Handshake Configuration</description>
              <addressOffset>0x288</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x5220</resetValue>
              <resetMask>0xF770</resetMask>
              <fields>
                <field>
                  <name>RX_CAP_LBPM_CNT</name>
                  <description>The port shall transition to Polling.PortConfig when four consecutive and matched PHY Capability LBPMs are sent after two consecutive and matched PHY Capability LBPMs or PHY Ready LBPMs are received.</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ARX_LBPM_LIMIT</name>
                  <description>N/A</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TX_ARX_CAP_LBPM_CNT</name>
                  <description>N/A</description>
                  <bitRange>[15:12]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_CAP_LBPM_OBSERVE</name>
              <description>Polling.PortMatch LBPM Observability</description>
              <addressOffset>0x28C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x80777777</resetMask>
              <fields>
                <field>
                  <name>RCVD_10GX1_CAP_LBPM_CNT</name>
                  <description>Received Capability LBPM Count
0:  No CAP LBPM received; 1: CAP LBPM received; Others: 10Gx1 decoded</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RCVD_5GX1_CAP_LBPM_CNT</name>
                  <description>Received Capability LBPM Count
0:  No CAP LBPM received; 1: CAP LBPM received; Others: 5Gx1 decoded</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RCVD_10GX2_CAP_LBPM_CNT</name>
                  <description>Received Capability LBPM Count
0:  No CAP LBPM received; 1: CAP LBPM received; Others: 10Gx2 decoded</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RCVD_5GX2_CAP_LBPM_CNT</name>
                  <description>Received Capability LBPM Count
0:  No CAP LBPM received; 1: CAP LBPM received; Others: 5Gx2 decoded</description>
                  <bitRange>[14:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RCVD_READY_LBPM_CNT</name>
                  <description>Recevied Ready LBPM Count</description>
                  <bitRange>[18:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SENT_CAP_LBPM_CNT_ARX</name>
                  <description>The number of CAP LBPM sent after Receiving CAP LBPM</description>
                  <bitRange>[22:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CAP_LBPM_HSK_DONE</name>
                  <description>Capability LBPM handshake Done since last cleared by CPU</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_READY_LBPM_HSK</name>
              <description>Polling.PortConfig LBPM Handshake Configuration</description>
              <addressOffset>0x290</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x422</resetValue>
              <resetMask>0xFF0F77</resetMask>
              <fields>
                <field>
                  <name>RX_RDY_LBPM_CNT</name>
                  <description>The port shall transition to Polling.RxEQ when four consecutive and matched PHY Capability LBPMs are sent after two consecutive and matched PHY Capability LBPMs or PHY Ready LBPMs are received.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ARX_RDY_LBPM_LIMIT</name>
                  <description>N/A</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TX_ARX_RDY_LBPM_CNT</name>
                  <description>N/A</description>
                  <bitRange>[11:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENTRY_TO_TX_DELAY</name>
                  <description>Start-up delay to transmit Ready.LBPMs once LTSSM enters the Polling.PortConfig state if PHY re-configuration required.
Note that the delay value is counted in the unit of 8 ns.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_READY_LBPM_OBSERVE</name>
              <description>Polling.PortConfig LBPM Observability</description>
              <addressOffset>0x294</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x800000F7</resetMask>
              <fields>
                <field>
                  <name>RCVD_RDY_LBPM_CNT</name>
                  <description>The port shall transition to Polling.PortConfig when four consecutive and matched PHY Capability LBPMs are sent after two consecutive and matched PHY Capability LBPMs or PHY Ready LBPMs are received.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SENT_RDY_LBPM_CNT_ARX</name>
                  <description>N/A</description>
                  <bitRange>[7:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RDY_LBPM_HSK_DONE</name>
                  <description>ReadyLBPM handshake Done since last cleared by CPU</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_RCVD_LBPM_OBSERVE</name>
              <description>Received LBPM Observability</description>
              <addressOffset>0x298</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>LBPM</name>
                  <description>Reveived LBPM</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_SCD_LFPS_TIMEOUT</name>
              <description>LTSSM SCD LFPS Timeout (SuperSpeedPlus Only)</description>
              <addressOffset>0x29C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1D4C</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT16</name>
                  <description>LTSSM Polling.LFPS/Polling.LFPSPlus Timeout (default: 60 us in 8 ns)
Note that LTSSM will goes to LFPS.RxEQ from Polling.LFPS(Plus) immediately if it is set to '0'.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_LBPM_LFPS_TIMEOUT</name>
              <description>LTSSM LBPM LFPS Timeout (SuperSpeedPlus Only)</description>
              <addressOffset>0x2A0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x16E360</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIMEOUT24</name>
                  <description>LTSSM PollingPortMatch/Polling.PortConfig Timeout (default: 12 ms in 8ns)
(0= Timer Disabled)</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_COMPLIANCE_PATTERN_9_TO_12</name>
              <description>Compliance Pattern CP9 to CP12</description>
              <addressOffset>0x2A4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x2</resetValue>
              <resetMask>0x3FFFF</resetMask>
              <fields>
                <field>
                  <name>DEEMPH_COEFF</name>
                  <description>N/A</description>
                  <bitRange>[17:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_COMPLIANCE_PATTERN_13</name>
              <description>Compliance Pattern CP13</description>
              <addressOffset>0x2A8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x2</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>DEEMPH_COEFF</name>
                  <description>Selection transmitter de-emphasis
[ 5: 0]  : C-1
[11: 6] : C0
[17:12] : C+1</description>
                  <bitRange>[17:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GEN2_TXONESZEROS</name>
                  <description>Enable TXONESZEROS</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_COMPLIANCE_PATTERN_14</name>
              <description>Compliance Pattern CP14</description>
              <addressOffset>0x2AC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x2</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>DEEMPH_COEFF</name>
                  <description>Selection transmitter de-emphasis
[ 5: 0]  : C-1
[11: 6] : C0
[17:12] : C+1</description>
                  <bitRange>[17:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GEN2_TXONESZEROS</name>
                  <description>Enable TXONESZEROS</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_COMPLIANCE_PATTERN_15</name>
              <description>Compliance Pattern CP15</description>
              <addressOffset>0x2B0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x2</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>DEEMPH_COEFF</name>
                  <description>Selection transmitter de-emphasis
[ 5: 0]  : C-1
[11: 6] : C0
[17:12] : C+1</description>
                  <bitRange>[17:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GEN2_TXONESZEROS</name>
                  <description>Enable TXONESZEROS</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_COMPLIANCE_PATTERN_16</name>
              <description>Compliance Pattern CP16</description>
              <addressOffset>0x2B4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x2</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>DEEMPH_COEFF</name>
                  <description>Selection transmitter de-emphasis
[ 5: 0]  : C-1
[11: 6] : C0
[17:12] : C+1</description>
                  <bitRange>[17:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GEN2_TXONESZEROS</name>
                  <description>Enable TXONESZEROS</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_COMPLIANCE_PATTERN_OBSERVE</name>
              <description>Compliance Pattern Observability</description>
              <addressOffset>0x2B8</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>CP_OBSERVE</name>
                  <description>Compliance Pattern Status
0 : Not Compliamce Mode
1: CP0
2: CP1
3: CP2
4: CP3
5: CP4
6: CP5
7: CP6
8: CP7
9: CP8
10: CP9
11: CP10
12: CP11
13 :CP12
14: CP13
15: CP14
16: CP15
17: CP16
18: Transition State(G1G2: waiting for clock switching)
19: Transition State(G2G1: waiting for clock switching)
20: Initial State(COMMA: reseting scrambler)</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_SOFT_ERR_CNT_CONF</name>
              <description>Soft Error Counter Configuration</description>
              <addressOffset>0x2BC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xE0000000</resetMask>
              <fields>
                <field>
                  <name>SOFT_ERR_LFR_OPT</name>
                  <description>When Error in Length Filed Replica in DPH
0 : No Increment Soft Error Count
1: Increment Soft Error Count</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SOFT_ERR_CNT_RESET</name>
                  <description>Soft Error Count Reset</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SOFT_ERR_CNT_EN</name>
                  <description>Soft Error Count Enable</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_SOFT_ERR_CNT_OBSERVE</name>
              <description>Soft Error Counter Observability</description>
              <addressOffset>0x2C0</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>SOFT_ERR_CNT_OBSERVE</name>
                  <description>Soft Error Count (for Debug Only)
This count will increment by one if any of the following errors is detected.
1. Single-bit error in the block header
2. CRC-5 or CRC-16 or CRC-32 error
3.Single symbol framing error
4. Idle Symbol error
5.Single SKP symbol error
6. Optionally for error in the length field replica of DPH</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_STATE_CHG_INTR_CONF</name>
              <description>LTSSM State Change Interrupt Configuration</description>
              <addressOffset>0x2C4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1FFEFFF</resetValue>
              <resetMask>0x7FFFFFF</resetMask>
              <fields>
                <field>
                  <name>SS_DISABLE_INTR</name>
                  <description>0: Disabled
1: Enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_DETECT_RESET_INTR</name>
                  <description>0: Disabled
1: Enabled</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_DETECT_ACTIVE_INTR</name>
                  <description>0: Disabled
1: Enabled</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_DETECT_QUIET_INTR</name>
                  <description>0: Disabled
1: Enabled</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SS_INACTIVE_QUIET_INTR</name>
                  <description>0: Disabled
1: Enabled</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SS_INACTIVE_DISCONNECT_DETECT_INTR</name>
                  <description>0: Disabled
1: Enabled</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HOTRESET_ACTIVE_INTR</name>
                  <description>0: Disabled
1: Enabled</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HOTRESET_EXIT_INTR</name>
                  <description>0: Disabled
1: Enabled</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>POLLING_LFPS_INTR</name>
                  <description>0: Disabled
1: Enabled</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>POLLING_RXEQ_INTR</name>
                  <description>0: Disabled
1: Enabled</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>POLLING_ACTIVE_INTR</name>
                  <description>0: Disabled
1: Enabled</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>POLLING_CONFIGURATION_INTR</name>
                  <description>0: Disabled
1: Enabled
Note that this bit cannot be set if Bit16 set</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>POLLING_IDLE_INTR</name>
                  <description>0: Disabled
1: Enabled</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>POLLING_LFPSPLUS_INTR</name>
                  <description>0: Disabled
1: Enabled</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>POLLING_PORT_MATCH_INTR</name>
                  <description>0: Disabled
1: Enabled</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>POLLING_PORT_CONFIG_INTR</name>
                  <description>0: Disabled
1: Enabled</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>U0_INTR</name>
                  <description>0: Disabled
1: Enabled
Note that this bit cannot be set if Bit12 or Bit25 set</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>U1_INTR</name>
                  <description>0: Disabled
1: Enabled</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>U2_INTR</name>
                  <description>0: Disabled
1: Enabled</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>U3_INTR</name>
                  <description>0: Disabled
1: Enabled</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LOOPBACK_ACTIVE_INTR</name>
                  <description>0: Disabled
1: Enabled</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LOOPBACK_EXIT_INTR</name>
                  <description>0: Disabled
1: Enabled</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>COMPLIANCE_INTR</name>
                  <description>0: Disabled
1: Enabled</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RECOVERY_ACTIVE_INTR</name>
                  <description>0: Disabled
1: Enabled</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RECOVERY_CONFIGURATION_INTR</name>
                  <description>0: Disabled
1: Enabled</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RECOVERY_IDLE_INTR</name>
                  <description>0: Disabled
1: Enabled
Note that this bit cannot be set if Bit16 set</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ILLEGAL_STATE_INTR</name>
                  <description>0: Disabled
1: Enabled</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_DEBUG_RSVD</name>
              <description>N/A</description>
              <addressOffset>0x2C8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DEBUG_SIG_SEL</name>
                  <description>Selection of Debugging Signal Set
[15:12]: to select one of the debug signal sets to debug_mux[127:96]
[11:8]: to select one of the debug signal sets to debug_mux[95:64]
[7:4]: to select one of the debug signal sets to debug_mux[63:32]
[3:0]: to select one of the debug signal sets to debug_mux[31:0]

Note that all 16 signal sets are listed in 'Debug signals' Tab</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HS_DDFT_SEL</name>
                  <description>Selection of High Speed DDFT</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HS_DDFT_NOT_EXTD</name>
                  <description>0: High speed signal will be extended
1: High speed signal will not be extended</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RSVD</name>
                  <description>N/A</description>
                  <bitRange>[30:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FORCE_RATE_CONFIG_TO_GEN1</name>
                  <description>Force the initial data rate configuration starting from gen1</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_TX_TS1_HOLDOFF_TIMEOUT</name>
              <description>Transmitting TS1 Holdoff</description>
              <addressOffset>0x2CC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TX_TS1_HOLDOFF_TIMEOUT</name>
                  <description>Holdoff period before transmit TS1 when entering Polling.Active or Recovery.Active</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_MISC_CONF</name>
              <description>Miscellaneous Configuration</description>
              <addressOffset>0x2D0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xC02F7055</resetValue>
              <resetMask>0xC0FFFFFF</resetMask>
              <fields>
                <field>
                  <name>REPLACED_SKP_SYMB</name>
                  <description>SKP symbol will be replaced by the value</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TX_TS2_CONF</name>
                  <description>Selection of the number of TS2 being transmitted during Polling.Configuration or Recovery.Configuration
00: 16 (default as specified in USB 3.2 SPEC)
01: 32
10: 64
11: 255</description>
                  <bitRange>[9:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>INVALID_LFPS_NOT_RST_TIMER_EN</name>
                  <description>0: Disabled
1: Enable the fix to disable the reset of 60 us timer if invalid LFPS detected as long as LFPS handshake done</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GEN1X2_SKP_REMOVAL_EN</name>
                  <description>Spare</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TX_DL_SET_ENABLE</name>
                  <description>0:: Disable
1: Enables the DL bit to be set based on the spec defined condition</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GEN1_GT_4CLK_SKEW_DET_EN</name>
                  <description>0:: Disable
1: Enable greater than 4 clocks skew value detection for gen1x2</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GEN2_GT_4CLK_SKEW_DET_EN</name>
                  <description>0:: Disable
1: Enable greater than 4 clocks skew value detection for gen2x2</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GEN1_SKEW_EVAL_EN</name>
                  <description>0:: Disable
1: Enable the evaluation of skew value for gen1x2</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GEN2_SKEW_EVAL_EN</name>
                  <description>0:: Disable
1: Enable the evaluation of skew value for gen2x2</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GEN2_SKP_REMOVAL_OPT</name>
                  <description>0: SKP OS will be replace by the symbol which defined in 'REPLACED_SKP_SYMB'
1: SKP OS will be removed by de-asserting rxdata_valid
(Debugging Only)</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GEN2_ALGN_FSM_RST_OPT</name>
                  <description>0: No reset
1: FSM will be reset if dummy cycle interfering detected</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PENDING_LXU_BEFORE_LGOOD_BUG_FIX_EN</name>
                  <description>0: No fix applied
1: Fix applied</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_DESKEW_CLK_GT_EN</name>
                  <description>1: The clock for the deskew block will always be on
0: The clock for the deskew will be on only during X2 and when RX_DESKEW_EN is '1'</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GEN2X2_DESKEW_ON_TS1</name>
                  <description>1: Skew detection will be performed on TS1 or TS2
0: Skew detection will be performed on TS2</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TX_IDLE_CONF</name>
                  <description>Selection of the number of IDLE being transmitted during Polling.Idle or Recovery.Idle
00: 16 (default as specified in USB 3.2 SPEC)
01: 32
10: 64
11: 252</description>
                  <bitRange>[23:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_DESKEW_RST_IF_RECOV</name>
                  <description>0: No reset
1: de-skew logic will be reset if entering Recovery
(Debugging Only)</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_DESKEW_EN</name>
                  <description>0:: Disable; It will cause de-skew logic being reset
1: Enable De-skew FIFO if X2 negociated</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_MISC_OBSERVE</name>
              <description>Miscellaneous Observability</description>
              <addressOffset>0x2D4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1F</resetMask>
              <fields>
                <field>
                  <name>LOCKED_SKEW_VAL</name>
                  <description>Locked Skew Value
0: 0 skew
1: Lane0 ahead of Lane1 by 1 Clock
2: Lane0 ahead of Lane1 by 2 Clock
3: Lane0 ahead of Lane1 by 3 Clock
4: Lane0 ahead of Lane1 by 4 Clock
5: Lane0 ahead of Lane1 by 5 Clock
6: Lane0 ahead of Lane1 by 6 Clock
7: Lane0 ahead of Lane1 by 7 Clock
8: Lane0 ahead of Lane1 by 8 Clock
9: Lane0 ahead of Lane1 by 9 Clock
10: Lane0 ahead of Lane1 by 10 Clock
11: Lane1 ahead of Lane0 by 1 Clock
12: Lane1 ahead of Lane0 by 2 Clock
13: Lane1 ahead of Lane0 by 3 Clock
14: Lane1 ahead of Lane0 by 4 Clock
15: Lane1 ahead of Lane0 by 5 Clock
16: Lane1 ahead of Lane0 by 6 Clock
17: Lane1 ahead of Lane0 by 7 Clock
18: Lane1 ahead of Lane0 by 8 Clock
19: Lane1 ahead of Lane0 by 9 Clock
20: Lane1 ahead of Lane0 by 10 Clock
others: not used</description>
                  <bitRange>[4:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_LTSSM_SUBSTATE_OBSERVE</name>
              <description>LTSSM Substate Observability</description>
              <addressOffset>0x2D8</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LTSSM_SUBSTATE_OBSERVE</name>
                  <description>4:0: compliance states
6:5: loopback states
8:7: ssinactive states
10:9: rxdetect states
14:11: polling states
16:15: hotreset states
19:17: recov states
22:20: u3 states
25:23: u2 states
29:27: u1 states
32:30: u0 states</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>21</dim>
              <dimIncrement>4</dimIncrement>
              <name>LNK_RX_TYPE1_HEADER_BUFFER[%s]</name>
              <description>Receive Type1 Packet Header Buffer</description>
              <addressOffset>0x300</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>HEADER</name>
                  <description>Rx Header Packet(SS)/Type1 Rx Header Packet(SSP)</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_RX_TYPE1_HEADER_BUFFER_STATE_0</name>
              <description>Receive Type1 Packet Header Buffer Status 0</description>
              <addressOffset>0x380</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F3F3F3F</resetMask>
              <fields>
                <field>
                  <name>SEQUENCE0</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID0</name>
                  <description>Packet Valid. Set on transmission of LGOOD_n, cleared on transmission of LCRD_x/LCRD1_x</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RCVD0</name>
                  <description>Not used. Tied to '0'</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SEQUENCE1</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[11:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID1</name>
                  <description>Packet Valid. Set on transmission of LGOOD_n, cleared on transmission of LCRD_x/LCRD1_x</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RCVD1</name>
                  <description>Not used. Tied to '0'</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SEQUENCE2</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID2</name>
                  <description>Packet Valid. Set on transmission of LGOOD_n, cleared on transmission of LCRD_x/LCRD1_x</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RCVD2</name>
                  <description>Not used. Tied to '0'</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SEQUENCE3</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[27:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID3</name>
                  <description>Packet Valid. Set on transmission of LGOOD_n, cleared on transmission of LCRD_x/LCRD1_x</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RCVD3</name>
                  <description>Not used. Tied to '0'</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_RX_TYPE1_HEADER_BUFFER_STATE_1</name>
              <description>Receive Type1 Packet Header Buffer Status 1</description>
              <addressOffset>0x384</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F3F3F</resetMask>
              <fields>
                <field>
                  <name>SEQUENCE4</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID4</name>
                  <description>Packet Valid. Set on transmission of LGOOD_n, cleared on transmission of LCRD_x/LCRD1_x</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RCVD4</name>
                  <description>Not used. Tied to '0'</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SEQUENCE5</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[11:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID5</name>
                  <description>Packet Valid. Set on transmission of LGOOD_n, cleared on transmission of LCRD_x/LCRD1_x</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RCVD5</name>
                  <description>Not used. Tied to '0'</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SEQUENCE6</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID6</name>
                  <description>Packet Valid. Set on transmission of LGOOD_n, cleared on transmission of LCRD_x/LCRD1_x</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RCVD6</name>
                  <description>Not used. Tied to '0'</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>21</dim>
              <dimIncrement>4</dimIncrement>
              <name>LNK_RX_TYPE2_HEADER_BUFFER[%s]</name>
              <description>Receive Type2 Packet Header Buffer</description>
              <addressOffset>0x400</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>HEADER</name>
                  <description>Type2 Rx Header Packet(SSP)</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_RX_TYPE2_HEADER_BUFFER_STATE_0</name>
              <description>Receive Type2 Packet Header Buffer Status 0</description>
              <addressOffset>0x480</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F3F3F3F</resetMask>
              <fields>
                <field>
                  <name>SEQUENCE0</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID0</name>
                  <description>Packet Valid. Set on transmission of LGOOD_n, cleared on transmission of LCRD2_x</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RCVD0</name>
                  <description>Not used. Tied to '0'</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SEQUENCE1</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[11:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID1</name>
                  <description>Packet Valid. Set on transmission of LGOOD_n, cleared on transmission of LCRD2_x</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RCVD1</name>
                  <description>Not used. Tied to '0'</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SEQUENCE2</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID2</name>
                  <description>Packet Valid. Set on transmission of LGOOD_n, cleared on transmission of LCRD2_x</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RCVD2</name>
                  <description>Not used. Tied to '0'</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SEQUENCE3</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[27:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID3</name>
                  <description>Packet Valid. Set on transmission of LGOOD_n, cleared on transmission of LCRD2_x</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RCVD3</name>
                  <description>Not used. Tied to '0'</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_RX_TYPE2_HEADER_BUFFER_STATE_1</name>
              <description>Receive Type2 Packet Header Buffer Status 1</description>
              <addressOffset>0x484</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F3F3F</resetMask>
              <fields>
                <field>
                  <name>SEQUENCE4</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID4</name>
                  <description>Packet Valid. Set on transmission of LGOOD_n, cleared on transmission of LCRD2_x</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RCVD4</name>
                  <description>Not used. Tied to '0'</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SEQUENCE5</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[11:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID5</name>
                  <description>Packet Valid. Set on transmission of LGOOD_n, cleared on transmission of LCRD2_x</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RCVD5</name>
                  <description>Not used. Tied to '0'</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SEQUENCE6</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID6</name>
                  <description>Packet Valid. Set on transmission of LGOOD_n, cleared on transmission of LCRD2_x</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RCVD6</name>
                  <description>Not used. Tied to '0'</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>21</dim>
              <dimIncrement>4</dimIncrement>
              <name>LNK_TX_TYPE1_HEADER_BUFFER[%s]</name>
              <description>Transmit Type1 Packet Header Buffer</description>
              <addressOffset>0x500</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>HEADER</name>
                  <description>Tx Header Packet(SS)/Type1 Rx Header Packet(SSP)</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_TX_TYPE1_HEADER_BUFFER_STATE_0</name>
              <description>Transmit Type1 Packet Header Buffer Status 0</description>
              <addressOffset>0x580</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F3F3F3F</resetMask>
              <fields>
                <field>
                  <name>SEQUENCE0</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID0</name>
                  <description>Packet Valid. Set on receipt of buffer from Protocol Layer; cleared on receipt of LGOOD_n</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SENT0</name>
                  <description>Packet Sent. Set on receipt of buffer from Protocol Layer; cleared when sent out for first time</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SEQUENCE1</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[11:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID1</name>
                  <description>Packet Valid. Set on receipt of buffer from Protocol Layer; cleared on receipt of LGOOD_n</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SENT1</name>
                  <description>Packet Sent. Set on receipt of buffer from Protocol Layer; cleared when sent out for first time</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SEQUENCE2</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID2</name>
                  <description>Packet Valid. Set on receipt of buffer from Protocol Layer; cleared on receipt of LGOOD_n</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SENT2</name>
                  <description>Packet Sent. Set on receipt of buffer from Protocol Layer; cleared when sent out for first time</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SEQUENCE3</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[27:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID3</name>
                  <description>Packet Valid. Set on receipt of buffer from Protocol Layer; cleared on receipt of LGOOD_n</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SENT3</name>
                  <description>Packet Sent. Set on receipt of buffer from Protocol Layer; cleared when sent out for first time</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_TX_TYPE1_HEADER_BUFFER_STATE_1</name>
              <description>Transmit Type1 Packet Header Buffer Status 1</description>
              <addressOffset>0x584</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xE03F3F3F</resetMask>
              <fields>
                <field>
                  <name>SEQUENCE4</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID4</name>
                  <description>Packet Valid. Set on receipt of buffer from Protocol Layer; cleared on receipt of LGOOD_n</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SENT4</name>
                  <description>Packet Sent. Set on receipt of buffer from Protocol Layer; cleared when sent out for first time</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SEQUENCE5</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[11:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID5</name>
                  <description>Packet Valid. Set on receipt of buffer from Protocol Layer; cleared on receipt of LGOOD_n</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SENT5</name>
                  <description>Packet Sent. Set on receipt of buffer from Protocol Layer; cleared when sent out for first time</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SEQUENCE6</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID6</name>
                  <description>Packet Valid. Set on receipt of buffer from Protocol Layer; cleared on receipt of LGOOD_n</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SENT6</name>
                  <description>Packet Sent. Set on receipt of buffer from Protocol Layer; cleared when sent out for first time</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>REMOTE_CREDITS</name>
                  <description>Remote Rx (Type1) Header Buffer Credit Count. The number of free entries in the Link Partner's Receive Header Packet Buffer.</description>
                  <bitRange>[31:29]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>21</dim>
              <dimIncrement>4</dimIncrement>
              <name>LNK_TX_TYPE2_HEADER_BUFFER[%s]</name>
              <description>Transmit Type2 Packet Header Buffer</description>
              <addressOffset>0x600</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>HEADER</name>
                  <description>Type2 Rx Header Packet(SSP)</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_TX_TYPE2_HEADER_BUFFER_STATE_0</name>
              <description>Transmit Type2 Packet Header Buffer Status 0</description>
              <addressOffset>0x680</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F3F3F3F</resetMask>
              <fields>
                <field>
                  <name>SEQUENCE0</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID0</name>
                  <description>Packet Valid. Set on receipt of buffer from Protocol Layer; cleared on receipt of LGOOD_n</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SENT0</name>
                  <description>Packet Sent. Set on receipt of buffer from Protocol Layer; cleared when sent out for first time</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SEQUENCE1</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[11:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID1</name>
                  <description>Packet Valid. Set on receipt of buffer from Protocol Layer; cleared on receipt of LGOOD_n</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SENT1</name>
                  <description>Packet Sent. Set on receipt of buffer from Protocol Layer; cleared when sent out for first time</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SEQUENCE2</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID2</name>
                  <description>Packet Valid. Set on receipt of buffer from Protocol Layer; cleared on receipt of LGOOD_n</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SENT2</name>
                  <description>Packet Sent. Set on receipt of buffer from Protocol Layer; cleared when sent out for first time</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SEQUENCE3</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[27:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID3</name>
                  <description>Packet Valid. Set on receipt of buffer from Protocol Layer; cleared on receipt of LGOOD_n</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SENT3</name>
                  <description>Packet Sent. Set on receipt of buffer from Protocol Layer; cleared when sent out for first time</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LNK_TX_TYPE2_HEADER_BUFFER_STATE_1</name>
              <description>Transmit Type2 Packet Header Buffer Status 1</description>
              <addressOffset>0x684</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xE03F3F3F</resetMask>
              <fields>
                <field>
                  <name>SEQUENCE4</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID4</name>
                  <description>Packet Valid. Set on receipt of buffer from Protocol Layer; cleared on receipt of LGOOD_n</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SENT4</name>
                  <description>Packet Sent. Set on receipt of buffer from Protocol Layer; cleared when sent out for first time</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SEQUENCE5</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[11:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID5</name>
                  <description>Packet Valid. Set on receipt of buffer from Protocol Layer; cleared on receipt of LGOOD_n</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SENT5</name>
                  <description>Packet Sent. Set on receipt of buffer from Protocol Layer; cleared when sent out for first time</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SEQUENCE6</name>
                  <description>Packet Sequence Number</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VALID6</name>
                  <description>Packet Valid. Set on receipt of buffer from Protocol Layer; cleared on receipt of LGOOD_n</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SENT6</name>
                  <description>Packet Sent. Set on receipt of buffer from Protocol Layer; cleared when sent out for first time</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>REMOTE_CREDITS</name>
                  <description>Remote Rx Type2 Header Buffer Credit Count. The number of free entries in the Link Partner's Receive Header Packet Buffer.</description>
                  <bitRange>[31:29]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
          <cluster>
            <name>USB32DEV_PROT</name>
            <description>USB32 SuperSpeedPlus Device Controller Protocol Layer Registers</description>
            <addressOffset>0x00003000</addressOffset>
            <register>
              <name>PROT_CS</name>
              <description>Protocol Control and Status</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xC0E80000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DEVICEADDR</name>
                  <description>During the USB enumeration process, the host sends a device a unique 7-bit address, which the USB core copies into this register. The USB Core will automatically respond only to its assigned address.  During the USB RESET, this register will be cleared to zero.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DISABLE_INGRS_SEQ_MATCH</name>
                  <description>Disable the Ingress Sequence match detection</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DISABLE_EGRS_SEQ_MATCH</name>
                  <description>Disable the egress Sequence match detection</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DISABLE_HE_DETECTION</name>
                  <description>Disable the egress HE detection. This wont effect the PROT_INTR.HOST_ERR_EV interrupt</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SPARE_CS</name>
                  <description>SPARE</description>
                  <bitRange>[12:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EN_STATUS_CONTROL</name>
                  <description>To control the respond to the HOST-STATUS token.</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STATUS_RESPONSE</name>
                  <description>This is valid only for none Set_Address_Command. The Status phase of theSet_Address_Command is always ACKED.
0: NRDY is sent for the STATUS response
    If EN_STATUS_CONTROL is '1' and STATUS_CLR_BUSY is '1' before STATUS phase.
1: STALL is sent for the STATUS response
    If EN_STATUS_CONTROL is '1' and STATUS_CLR_BUSY is '0' before STATUS phase.</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STATUS_CLR_BUSY</name>
                  <description>This is valid only for none Set_Address_Command.
This register is used only when EN_STATUS_CONTROL is set.
This register is used for control the status phase.
This gets set by HW once a valid setup token is received.
If this bit is not cleared before status phase, A NRDY/STALL(based on STATUS_RESPONSE) is issued when a STATUS token is received.
If this bit is cleared before status phase, an ACK is issued when a STATUS token is received.
If this bit is cleared after status phase, an ERDY is issued to the HOST to continue the STATUS phase.</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SETUP_CLR_BUSY</name>
                  <description>Hardware set this bit to '1' once a valid Setup packet is detected.
The 8-byte data port of the SETUP packet is in PROT_SETUPDAT0/PROT_SETUPDAT.
This register bit used by Hardware to see if FW has finished processing the 8-bytes data.
If this regsiter is NOT cleared by FW, HW will isssue NRDY for the data-phase if any.
If this regsiter is          cleared by FW, HW will response like other End-point transaction</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NRDY_ALL</name>
                  <description>Set '1' to this bit, the HW will send NRDY all transfers from the host in all endpoint1-31.</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TP_THRESHOLD</name>
                  <description>Ingress TP response transmit buffer threshold for almost full flag.  When buffer contains TP_THRESHOLD items or more, controller will stop issuing credits to host.  This field must be larger than 0.  The transmit buffer can hold up to 64 responses.</description>
                  <bitRange>[23:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PROT_HOST_RESET_RESP</name>
                  <description>This bit is used to infom the protocol of what the response to incoming TP/DPH should be after warm/host reset. This register will be used by Protocol until the LINK_INTR.LTSSM_RESET is cleared by CPU.
0: Issue NRDY
1: Ignore TP</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SEQ_NUM_CONFIG</name>
                  <description>This bit indicates if the seq numbers are EP based or Stream ID(Socket) based
0: EP based
1: Stream ID(Socket) based</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DISABLE_IDLE_DET</name>
                  <description>This bit will control the idle detection logic in the protocol.
0: Logic is not disabled.
1: Logic is disabled.</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MULT_TIMER</name>
                  <description>This timer indicates how long protocol should wait for data (MULT is enabled) to be available by EPM before terminating a burst.
Programming this register to '0' will disable the function.
Protocol will multiply the value programmed by 32.
Max value in Gen1 will be 7936ns.
Max Value in Gen2 will be ~ 3174 ns.</description>
                  <bitRange>[31:27]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_INTR</name>
              <description>Protocol Interrupts</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1FFFFF7F</resetMask>
              <fields>
                <field>
                  <name>LMP_RCV_EV</name>
                  <description>A LMP was received and placed in PROT_LMP_PACKET_RX.  The LMP may have been recognized and processed as well (leading to other interrupts in this register).</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LMP_UNKNOWN_EV</name>
                  <description>An unkown LMP was received and placed in PROT_LMP_PACKET_RX.  The LMP was not recognized and no response LMP was sent back.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LMP_PORT_CAP_EV</name>
                  <description>A Port Capabilities LMP was received.  A response may have been sent automatically depending on settings for PROT_LMP_PORT_CAPABILITIES_TIMER.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LMP_PORT_CFG_EV</name>
                  <description>A Port Configuration LMP was received.  A response may have been sent automatically depending on settings for PROT_LMP_PORT_CONFIGURATION_TIMER.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TIMEOUT_PORT_CAP_EV</name>
                  <description>The Port Capabilities LMP Timer expired</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TIMEOUT_PORT_CFG_EV</name>
                  <description>The Port Configuraiton LMP Timer expired</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TIMEOUT_PING_EV</name>
                  <description>The Ping Timer expired</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ITP_EV</name>
                  <description>Set whenever a ITP(SOF) occurrs. Please see ITP_PTM_INTR_CONDITION.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SUTOK_EV</name>
                  <description>Set whenever a (valid of invalid) SETUP DPP is received that is not a set_address.  The set_address DPP is handled entirely in hardware and does not require any firmware intervention.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HOST_ERR_EV</name>
                  <description>Set whenever an ACK TP is received with HE=1
[USB 3.0:  section 8.5.1, Table 8-12, p 8-13]</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STATUS_STAGE</name>
                  <description>Set when host completes Status Stage of a Control Transfer</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LMP_INVALID_PORT_CAP_EV</name>
                  <description>Set whenever a LMP port capability is received but the Link Speed is not '1' or
Num HP buffer is not '4' or bit zero of the Direction is not '1'.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LMP_INVALID_PORT_CFG_EV</name>
                  <description>Set whenever a LMP port configuration is received but the Link Speed is not '1'.</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EP0_STALLED_EV</name>
                  <description>Device sets this interrupt based on the following conditions:
1: When Host sends more data than it is suppose to in ingress.
2: When Device sends more data that it suppose to in egress.
3: During STATUS Stage, host sends/asks to/for data from device.
Device will come out of stall condition when it receives a valid SETUP(SUTOK_EV 
interrupt will be generated).</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SET_ADDR0_EV</name>
                  <description>Device sets this interrupt when it receives a set address 0 command.
The Stall condition (except Stream-ID mismatch) will be disabled until this interrupt is cleared.
Based on USB3.2 Spec Section 9.4.6:
If the address specified is zero, then the device shall enter the Default state;</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDM_TX</name>
                  <description>LDM-LMP was Sent because PROT_PTM_CONFIG.LMP_SEND was set. PROT_PTM_T1.TIME is valid</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDM_DL_TX</name>
                  <description>LDM-LMP was Sent because a LDM with DL bit was received. PROT_PTM_T1.TIME is valid</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDM_RX</name>
                  <description>LDM-LMP with DL bit 0 received. PROT_PTM_T4.TIME is valid</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDM_DL_RX</name>
                  <description>LDM-LMP with DL bit 1 received. PROT_PTM_T1.TIME is invalid</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDM_RESP_TIMEOUT_1</name>
                  <description>Response timer timeout for the first LDM request</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDM_RESP_TIMEOUT_2</name>
                  <description>Response timer timeout for the second LDM request</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDM_RESP_TIMEOUT_3</name>
                  <description>Response timer timeout for the Third LDM request. The PTM is in LDM-Disabled state</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SET_ADDR</name>
                  <description>Device sets this interrupt when it receives a set address command. The value of the address can be found in PROT_CS.DEVICEADDR</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEFERRED_SET</name>
                  <description>Device sets this interrupt when it receives defer is detected</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEFERRED_CLEAR</name>
                  <description>Device sets this interrupt when it receives a packet without defer after receiving the defer earlier</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDM_STATE_CHANGE</name>
                  <description>LDM state changed interrupt based on the PROT_PTM_CONFIG.STATE_CHANGE_SEL register.</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>T1_SCH_FULL</name>
                  <description>Type1 scheduler got full</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>T2_SCH_FULL</name>
                  <description>Type2 scheduler got full</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_INTR_SET</name>
              <description>Protocol Interrupts Set</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1FFFFF7F</resetMask>
              <fields>
                <field>
                  <name>LMP_RCV_EV</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LMP_UNKNOWN_EV</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LMP_PORT_CAP_EV</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LMP_PORT_CFG_EV</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TIMEOUT_PORT_CAP_EV</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TIMEOUT_PORT_CFG_EV</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TIMEOUT_PING_EV</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ITP_EV</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SUTOK_EV</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HOST_ERR_EV</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STATUS_STAGE</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LMP_INVALID_PORT_CAP_EV</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LMP_INVALID_PORT_CFG_EV</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EP0_STALLED_EV</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SET_ADDR0_EV</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDM_TX</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDM_DL_TX</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDM_RX</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDM_DL_RX</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RESP_TIMEOUT_1</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RESP_TIMEOUT_2</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RESP_TIMEOUT_3</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SET_ADDR</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEFERRED_SET</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEFERRED_CLEAR</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDM_STATE_CHANGE</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>T1_SCH_FULL</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>T2_SCH_FULL</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_INTR_MASK</name>
              <description>Protocol Interrupts Mask</description>
              <addressOffset>0xC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1FFFFF7F</resetMask>
              <fields>
                <field>
                  <name>LMP_RCV_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LMP_UNKNOWN_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LMP_PORT_CAP_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LMP_PORT_CFG_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TIMEOUT_PORT_CAP_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TIMEOUT_PORT_CFG_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TIMEOUT_PING_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ITP_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SUTOK_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HOST_ERR_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STATUS_STAGE_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LMP_INVALID_PORT_CAP_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LMP_INVALID_PORT_CFG_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EP0_STALLED_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SET_ADDR0_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDM_TX_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDM_DL_TX_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDM_RX_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDM_DL_RX_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RESP_TIMEOUT_1_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RESP_TIMEOUT_2_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RESP_TIMEOUT_3_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SET_ADDR_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEFERRED_SET_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEFERRED_CLEAR_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDM_STATE_CHANGE_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>T1_SCH_FULL_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>T2_SCH_FULL_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_INTR_MASKED</name>
              <description>Protocol Interrupts Masked</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1FFFFF7F</resetMask>
              <fields>
                <field>
                  <name>LMP_RCV_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LMP_UNKNOWN_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LMP_PORT_CAP_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LMP_PORT_CFG_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TIMEOUT_PORT_CAP_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TIMEOUT_PORT_CFG_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TIMEOUT_PING_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ITP_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SUTOK_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>HOST_ERR_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STATUS_STAGE_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LMP_INVALID_PORT_CAP_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LMP_INVALID_PORT_CFG_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EP0_STALLED_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SET_ADDR0_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LDM_TX_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LDM_DL_TX_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LDM_RX_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LDM_DL_RX_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RESP_TIMEOUT_1_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RESP_TIMEOUT_2_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RESP_TIMEOUT_3_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SET_ADDR_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DEFERRED_SET_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DEFERRED_CLEAR_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LDM_STATE_CHANGE_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>T1_SCH_FULL_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>T2_SCH_FULL_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_EP_INTR</name>
              <description>Endpoint Interrupts</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>EP_IN</name>
                  <description>Bit &lt;x&gt; indicates an interrupt from EPI_CS[x]</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EP_OUT</name>
                  <description>Bit &lt;16+x&gt; indicates an interrupt from EPO_CS[x]</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_EP_INTR_SET</name>
              <description>Endpoint Interrupts set</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>EP_IN</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EP_OUT</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_EP_INTR_MASK</name>
              <description>Endpoint Interrupts Mask</description>
              <addressOffset>0x1C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>EP_IN_MASK</name>
                  <description>Bit &lt;x&gt; masks any interrupt from EPI_CS[x]</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EP_OUT_MASK</name>
                  <description>Bit &lt;16+x&gt; masks any interrupt from EPO_CS[x]</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_EP_INTR_MASKED</name>
              <description>Endpoint Interrupts Masked</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>EP_IN_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EP_OUT_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_DEVICE_NOTIF_FUNC_WAKE</name>
              <description>Device Notification Remote Wake up TP</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x800000FF</resetMask>
              <fields>
                <field>
                  <name>INTERFACE</name>
                  <description>Interface.  This  field  identifies  the  first  interface  in  the  function  that  caused  the device  to  perform  a  remote  wake  operation.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REQUEST</name>
                  <description>Firmware writes 1 to enable it and hardware clears this bit after device notification TP service request has been completed</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_DEVICE_NOTIF_LTM</name>
              <description>Device Notification Latency Tolerance Message TP</description>
              <addressOffset>0x28</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xC00</resetValue>
              <resetMask>0x80000FFF</resetMask>
              <fields>
                <field>
                  <name>BELT_LATENCY</name>
                  <description>BELT.  This  field  describes  the  Best  Effort  Latency  Tolerance  value, representing  the  time  in nanoseconds  that  a  device  can  wait  for  service  before  experiencing  unintended  operational  side effects. 
[9:0]: LatencyValue in nano-seconds (ns)</description>
                  <bitRange>[9:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BELT_SCALE</name>
                  <description>N/A</description>
                  <bitRange>[11:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REQUEST</name>
                  <description>Firmware writes 1 to enable it and hardware clears this bit after servicing the request</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_DEVICE_NOTIF_BIAM</name>
              <description>Device Notification Bus Interval Adjustment TP</description>
              <addressOffset>0x2C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x8000FFFF</resetMask>
              <fields>
                <field>
                  <name>BIA</name>
                  <description>Bus  Interval  Adjustment.  This  field  is  a  two's  complement  value  ranging  from  -32768  to  +32767 expressed  in  BusIntervalAdjustmentGranularity units.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REQUEST</name>
                  <description>Firmware writes 1 to enable it and hardware clears this bit after servicing the request</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_LMP_PORT_CAPABILITY_TIMER</name>
              <description>Port Capabilites LMP Timeout Configuration</description>
              <addressOffset>0x30</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x9C4</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RX_TIMEOUT</name>
                  <description>Maximum  time  after  a  successful  warm  reset  or  a power  on  reset  that  the  device should wait for port  capability LMP on its RX link. 
Default is 20us which translates to:
Gen1: (2500 cycles using 125 mhz clock)
Gen2: (2500*2.5 cyckes using 3125 mhz clock)</description>
                  <bitRange>[14:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_DISABLE</name>
                  <description>Disables the protocol layer to wait for port capabilities LMP</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TX_TIMEOUT</name>
                  <description>This for TX lane, device should send port capability within 20us of link initialization done. Firmware can load a timer and ask device to wait for that much time before sending port Capability LMP.
The value must be programmed accordinlgy with respect to Gen1(125MHz) or Gen2(312.5MHz) clock.</description>
                  <bitRange>[30:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TX_DISABLE</name>
                  <description>Disables the protocol layer to send port capabilities LMP</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_LMP_PORT_CONFIGURATION_TIMER</name>
              <description>Port Configuration LMP Timeout Configuration</description>
              <addressOffset>0x34</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x9C4</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RX_TIMEOUT</name>
                  <description>Maximum  time  after  a  successful  warm  reset  or  a power  on  reset  that  the  link  partners  should  send  the  port  configuration LMP.  
Default is 20us which translates to:
Gen1: (2500 cycles using 125 Mhz clock)
Gen2: (2500*2.5 cyckes using 3125 Mhz clock)</description>
                  <bitRange>[14:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX_DISABLE</name>
                  <description>Disables the protocol layer to wait for port configuration LMP</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TX_TIMEOUT</name>
                  <description>Maximum time device protocol layer will wait after receiving Port Configuration LMP.
The value must be programmed accordinlgy with respect to Gen1(125MHz) or Gen2(312.5MHz) clock.</description>
                  <bitRange>[30:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TX_DISABLE</name>
                  <description>Disables the protocol layer to send Port configuration response LMP</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_PING_TIMEOUT</name>
              <description>Ping Timeout Configuration</description>
              <addressOffset>0x38</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x7A12</resetValue>
              <resetMask>0x80FFFFFF</resetMask>
              <fields>
                <field>
                  <name>PING_TIMEOUT</name>
                  <description>Timeout  after  a  device  receives  a  ping  from  the host  and  when  it  can  initiate  U1  or  U2.   This parameter  is  measured  in  terms  of  the  maximum 
of  all  the  service  intervals  for  all  isochronous endpoints  within  the  device. Default is 2 service intervals (1 service interval = 1 bus interval in this case)
Default is 250 us which translates to:
Gen1: (31250 cycles using 125 Mhz clock)
Gen2: (31250*2.5 cycles using 312.5 Mhz clock)</description>
                  <bitRange>[23:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PING_DISABLE</name>
                  <description>Directs the protocol layer to disable ping timer</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_FRAMECNT</name>
              <description>Frame Counter Register</description>
              <addressOffset>0x44</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFFFF</resetMask>
              <fields>
                <field>
                  <name>SS_MICROFRAME</name>
                  <description>MICROFRAME counter which indicates which of the 8 125-microsecond micro-frames last occurred... This is based on ITPs recieved from Host</description>
                  <bitRange>[13:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DELTA</name>
                  <description>The delta value in the last ITP received</description>
                  <bitRange>[26:14]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_ITP_CORRECTION</name>
              <description>Correction field of ITP.</description>
              <addressOffset>0x48</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFF</resetMask>
              <fields>
                <field>
                  <name>CORRECTION</name>
                  <description>The correction field in the last ITP received</description>
                  <bitRange>[13:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_SETUPDAT0</name>
              <description>Received SETUP Packet Data</description>
              <addressOffset>0x54</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>SETUP_REQUEST_TYPE</name>
                  <description>Setup data field</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SETUP_REQUEST</name>
                  <description>Setup data field</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SETUP_VALUE</name>
                  <description>Setup data field</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_SETUPDAT1</name>
              <description>Received SETUP Packet Data</description>
              <addressOffset>0x58</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>SETUP_INDEX</name>
                  <description>Setup data field</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SETUP_LENGTH</name>
                  <description>Setup data field</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_SEQ_NUM</name>
              <description>Sequence Number</description>
              <addressOffset>0x5C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFF3FFF</resetMask>
              <fields>
                <field>
                  <name>INGRESS_EP_NUM</name>
                  <description>Ingresss Endpoint Number for the Read/Write operation.
See the description for INGRESS_WRITE_SEQ_NUM.</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>INGRESS_READ_SEQ_NUM</name>
                  <description>The ingress sequence number based on the INGRESS_EP_NUM.
This register reflects the current seq_num when FW reads the reigster.</description>
                  <bitRange>[8:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>INGRESS_WRITE_SEQ_NUM</name>
                  <description>To update this field, two writes must be performed.
Steps:
1: Write the INGRESS_EP_NUM &amp; the new value of the sequence number + 1
2: Write the  new value of the sequence number
After ~4 system clocks the INGRESS_READ_SEQ_NUM will have the updated result if INGRESS_EP_NUM is not changed.</description>
                  <bitRange>[13:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EGRESS_EP_NUM</name>
                  <description>Egresss Endpoint Number for the Read/Write operation.
See the description for EGRESS_WRITE_SEQ_NUM.</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EGRESS_READ_SEQ_NUM</name>
                  <description>The egress sequence number based on the EGRESS_EP_NUM.
This register reflects the current seq_num when FW reads the reigster.</description>
                  <bitRange>[24:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EGRESS_WRITE_SEQ_NUM</name>
                  <description>To update this field, two writes must be performed.
Steps:
1: Write the EGRESS_EP_NUM &amp; the new value of the sequence number + 1
2: Write the  new value of the sequence number
After ~4 system clocks the EGRESS_READ_SEQ_NUM will have the updated result if EGRESS_EP_NUM is not changed.</description>
                  <bitRange>[29:25]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_LMP_RECEIVED</name>
              <description>Link Management Packet Received Value</description>
              <addressOffset>0x80</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1FF</resetMask>
              <fields>
                <field>
                  <name>U2_INACTIVITY_TIMEOUT</name>
                  <description>U2 Inactivity Timeout Value</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FORCE_LINKPM_ACCEPT</name>
                  <description>Force Link to accept LGO_Ux Link Commands</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_LMP_OVERRIDE</name>
              <description>Link Management Packet Override Values</description>
              <addressOffset>0x84</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xE00001FF</resetMask>
              <fields>
                <field>
                  <name>U2_INACTIVITY_TIMEOUT</name>
                  <description>U2 Inactivity Timeout Value when INACITIVITY_TIMEOUT_OVR is set</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FORCE_LINKPM_ACCEPT</name>
                  <description>Force Link to accept LGO_Ux Link Commands when LINKPM_ACCEPT_OVR is set</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>INACITIVITY_TIMEOUT_OVR</name>
                  <description>Enable U2 Inactivity Timeout Setting Override</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LINKPM_ACCEPT_OVR</name>
                  <description>Enable Force_LINKPM_Accept Setting Override</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LMP_SEND</name>
                  <description>Initiates sending a custom LMP packet where the content of the whole packet is the PROT_LMP_PACKET_TX register.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_LMP_PORT_CAPABILITIES_RX</name>
              <description>Port Capabilities LMP Received</description>
              <addressOffset>0x88</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1FFFFF</resetMask>
              <fields>
                <field>
                  <name>LINK_SPEED</name>
                  <description>The Link Speed supported by device</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>NUM_HP_BUFFERS</name>
                  <description>This field specifies the number of header  packet  buffers  
(in each direction Transmit or Receive)  this  device  supports.</description>
                  <bitRange>[14:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DIRECTION</name>
                  <description>This field is used to identify the upstream or downstream capabilities of the port</description>
                  <bitRange>[16:15]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TIEBREAKER</name>
                  <description>This  field  is  used  to  determine  the  port  type  when  two  devices  with  both  upstream  and  downstream capability are connected to each other</description>
                  <bitRange>[20:17]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_LMP_PORT_CAPABILITIES_TX</name>
              <description>Port Capabilities LMP Transmitted</description>
              <addressOffset>0x8C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x10201</resetValue>
              <resetMask>0x801FFFFF</resetMask>
              <fields>
                <field>
                  <name>LINK_SPEED</name>
                  <description>Only used for Gen1x1. HW will use this only for Gen1x1 for others HW send a value '0'.
The Link Speed supported by device</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NUM_HP_BUFFERS</name>
                  <description>Only used for Gen1x1. HW will use this only for Gen1x1 for others HW send a value '0'.
This field specifies the number of header  packet  buffers  
(in each direction Transmit or Receive)  this  device  supports.</description>
                  <bitRange>[14:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DIRECTION</name>
                  <description>This field is used to identify the upstream or downstream capabilities of the port</description>
                  <bitRange>[16:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TIEBREAKER</name>
                  <description>This  field  is  used  to  determine  the  port  type  when  two  devices  with  both  upstream  and  downstream capability are connected to each other</description>
                  <bitRange>[20:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LMP_SEND</name>
                  <description>Initiates sending of the Port Configuration Response LMP</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_LMP_PORT_CONFIGURATION_RX</name>
              <description>Port Configuration LMP Received</description>
              <addressOffset>0x90</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F</resetMask>
              <fields>
                <field>
                  <name>LINK_SPEED</name>
                  <description>This  field  describes  the  link  speed  at  which  the  upstream  port  shall  operate.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_LMP_PORT_CONFIGURATION_TX</name>
              <description>Port Configuration Response LMP</description>
              <addressOffset>0x94</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1</resetValue>
              <resetMask>0x8000007F</resetMask>
              <fields>
                <field>
                  <name>LINK_SPEED</name>
                  <description>This  field  indicates  the  settings  that  were  accepted  in  the  Port  Configuration LMP  that  was  sent  to  a  device.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LMP_SEND</name>
                  <description>Initiates sending of the Port Configuration Response LMP</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_STREAM_ERROR_DISABLE</name>
              <description>Streams Error Disable Type Registers</description>
              <addressOffset>0x98</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>TYPE</name>
                  <description>N/A</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_STREAM_ERROR_STATUS</name>
              <description>Streams Error STATUS Registers</description>
              <addressOffset>0x9C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xBFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ID</name>
                  <description>The stream id when the error occurred.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EP_NUM</name>
                  <description>The End Point number when the error occurred.</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EP_IO</name>
                  <description>1: IN EP, 0: OUT EP</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ERROR_TYPE</name>
                  <description>N/A</description>
                  <bitRange>[26:21]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ERROR_STATE</name>
                  <description>The stream state when the error occurred.
1: Disabled
2: Prime Pipe
3: DFR Prime Pipe
4: Idle
5: Start Stream
6: Move Data
7: End</description>
                  <bitRange>[29:27]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ERROR_DETECTED</name>
                  <description>An Stream Error was detected.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>3</dim>
              <dimIncrement>4</dimIncrement>
              <name>PROT_LMP_PACKET_RX[%s]</name>
              <description>Link Management Packet Received</description>
              <addressOffset>0x100</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RX_LMP_PACKET</name>
                  <description>Link Management Packet</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>3</dim>
              <dimIncrement>4</dimIncrement>
              <name>PROT_LMP_PACKET_TX[%s]</name>
              <description>Link Management Packet to be sent</description>
              <addressOffset>0x110</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TX_LMP_PACKET</name>
                  <description>Link Management Packet</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>16</dim>
              <dimIncrement>4</dimIncrement>
              <name>PROT_EPI_INTR[%s]</name>
              <description>Per IN-Endpoint Interrupt</description>
              <addressOffset>0x140</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x70777</resetMask>
              <fields>
                <field>
                  <name>COMMIT</name>
                  <description>Set whenever an IN token was ACKed by the host.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RETRY</name>
                  <description>Whenever the USB3.0 does a retry it will asserts this interrupt.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FLOWCONTROL</name>
                  <description>This bit will be set when entering flow control state due to data not being available (NRDY) Or End of Burst is detected.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ZERO</name>
                  <description>Indicates a zero length packet was returned to the host in an IN transaction.  Must be cleared by s/w.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SHORT</name>
                  <description>Indicates a shorter-than-maxsize packet was received, but EPI_XFER_CNT did not reach 0).</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OOSERR</name>
                  <description>Out Of Sequence Error. Anytime an ACK is received with unexpected sequence number request, the ACK will be dropped and intr will be raised</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DBTERM</name>
                  <description>The Burst was terminated by the device when the MULT_TIMER expires.
While the mult-timer is running or when mult expires if Host asks for more packets, controller will send NRDY.
After this interrupt is triggered, If socket has packet FW should clear this register to enable the traffic for the EP.
If socket has no data, FW should Stall the EP.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STREAM_ERROR</name>
                  <description>Stream Error occurred. See PROT_STREAM_ERROR_DISABLE</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIRST_ACK_NUMP_0</name>
                  <description>The NumP for the first ACK is zero.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STREAM_ST_CHG</name>
                  <description>Stream state changed. Read PROT_EPI_UNMAPPED_STREAM.SPSM_STATE</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FLOWCONTROL_EXIT</name>
                  <description>This bit will be set when exiting flow control state when transmitting ERDY due to data is being available</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SPARE_REG</name>
                  <description>Spare</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>16</dim>
              <dimIncrement>4</dimIncrement>
              <name>PROT_EPI_INTR_SET[%s]</name>
              <description>Per IN-Endpoint Interrupt set</description>
              <addressOffset>0x180</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x70777</resetMask>
              <fields>
                <field>
                  <name>COMMIT</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RETRY</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FLOWCONTROL</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ZERO</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SHORT</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OOSERR</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DBTERM</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STREAM_ERROR</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIRST_ACK_NUMP_0</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STREAM_ST_CHG</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FLOWCONTROL_EXIT</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SPARE_REG</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>16</dim>
              <dimIncrement>4</dimIncrement>
              <name>PROT_EPI_INTR_MASK[%s]</name>
              <description>Per IN-Endpoint Interrupt Mask</description>
              <addressOffset>0x1C0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x70777</resetMask>
              <fields>
                <field>
                  <name>COMMIT_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RETRY_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FLOWCONTROL_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ZERO_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SHORT_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OOSERR_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DBTERM_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STREAM_ERROR_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIRST_ACK_NUMP_0_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STREAM_ST_CHG_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FLOWCONTROL_EXIT_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SPARE_REG_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>16</dim>
              <dimIncrement>4</dimIncrement>
              <name>PROT_EPI_INTR_MASKED[%s]</name>
              <description>Per IN-Endpoint Interrupt Masked</description>
              <addressOffset>0x200</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x70777</resetMask>
              <fields>
                <field>
                  <name>COMMIT_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RETRY_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FLOWCONTROL_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ZERO_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SHORT_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>OOSERR_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DBTERM_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STREAM_ERROR_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FIRST_ACK_NUMP_0_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STREAM_ST_CHG_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FLOWCONTROL_EXIT_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SPARE_REG_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>16</dim>
              <dimIncrement>4</dimIncrement>
              <name>PROT_EPI_CS1[%s]</name>
              <description>SuperSpeed IN Endpoint Control and Status</description>
              <addressOffset>0x240</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x11F</resetMask>
              <fields>
                <field>
                  <name>VALID</name>
                  <description>Set VALID=1 to activate an endpoint, and VALID=0 to de-activate it. All USB endpoints default to invalid. An endpoint whose VALID bit is 0 does not respond to any USB traffic.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NRDY</name>
                  <description>Setting this bit causes NRDY on IN transactions.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STALL</name>
                  <description>Set this bit to '1' to stall an endpoint, and to '0' to clear a stall.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STREAM_EN</name>
                  <description>Enables bulk stream protocol handling for this EP</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EP_RESET</name>
                  <description>Per End Point Reset.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ERDY_FLOWCONTROL</name>
                  <description>0: No Flow control
1: In Flow Control and wating to send ERDY. Once ERDY is sent this bit will be set to 0.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>16</dim>
              <dimIncrement>4</dimIncrement>
              <name>PROT_EPI_CS2[%s]</name>
              <description>SuperSpeed IN Endpoint Control and Status</description>
              <addressOffset>0x280</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x600040</resetValue>
              <resetMask>0x1FFE0FFF</resetMask>
              <fields>
                <field>
                  <name>EPI_TYPE</name>
                  <description>Endpoint type (EP0 suports CONTROL only)
0: ISO
1: INT
2: BULK
3: CONTROL (only valid for EP0)</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SPARE</name>
                  <description>Spare</description>
                  <bitRange>[7:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MAXBURST</name>
                  <description>Maximum number of packets the endpoint can send.
0: 1-PKT
1: 2-PKTS
2: 3-PKTS
.
.
.
15: 16-PKTS</description>
                  <bitRange>[11:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ISOINPKS</name>
                  <description>Number of packets to be sent per service interval .  Maximum can be 192.
48 DPs per service interval for devices operating at Gen 1x1 speed
96 DPs for devices operating at Gen 1x2 speed and Gen 2x1 speed
192 DPs for devices operating at Gen 2x2 speed.</description>
                  <bitRange>[24:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BINTERVAL</name>
                  <description>This register defines the service interval per bInterval value per EP (Egress ISO Only).
This register is used only if PROT_ENHANCE.EN_EGRS_ISO_SEQ_MATCH is '1'.
If PROT_EPI_INTR.OOSERR is set, FW needs to flush the SRAM and be ready for the next Service internal
0: Reset sequence # when BIC[0] changed (every ITP)
1: Reset sequence # when BIC[0]    transition to 0
2: Reset sequence # when BIC[1:0] transition to 0
3: Reset sequence # when BIC[2:0] transition to 0</description>
                  <bitRange>[28:25]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>16</dim>
              <dimIncrement>4</dimIncrement>
              <name>PROT_EPI_UNMAPPED_STREAM[%s]</name>
              <description>Unmapped Stream Request</description>
              <addressOffset>0x2C0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x400F0000</resetMask>
              <fields>
                <field>
                  <name>SPSM_STATE</name>
                  <description>Stream Protocol State Machine (SPSM) State for this EndPoint:

0: Not Configured
1: Disabled
2: Prime Pipe
3: DFR Prime Pipe
4: Idle
5: Start Stream
6: Move Data
7: End
8: Error</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>COMMAND</name>
                  <description>On the posedge edge of this signal, the stream state will be over-written by the SPSM_STATE value (SPSM_STATE value&lt;8) except Error state</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>16</dim>
              <dimIncrement>4</dimIncrement>
              <name>PROT_EPI_MAPPED_STREAM[%s]</name>
              <description>Mapped Streams Registers</description>
              <addressOffset>0x300</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xE00FFFFF</resetMask>
              <fields>
                <field>
                  <name>STREAM_ID</name>
                  <description>The StreamID of the stream connected to the corresponding socket by firmware.
Stream ID has to be unique for each socket.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EP_NUMBER</name>
                  <description>The Endpoint number of the stream connected to the corresponding socket by firmware.</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UNMAPPED</name>
                  <description>Stream is unmapped (not in use by the corresponding EP's SPSM).</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>UNMAP</name>
                  <description>Request to unmap this stream.  May be cleared to revert/withdaw request.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLE</name>
                  <description>Set by firmware if a stream is mapped to the corresponding socket. If this bit is set, the endpoint number corresponding to this socket number can no longer be used in non-streaming mode (that would create a conflict of two endpoints wanting to use the same socket).</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>16</dim>
              <dimIncrement>4</dimIncrement>
              <name>PROT_EPO_INTR[%s]</name>
              <description>Per OUT-Endpoint Interrupt</description>
              <addressOffset>0x340</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x71A77</resetMask>
              <fields>
                <field>
                  <name>COMMIT</name>
                  <description>Set whenever an OUT DATA was commited into the EPM.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RETRY</name>
                  <description>Whenever the USB3.0 device does a retry it will asserts this interrupt.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FLOWCONTROL</name>
                  <description>This bit will be set when entering flow control state due to data not being available or NRDY configuration register bit being set (NRDY) Or nump is zero.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ZERO</name>
                  <description>Indicates a zero length packet was received by the device in an OUT transaction.  Must be cleared by s/w.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SHORT</name>
                  <description>Indicates a shorter-than-maxsize packet was received.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OOSERR</name>
                  <description>Out Of Sequence Error. Anytime an OUT-DATA is received with unexpected sequence number request, the data will be dropped and intr will be raised</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STREAM_ERROR</name>
                  <description>Stream Error occurred. See PROT_STREAM_ERROR_DISABLE</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PP_ZERO</name>
                  <description>The PP field is zero</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EOB_ONE</name>
                  <description>The EOB/LPF is 1</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STREAM_ST_CHG</name>
                  <description>Stream state changed. Read PROT_EPO_UNMAPPED_STREAM.SPSM_STATE</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FLOWCONTROL_EXIT</name>
                  <description>This bit will be set when exiting flow control state when transmitting ERDY due to data is being available</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SPARE_REG</name>
                  <description>Spare</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>16</dim>
              <dimIncrement>4</dimIncrement>
              <name>PROT_EPO_INTR_SET[%s]</name>
              <description>Per OUT-Endpoint Interrupt set</description>
              <addressOffset>0x380</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x71A77</resetMask>
              <fields>
                <field>
                  <name>COMMIT</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RETRY</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FLOWCONTROL</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ZERO</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SHORT</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OOSERR</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STREAM_ERROR</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PP_ZERO</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EOB_ONE</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STREAM_ST_CHG</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FLOWCONTROL_EXIT</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SPARE_REG</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>16</dim>
              <dimIncrement>4</dimIncrement>
              <name>PROT_EPO_INTR_MASK[%s]</name>
              <description>Per OUT-Endpoint Interrupt Mask</description>
              <addressOffset>0x3C0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x71A77</resetMask>
              <fields>
                <field>
                  <name>COMMIT_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RETRY_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FLOWCONTROL_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ZERO_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SHORT_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OOSERR_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STREAM_ERROR_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PP_ZERO_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EOB_ONE_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STREAM_ST_CHG_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FLOWCONTROL_EXIT_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SPARE_REG_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>16</dim>
              <dimIncrement>4</dimIncrement>
              <name>PROT_EPO_INTR_MASKED[%s]</name>
              <description>Per OUT-Endpoint Interrupt Masked</description>
              <addressOffset>0x400</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x71A77</resetMask>
              <fields>
                <field>
                  <name>COMMIT_MASKED</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RETRY_MASKED</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FLOWCONTROL_MASKED</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ZERO_MASKED</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SHORT_MASKED</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>OOSERR_MASKED</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STREAM_ERROR_MASKED</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PP_ZERO_MASKED</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EOB_ONE_MASKED</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STREAM_ST_CHG_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FLOWCONTROL_EXIT_MASKED</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SPARE_REG_MASKED</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>16</dim>
              <dimIncrement>4</dimIncrement>
              <name>PROT_EPO_CS1[%s]</name>
              <description>SuperSpeed OUT Endpoint Control and Status</description>
              <addressOffset>0x440</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xC0</resetValue>
              <resetMask>0x1DF</resetMask>
              <fields>
                <field>
                  <name>VALID</name>
                  <description>Set VALID=1 to activate an endpoint, and VALID=0 to de-activate it. All USB endpoints default to invalid. An endpoint whose VALID bit is 0 does not respond to any USB traffic.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NRDY</name>
                  <description>Setting this bit causes NRDY on IN transactions.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STALL</name>
                  <description>Set this bit to '1' to stall an endpoint, and to '0' to clear a stall.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STREAM_EN</name>
                  <description>Enables bulk stream protocol handling for this EP</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EP_RESET</name>
                  <description>Per End Point Reset.This register only Resets the Ingress: ISO overflow sequence#, Pending ERDY &amp; Stream state machine.
The sequence# reset must be done using PROT_SEQ_NUM register</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EN_PP_ZERO_DET</name>
                  <description>This bit controls the EOT generation for Full-Packets when the Packet-Pending bit is zero in a valid DPH. 
In the case of Short or ZLP, EOT is automatically generated.
Note: When IEPM_ENDPOINT.EOT_EOP is '1', EOT is generated for DMA adapter for every packet.
0: EOT is NOT generated when PP=0
1: EOT is          generated when PP=0</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EN_EOB_ONE_DET</name>
                  <description>This bit controls the EOT generation when theEOB/LPF bit is one in a valid DPH. 
0: EOT is NOT generated when EOB/LPF=1
1: EOT is          generated when EOB/LPF=1</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ERDY_FLOWCONTROL</name>
                  <description>0: No Flow control
1: In Flow Control and wating to send ERDY. Once ERDY is sent this bit will be set to 0.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>16</dim>
              <dimIncrement>4</dimIncrement>
              <name>PROT_EPO_CS2[%s]</name>
              <description>SuperSpeed IN Endpoint Control and Status</description>
              <addressOffset>0x480</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x600040</resetValue>
              <resetMask>0x1FE0FFF</resetMask>
              <fields>
                <field>
                  <name>EPO_TYPE</name>
                  <description>Endpoint type (EP0 suports CONTROL only)
0: ISO
1: INT
2: BULK
3: CONTROL (only valid for EP0)</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SPARE</name>
                  <description>Spare</description>
                  <bitRange>[7:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MAXBURST</name>
                  <description>Maximum number of packets the endpoint can receive
0: 1-PKT
1: 2-PKTS
2: 3-PKTS
.
.
.
15: 16-PKTS</description>
                  <bitRange>[11:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ISOINPKS</name>
                  <description>Number of packets to be sent per service interval .  Maximum can be 192.
48 DPs per service interval for devices operating at Gen 1x1 speed
96 DPs for devices operating at Gen 1x2 speed and Gen 2x1 speed
192 DPs for devices operating at Gen 2x2 speed.</description>
                  <bitRange>[24:17]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>16</dim>
              <dimIncrement>4</dimIncrement>
              <name>PROT_EPO_UNMAPPED_STREAM[%s]</name>
              <description>Unmapped Stream Request</description>
              <addressOffset>0x4C0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x400F0000</resetMask>
              <fields>
                <field>
                  <name>SPSM_STATE</name>
                  <description>Stream Protocol State Machine (SPSM) State for this EndPoint:

0: Not Configured
1: Disabled
2: Prime Pipe
3: DFR Prime Pipe
4: Idle
5: Start Stream
6: Move Data
7: End
8: Error</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>COMMAND</name>
                  <description>On the posedge edge of this signal, the stream state will be over-written by the SPSM_STATE value (SPSM_STATE value&lt;8) except Error state</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>16</dim>
              <dimIncrement>4</dimIncrement>
              <name>PROT_EPO_MAPPED_STREAM[%s]</name>
              <description>Mapped Streams Registers</description>
              <addressOffset>0x500</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xE00FFFFF</resetMask>
              <fields>
                <field>
                  <name>STREAM_ID</name>
                  <description>The StreamID of the stream connected to the corresponding socket by firmware.
Note:
 The STREAM_ID[6:0] bits for EP0 is used for the device_address override value. See ENABLE description below.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EP_NUMBER</name>
                  <description>The Endpoint number of the stream connected to the corresponding socket by firmware.</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UNMAPPED</name>
                  <description>Stream is unmapped (not in use by the corresponding EP's SPSM).</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>UNMAP</name>
                  <description>Request to unmap this stream.  May be cleared to revert/withdaw request.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLE</name>
                  <description>Set by firmware if a stream is mapped to the corresponding socket. If this bit is set, the endpoint number corresponding to this socket number can no longer be used in non-streaming mode (that would create a conflict of two endpoints wanting to use the same socket).
Note:
 This bit for EP0 is used to enable overriding the device-address. The STREAM_ID[6:0] for EP0 is used for the device_address override value.
 If needed to over ride the device_address, the STREAM_ID[6:0] for EP0 should be programm first, then ENABLE for EP0 should be set to '1'.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_SUBLINK_DEV_NNOTIFICATION</name>
              <description>Sublink Speed Device Notification Settings</description>
              <addressOffset>0x580</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x40F</resetValue>
              <resetMask>0xFFF</resetMask>
              <fields>
                <field>
                  <name>EN_SUBLINK</name>
                  <description>0: Protocol won't issue Sublink Speed Device Notification
1: Protocol will issue RX followed by TX Sublink Speed Device Notification after ACKING the Status Phase of the Address USB Device State</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EN_SUBLINK_SET_ADDR0</name>
                  <description>0: Protocol won't issue Sublink Speed Device Notification when the host set device address to '0'
1: Protocol will issue RX followed by TX Sublink Speed Device Notification after ACKING the Status Phase of the Address USB Device State including setting the address to '0'</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LSE</name>
                  <description>The Lane Speed Exponent (LSE) field of the notification</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ST</name>
                  <description>The Sublink Type (ST) field of the notification</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LANES</name>
                  <description>Spare</description>
                  <bitRange>[9:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LP</name>
                  <description>Spare</description>
                  <bitRange>[11:10]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_SUBLINK_LSM</name>
              <description>Sublink Speed Device Notification Lane Speed Mantissa</description>
              <addressOffset>0x584</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RX_LSM</name>
                  <description>The Lane Speed Mantissa (LSM) field of the notification for RX</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TX_LSM</name>
                  <description>The Lane Speed Mantissa (LSM) field of the notification for TX</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_PTM_CONFIG</name>
              <description>PTM configuration register</description>
              <addressOffset>0x588</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x80000F07</resetMask>
              <fields>
                <field>
                  <name>LDM_ENABLE</name>
                  <description>Applies only to SuperSpeedPlus
0: LDM disabled. 
    This will cause the Requester State machine to go to LDM-Disabled state and all the logic for PTM will be reset
1: LDM enabled
    This will cause the Requester State machine to move to Init-Request state</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>COUNTER_CFG</name>
                  <description>For power saving.
1: The PTM counter continutes counting after T4 is captured.
0: The PTM counter stops counting after T4 is captured.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WAIT_ITP</name>
                  <description>0: Don't wait for ITP before sending LDM LMP when LPM_SEND register is set
1: Wait for ITP (Please see ITP_PTM_INTR_CONDITION) before LDM LMP is send when LPM_SEND register is set</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>START</name>
                  <description>FW sets this bit to 1 to start the PTM engine. The LDM_ENABLE must also be '1'.
PTM engine will reset this register and starts the T1/T4 capturing process</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STATE_CHANGE_SEL</name>
                  <description>Based on the following values, the PROT_INTR.LDM_STATE_CHANGE will be asserted. 
0: Disable state
1: Start Request state
2: ITP State
3: initial request state
4: initial respond state
5: Stamp request state
6: stamp respond state
7: Any state change</description>
                  <bitRange>[11:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LMP_SEND</name>
                  <description>Initiates sending of the LDM LMP.
FW requests HW to send LDM LMP.
HW clears it when sending LDM request is issued to Link layer.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_FW_PTM_COUNTER</name>
              <description>FW Load PTM counter register</description>
              <addressOffset>0x58C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LOAD</name>
                  <description>0: Don't load the PROT_PTM_COUNTER.VALUE
1: Do      load the PROT_PTM_COUNTER.VALUE</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>VALUE</name>
                  <description>The PTM counter value to be loaded.
14:1 BIC
27:15 Delat</description>
                  <bitRange>[27:1]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_HW_PTM_COUNTER</name>
              <description>HW Internal PTM counter</description>
              <addressOffset>0x590</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>READ</name>
                  <description>FW Sets this bit to read the HW PTM counter.
HW clears this bit to indicate that the PROT_HW_PTM_COUNTER(BIC and DC) are valid</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BIC</name>
                  <description>HW PTM Bus Interval Counter,</description>
                  <bitRange>[14:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DC</name>
                  <description>HW PTM Delta Counter</description>
                  <bitRange>[27:15]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_PTM_STATUS</name>
              <description>PTM status register</description>
              <addressOffset>0x594</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1F</resetMask>
              <fields>
                <field>
                  <name>LDM_REQ_STATE</name>
                  <description>LDM Requester state machine
0: Disabled
    Note: When Response timeout count reaches 3, the prot_intr.ldm_response_timeout_3 gets set. However, the value of this register will show a value of 1 
    (Start) instead of 0 (Disabled) because the PROT_PTM_CONFIG.LDM_ENABLE is '1' and the ptm state machine moves from Init Response to Disbaled 
    and then to Start state.
1: Start
2: ITP
3: Init Request
4: Init Response
5: Timestamp Request
6: Timestamp Response</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LDMS_TX</name>
                  <description>LDM Sequence Number (LDMS)
This field provide the LDM Sequence Number (LDMS) that was send.</description>
                  <bitRange>[4:3]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_PTM_T1</name>
              <description>PTM T1 value</description>
              <addressOffset>0x598</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIME</name>
                  <description>T1 value when LDM is Sent either by FW or when an LDM response with DL=1 is received.
This value is valid when PROT_PTM_INTR.LDM_TX OR PROT_PTM_INTR.LDM_DL_TX is set.
The T1 value is based on the internal 27-bit counter running on PTM clock.</description>
                  <bitRange>[26:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_PTM_T4</name>
              <description>PTM T4 value</description>
              <addressOffset>0x59C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIME</name>
                  <description>T4 value when LDM response with DL=0 is received.
This value is valid when PROT_PTM_INTR.LDM_DL_RX is set.
The T4 value is based on the internal 27-bit counter running on PTM clock.</description>
                  <bitRange>[26:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_LMP_LDM_RESPONSE</name>
              <description>Protocol LMP LDM received</description>
              <addressOffset>0x5A0</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1FFF801F</resetMask>
              <fields>
                <field>
                  <name>LDM_TYPE</name>
                  <description>LDM Type</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LDMS_RX</name>
                  <description>LDM Sequence Number (LDMS)</description>
                  <bitRange>[4:3]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LDM_RESP_DELAY</name>
                  <description>LDM Response Delay</description>
                  <bitRange>[28:15]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>16</dim>
              <dimIncrement>4</dimIncrement>
              <name>PROT_EPI_ENHANCE[%s]</name>
              <description>Enhancements for IN-Endpoint transactions</description>
              <addressOffset>0xA80</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x80000003</resetMask>
              <fields>
                <field>
                  <name>EN_TERM_NUMP0_RTY1</name>
                  <description>0: Disable Burst termination when an ACK with nump==0 and RTY==1 is received
1: Enable  Burst termination when an ACK with nump==0 and RTY==1 is received</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EN_EOB_ZLP</name>
                  <description>0: EOB is '0' for ZLP packets
1: EOB is '1' for ZLP packets</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EN_EOB_SHORT</name>
                  <description>0: EOB is '0' for short packet (does not include ZLP, EN_EOB_ZLP can be used for ZLP)
1: EOB is '1' for short packet (does not include ZLP, EN_EOB_ZLP can be used for ZLP)</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PROT_ENHANCE</name>
              <description>Protocol Enhancements Configuration register</description>
              <addressOffset>0xAC0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x128A0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>EN_DPH_ERR_DET</name>
                  <description>Only for Gen2:
0: Protocol will retry if there is DPH Error for Setup or DPP
1: Protocol will ACK the next Good-DPH+DPABORT if the byte-count maches with Replica field and CRC32 is ggod for the Setup/DPP with DPH Error.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DISABLE_STREAM_ERDY</name>
                  <description>This bit will control the ERDY transmission when entering IDLE state.
If setting this bit to '1', it must be done before programming PROT_EPO_MAPPED_STREAM/PROT_EPI_MAPPED_STREAM.ENABLE
1: No ERDY will be transmitted
0: ERDY will be transmitted if the conditions are met.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STREAM_ERDY_ONLY_DISABLED_ST</name>
                  <description>0: ERDY will be issue (if ready) for All Arch coming to IDLE states
1: ERDY will be issue (if ready) only when IDLE state is reached from DISABLED-PRIME/DFR-PRIME state</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EN_REJECTED_ERDY</name>
                  <description>0: ERDY won't be issue (if ready) for the rejected ERDY entering the IDLE state
1: ERDY will be issue    (if ready) for the rejected ERDY entering the IDLE state</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DISABLE_SI_MODE</name>
                  <description>1: The DDP transaction request to egress-EPM will be the same as Gen1. (Simultanous-IN is not supported)
0: The DDP transaction request to egress-EPM will be based on FIFO-Mode.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EN_EGRS_ISO_SEQ_MATCH</name>
                  <description>Enable the egress ISO Sequence matching on ITP detection (See ITP_RST_SEQ_NUM_CONDITION) and PROT_EPI_CS2.BINTERVAL</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ITP_RST_SEQ_NUM_CONDITION</name>
                  <description>Condition to qualify a valid ITP for resetting the seq# of an egress ISO-EP based on the PROT_EPI_CS2.BINTERVAL for that EP.
Bit[7:6]: Defer bit selection
                0X: Defer is not considered to qualify for a valid ITP
                10: Defer == 0
                11: Defer == 1
Bit[9:8]: DL bit selection
                0X: DL is not considered to qualify for a valid ITP
                10: DL == 0
                11: DL == 1</description>
                  <bitRange>[9:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ITP_PTM_INTR_CONDITION</name>
                  <description>Condition to qualify a valid ITP for PTM and Interrupt generation
Bit[11:10]: Defer bit selection
                0X: Defer is not considered to qualify for a valid ITP
                10: Defer == 0
                11: Defer == 1
Bit[13:12]: DL bit selection
                0X: DL is not considered to qualify for a valid ITP
                10: DL == 0
                11: DL == 1</description>
                  <bitRange>[13:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>INGRESS_FULL_COUNTER</name>
                  <description>When EOT or no space left in ingress assert the full to one for #INGRESS_FULL_COUNTER of cycles because due to pipelining the full from ingress asserts six cycles after the commit signal from Link.</description>
                  <bitRange>[16:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STREAM_READ_DIR</name>
                  <description>0: Ingress
1: Egress</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STREAM_READ_END_POINT</name>
                  <description>The endpoint number used for for providing the stream state machine for that endpoint.</description>
                  <bitRange>[21:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STREAM_READ_STATE</name>
                  <description>The stream state machine for the Ingress/egress (STREAM_READ_DIR) Endpoint(STREAM_READ_END_POINT).
'h00: NONE_ST
'h02: DISABLED_ST
'h04: PRIME_ST
'h08: DFR_PRIME_ST
'h10: IDLE_ST
'h20: START_STRM_ST
'h40: MVDATA_DEVICE_ST
'h80: END_ST</description>
                  <bitRange>[29:22]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RESET_SCH_TYPE1</name>
                  <description>This will reset the type1 scheduler.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RESET_SCH_TYPE2</name>
                  <description>This will reset the type2 scheduler.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
          <cluster>
            <name>USB32DEV_PHYSS</name>
            <description>USB32 SuperSpeedPlus Physical Layer Registers</description>
            <addressOffset>0x00004000</addressOffset>
            <cluster>
              <dim>2</dim>
              <dimIncrement>4096</dimIncrement>
              <name>USB40PHY[%s]</name>
              <description>PHY Registers</description>
              <addressOffset>0x00000000</addressOffset>
              <cluster>
                <name>USB40PHY_TOP</name>
                <description>PHY TOP, PCS, Tx registers</description>
                <addressOffset>0x00000000</addressOffset>
                <register>
                  <name>TOP_CTRL_0</name>
                  <description>TOP control register</description>
                  <addressOffset>0x4</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x10201100</resetValue>
                  <resetMask>0x137BFF1E</resetMask>
                  <fields>
                    <field>
                      <name>REG_PWR_GOOD_CORE_RX</name>
                      <description>Power Good Rx</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_PWR_GOOD_CORE_PLL</name>
                      <description>Power Good PLL</description>
                      <bitRange>[2:2]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_VBUS</name>
                      <description>VBUS indication register. It connects to PowerPresent on PIPE</description>
                      <bitRange>[3:3]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_PLL_RSTB</name>
                      <description>Reset input that is synchronized to PLL clock. Once PLL is up and locked, this bit has to be set</description>
                      <bitRange>[4:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_LFPS_CLK_DIV</name>
                      <description>Divide value to generate LFPS Clock. LFPS clock is generated from clk_hf. Divide value is reg_lfps_clk_div + 1.
As this is used as the LFPS signal - only even divide factors are allowed to meet the duty cycle requirement i.e reg_lfps_clk_divide - 0,1,3,5 etc
This register must be programmed before clock HF ebabled from SRSS.</description>
                      <bitRange>[11:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_SHIFT_CLK_DIV</name>
                      <description>Divide value for generating Tx AFE shift clock. This clock is generated from MMIO clock. Divide value is ref_tx_shift_clk_div+1</description>
                      <bitRange>[15:12]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_PHYSS_EN</name>
                      <description>mxs40usb40phy enable. It used for the S/W reset</description>
                      <bitRange>[16:16]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_RX_EQ_TRAINING_FLAG</name>
                      <description>This register bit indicates that the RXEQ has happened. The PHY logic does not know if LTSSM has transitioned to RX_DETECT state. If LTSSM state transitions to RX_DETECT state, this bit has to be cleared by FW</description>
                      <bitRange>[17:17]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>PCLK_EN</name>
                      <description>This bit indicates that the PCLK is available to the PHY.
PCLK becomes available when the PLL is turned on and the TX digital serializer is enabled. When transitioning from PCLK OFF State -&gt; PCLK_ON State, this bit has to be set to 1 after PCLK is available. When transitioning from PCLK_ON State to PCLK_OFF state, this bit has to be set to 0 after switching off the PLL/Serializer</description>
                      <bitRange>[19:19]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>RATE_CHANGE_DONE</name>
                      <description>This bit needs to be set after a dynamic rate change to indicate to the PHY that the clock is updated. The PHY will clear this bit on indicating to the Link Layer</description>
                      <bitRange>[20:20]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>RATE</name>
                      <description>This field controls the rate of the PHY. FW has to set this bit to the appropriate rate before signalling rate change done. At power up default is Gen2. Allowed values are
Gen1 - 2'b00
Gen2 - 2'b01
The rate requested by the Link is available in PCS_STATUS.reg_pipe_rate
This bit should be changed by FW only when the PLL is in reset.</description>
                      <bitRange>[22:21]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>PLL_VCCD_LEVELSHIFT_EN</name>
                      <description>This register enables the level shifter on the XTAL clock reference.
This register should only be set after PLL regulator is turned on. When turning off the PLL regulator, this bit has to be cleared before PLL is turned off. This bit is effective only in the instance where PLL is present.
Note that this levelshifter is needed to be enable when using XTAL reference either for the RX or the PLL</description>
                      <bitRange>[24:24]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>PLL_VHS_LEVELSHIFT_EN</name>
                      <description>This register enables the level shifter on the USB2 clock reference to PLL.
The USB2 PLL output is on the VHS supply, so this register should only be set after both PLL regulator and VHS regulator are turned on. When turning off the PLL regulator, this bit has to be cleared before PLL is turned off. This bit is effective only in the instance where PLL is present
Note that this levelshifter is needed to be enable when using XTAL reference either for the RX or the PLL</description>
                      <bitRange>[25:25]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>GEN1_BERT_EN</name>
                      <description>This register enables the BERT command processing in PCS loopback</description>
                      <bitRange>[28:28]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PCS_CTRL_0</name>
                  <description>PCS control register</description>
                  <addressOffset>0x10</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x88000030</resetValue>
                  <resetMask>0xFF0038FF</resetMask>
                  <fields>
                    <field>
                      <name>GEN2_HDR_CORRECTION_DISABLE</name>
                      <description>Setting this bit disables header error correction in Gen2</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>GEN2_SKP_CORRECTION_DISABLE</name>
                      <description>Setting this bit disables SKP OS error correction in Gen2</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>GEN2_SDS_CORRECTION_DISABLE</name>
                      <description>Setting this bit disables SDS OS error correction in Gen2</description>
                      <bitRange>[2:2]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>CLEAR_ERR_CNTR</name>
                      <description>Clear the error counters reported in ERR_STATUS</description>
                      <bitRange>[3:3]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ONEZERO_CNT</name>
                      <description>USB 3.1 CP7/CP8 one_zero number selection (1clk = 20bit)
the number of clocks is programmed + 1
Spec requires 50-250 1/0</description>
                      <bitRange>[7:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>TX_SER_EN_DLY</name>
                      <description>HS TX starts on TXELECIDLE low, this register can be used to delay the TX Serializer Enable from the fall edge of TXELECIDLE</description>
                      <bitRange>[13:11]</bitRange>
                      <access>write-only</access>
                    </field>
                    <field>
                      <name>GEN1_EB_HALF_DEPTH</name>
                      <description>Half Depth for Gen1 Elasticity buffer. Depth is fixed at 16, but half depth is programmable</description>
                      <bitRange>[27:24]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>GEN2_EB_HALF_DEPTH</name>
                      <description>Half Depth for Gen2 Elasticity buffer. Depth is fixed at 16, but half depth is programmable</description>
                      <bitRange>[31:28]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PCS_STATUS</name>
                  <description>PCS status register</description>
                  <addressOffset>0x18</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xF3FF</resetMask>
                  <fields>
                    <field>
                      <name>REG_PCS_RX_ALIGNED</name>
                      <description>PCS aligner lock</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_PCS_RX_MATCHED_CNT</name>
                      <description>PCS aligner matched number</description>
                      <bitRange>[7:1]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_PIPE_RATE</name>
                      <description>Rate from MAC</description>
                      <bitRange>[9:8]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>ALIGNER_STATE</name>
                      <description>Aligner State for Debug</description>
                      <bitRange>[14:12]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>CDR_LOCK_TO_REFERENCE</name>
                      <description>RX CDR state</description>
                      <bitRange>[15:15]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PCS_SPARE</name>
                  <description>PCS spare</description>
                  <addressOffset>0x1C</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0xFF000000</resetValue>
                  <resetMask>0xFFFFFFFF</resetMask>
                  <fields>
                    <field>
                      <name>REG_DFT</name>
                      <description>Bit 0: TX AFE Calibration Enable overide
Bit 1: TX AFE Calibration Enable overide value
Bit 2: 0 - Lock 2 Data Change happens on P0 Entry
          1 - Lock 2 Data Change happens on 1st LFPS Deassertion after P0 Entry
Bit 3: 0 - Elastic Buffer writes start on RX alignment
          1 - Elastic Buffer writes start on External input from controller
Bit 4: 0 - This lane LFPS/Powermode are used for L2D change
          1 - Config Lane LFPS/Powermode are used for L2D change
Bits 11:4 - Spare
Bit 3 and Bit 4 are to enable X2 operation. These bits have to be set to select the config lane option. The config lane can be known from the link layer. During speed negotiation, these bits have to be set to appropriate value based on x2 or x1</description>
                      <bitRange>[11:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_SPARE0</name>
                      <description>Spare with default 0</description>
                      <bitRange>[23:12]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_SPARE1</name>
                      <description>Spare with default 1
Bit 0: Realignment allowed on block control assertion in Gen2</description>
                      <bitRange>[31:24]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>ERR_STATUS</name>
                  <description>Error status register</description>
                  <addressOffset>0x20</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x3FFFFFFF</resetMask>
                  <fields>
                    <field>
                      <name>HDR_ERR_CORRECTED_CNT</name>
                      <description>This counter tracks the number of corrected block headers in Gen2. This count will saturate when max count is hit</description>
                      <bitRange>[15:0]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>SKP_ERR_CORRECTED_CNT</name>
                      <description>This register indicates the number of SKP characters corrected by the PHY. This will saturate at 0x1F. The counter will be cleared automatically at every new U0 entry.</description>
                      <bitRange>[25:16]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>SDS_ERR_CORRECTED_CNT</name>
                      <description>This register indicates the number of SDS symbols corrected by the PHY. This will saturate at 0x1F. The counter will be cleared automatically at every new U0 entry.</description>
                      <bitRange>[29:26]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PIPE_OVERRIDE_0</name>
                  <description>PIPE interface control signals override register #0</description>
                  <addressOffset>0x30</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xC01FFFE3</resetMask>
                  <fields>
                    <field>
                      <name>PIPE_ENCDEC_BYPASS_OVRD_EN</name>
                      <description>PIPE - enable override of encodedecode_bypass signal</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>PIPE_ENCDEC_BYPASS_OVRD_VALUE</name>
                      <description>PIPE - encodedecode bypass signal override</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_PIPE_EB_MODE_OVRD_EN</name>
                      <description>PIPE - Selects elastic buffer operating mode</description>
                      <bitRange>[5:5]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_PIPE_EB_MODE_OVRD_VALUE</name>
                      <description>PIPE - Selects elastic buffer operating mode
Note: Gen2 does not support empty mode of operation</description>
                      <bitRange>[6:6]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_PIPE_TX_DETECTRX_OVRD_EN</name>
                      <description>PIPE - Controls receiver detection or loopback mode.</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_PIPE_TX_DETECTRX_OVRD_VALUE</name>
                      <description>PIPE - Controls receiver detection or loopback mode</description>
                      <bitRange>[8:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_PIPE_TX_ELECTIDLE_OVRD_EN</name>
                      <description>PIPE - Tx Electric Idle - Forces Tx output to Electrical Idle when asserted</description>
                      <bitRange>[9:9]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_PIPE_TX_ELECTIDLE_OVRD_VALUE</name>
                      <description>PIPE - Tx Electric Idle - Forces Tx output to Electrical Idle when asserted</description>
                      <bitRange>[10:10]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_PIPE_TX_ONE_ZEROS_OVRD_EN</name>
                      <description>PIPE - Enables USB SS compliance pattern CP7 or CP8</description>
                      <bitRange>[11:11]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_PIPE_TX_ONE_ZEROS_OVRD_VALUE</name>
                      <description>PIPE - Enables USB SS compliance pattern CP7 or CP8</description>
                      <bitRange>[12:12]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_PIPE_RX_POLARITY_OVRD_EN</name>
                      <description>PIPE - Enables receiver polarity inversion</description>
                      <bitRange>[13:13]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_PIPE_RX_POLARITY_OVRD_VALUE</name>
                      <description>PIPE - Enables receiver polarity inversion</description>
                      <bitRange>[14:14]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_PIPE_RX_EQ_TRAINING_OVRD_EN</name>
                      <description>PIPE - Enables equalization training</description>
                      <bitRange>[15:15]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_PIPE_RX_EQ_TRAINING_OVRD_VALUE</name>
                      <description>PIPE - Enables equalization training</description>
                      <bitRange>[16:16]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_PIPE_POWER_DOWN_OVRD_EN</name>
                      <description>PIPE - Controls the transceiver power state</description>
                      <bitRange>[17:17]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_PIPE_POWER_DOWN_OVRD_VALUE</name>
                      <description>PIPE - Controls the transceiver power state</description>
                      <bitRange>[20:18]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_PIPE_BLOCK_ALIGN_CONTROL_OVRD_EN</name>
                      <description>PIPE - Enables SYNC OS detection</description>
                      <bitRange>[30:30]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_PIPE_BLOCK_ALIGN_CONTROL_OVRD_VALUE</name>
                      <description>PIPE - Enables SYNC OS detection</description>
                      <bitRange>[31:31]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PIPE_STATUS</name>
                  <description>PIPE interface status read register</description>
                  <addressOffset>0x38</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x1FFF</resetMask>
                  <fields>
                    <field>
                      <name>REG_PIPE_RXVALID</name>
                      <description>PIPE - Indicates symbol lock and valid data</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_PIPE_PHY_STATUS</name>
                      <description>PIPE - Indicates completion of PHY operations</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_PIPE_RX_ELECIDLE</name>
                      <description>PIPE - Indicates receiver detection of electrical idle</description>
                      <bitRange>[2:2]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_PIPE_RX_STATUS</name>
                      <description>PIPE - Indicates status of received data and receiver detection</description>
                      <bitRange>[5:3]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_PIPE_POWER_PRESENT</name>
                      <description>PIPE - Indicates the presence of VBUS</description>
                      <bitRange>[6:6]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>RX_TERMINATION</name>
                      <description>PIPE - Indicates rx termination</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>RX_STANDBY</name>
                      <description>PIPE - RX Standby</description>
                      <bitRange>[8:8]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>PHY_IN_P0</name>
                      <description>PHY in P0</description>
                      <bitRange>[9:9]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>PHY_IN_P1</name>
                      <description>PHY in P1</description>
                      <bitRange>[10:10]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>PHY_IN_P2</name>
                      <description>PHY in P2</description>
                      <bitRange>[11:11]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>PHY_IN_P3</name>
                      <description>PHY in P3</description>
                      <bitRange>[12:12]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>INTR0</name>
                  <description>INTR0 Cause.  These are the wakeup interrupts get reflected on interrupt_wakeup pin.</description>
                  <addressOffset>0x40</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x3FFFFFFF</resetMask>
                  <fields>
                    <field>
                      <name>REG_INT_RATE_CHANGE</name>
                      <description>Indicates RATE change to F/W. RATE information comes from MAC</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_P0_CHANGE</name>
                      <description>Indicates P0 change to F/W. PowerDown information comes from MAC</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_P1_CHANGE</name>
                      <description>Indicates P1 change to F/W. PowerDown information comes from MAC</description>
                      <bitRange>[2:2]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_P2_CHANGE</name>
                      <description>Indicates P2 change to F/W. PowerDown information comes from MAC</description>
                      <bitRange>[3:3]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_P3_CHANGE</name>
                      <description>Indicates P3 change to F/W. PowerDown information comes from MAC</description>
                      <bitRange>[4:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_TX_SFT_REG_WDONE</name>
                      <description>Indicates shift register write done</description>
                      <bitRange>[5:5]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_PLL_LOCKED</name>
                      <description>Loss of RX PLL clock</description>
                      <bitRange>[6:6]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_POWER_GOOD_RXA</name>
                      <description>RXA Regulator power good</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_POWER_GOOD_RXCK</name>
                      <description>RXCK Regulator power good</description>
                      <bitRange>[8:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_POWER_GOOD_RXD</name>
                      <description>RXD Regulator power good</description>
                      <bitRange>[9:9]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_OSA_ERROR</name>
                      <description>Indicates failure of offset calibration</description>
                      <bitRange>[10:10]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_OSA_ALL_DONE</name>
                      <description>Indicates all offset calibration complete</description>
                      <bitRange>[11:11]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_EQ_START</name>
                      <description>Interrupt to F/W indicating start of RxEQ phase.</description>
                      <bitRange>[12:12]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_EYE_HIGHT_DONE</name>
                      <description>Interrupt to controller indicating completation of eye height measurement</description>
                      <bitRange>[13:13]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_EYE_MON_DONE</name>
                      <description>Interrupt to controller indicating completation of eye monitor measurement</description>
                      <bitRange>[14:14]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PLL_LOCKED</name>
                      <description>Loss of PLL clock</description>
                      <bitRange>[15:15]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PLL_PWR_GOOD_LCPLL</name>
                      <description>Indicates vreglcpll power good</description>
                      <bitRange>[16:16]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PLL_PWR_GOOD_REF</name>
                      <description>Indicates vregref power good</description>
                      <bitRange>[17:17]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PLL_PWR_GOOD_DIG</name>
                      <description>Indicates vregdig power good</description>
                      <bitRange>[18:18]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PCS_RX_ALIGNER_LOCK</name>
                      <description>Indicates PCS Rx aligner lock</description>
                      <bitRange>[19:19]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PCS_RX_DETECTED</name>
                      <description>Indicates PCS Rx detected</description>
                      <bitRange>[20:20]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PCS_DECODE_ERR</name>
                      <description>Indicates Gen1 8b/10b disparity error</description>
                      <bitRange>[21:21]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PCS_EB_OVERFLOW</name>
                      <description>Indicates elastic buffer overflow</description>
                      <bitRange>[22:22]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PCS_EB_UNDERFLOW</name>
                      <description>Indicates elastic buffer underflow</description>
                      <bitRange>[23:23]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_LOOPBACK_LOCK</name>
                      <description>Indicates Loopback lock</description>
                      <bitRange>[24:24]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_LOOPBACK_DONE</name>
                      <description>Indicates loopback is complete</description>
                      <bitRange>[25:25]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_TX_IMP_CAL_DONE</name>
                      <description>Indicates Tx impedance calibration done</description>
                      <bitRange>[26:26]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>SAR_DONE</name>
                      <description>Marks Completion of the ADC SAR1-4 conversion at the end of 8 cycles of clk_sar when SAR_EN is '1'</description>
                      <bitRange>[27:27]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>RX_TERMINATION_CHANGE</name>
                      <description>Indicates that Link has toggled RX_TERMINATION pipe signal</description>
                      <bitRange>[28:28]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>RX_STANDBY_CHANGE</name>
                      <description>Indicates that Link has toggled RX_TERMINATION pipe signal</description>
                      <bitRange>[29:29]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>INTR0_SET</name>
                  <description>INTR0 Set</description>
                  <addressOffset>0x44</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x3FFFFFFF</resetMask>
                  <fields>
                    <field>
                      <name>REG_INT_RATE_CHANGE</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_P0_CHANGE</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_P1_CHANGE</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[2:2]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_P2_CHANGE</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[3:3]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_P3_CHANGE</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[4:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_TX_SFT_REG_WDONE</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[5:5]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_PLL_LOCKED</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[6:6]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_POWER_GOOD_RXA</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_POWER_GOOD_RXCK</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[8:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_POWER_GOOD_RXD</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[9:9]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_OSA_ERROR</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[10:10]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_OSA_ALL_DONE</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[11:11]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_EQ_START</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[12:12]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_EYE_HIGHT_DONE</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[13:13]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_EYE_MON_DONE</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[14:14]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PLL_LOCKED</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[15:15]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PLL_PWR_GOOD_LCPLL</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[16:16]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PLL_PWR_GOOD_REF</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[17:17]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PLL_PWR_GOOD_DIG</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[18:18]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PCS_RX_ALIGNER_LOCK</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[19:19]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PCS_RX_DETECTED</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[20:20]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PCS_DECODE_ERR</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[21:21]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PCS_EB_OVERFLOW</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[22:22]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PCS_EB_UNDERFLOW</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[23:23]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_LOOPBACK_LOCK</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[24:24]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_LOOPBACK_DONE</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[25:25]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_TX_IMP_CAL_DONE</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[26:26]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>SAR_DONE</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[27:27]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>RX_TERMINATION_CHANGE</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[28:28]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>RX_STANDBY_CHANGE</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[29:29]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>INTR0_MASK</name>
                  <description>INTR0 Mask</description>
                  <addressOffset>0x48</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x3FFFFFFF</resetMask>
                  <fields>
                    <field>
                      <name>REG_INT_RATE_CHANGE_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_P0_CHANGE_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_P1_CHANGE_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[2:2]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_P2_CHANGE_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[3:3]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_P3_CHANGE_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[4:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_TX_SFT_REG_WDONE_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[5:5]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_PLL_LOCKED_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[6:6]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_POWER_GOOD_RXA_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_POWER_GOOD_RXCK_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[8:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_POWER_GOOD_RXD_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[9:9]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_OSA_ERROR_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[10:10]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_OSA_ALL_DONE_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[11:11]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_EQ_START_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[12:12]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_EYE_HIGHT_DONE_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[13:13]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_EYE_MON_DONE_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[14:14]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PLL_LOCKED_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[15:15]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PLL_PWR_GOOD_LCPLL_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[16:16]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PLL_PWR_GOOD_REF_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[17:17]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PLL_PWR_GOOD_DIG_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[18:18]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PCS_RX_ALIGNER_LOCK_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[19:19]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PCS_RX_DETECTED_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[20:20]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PCS_DECODE_ERR_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[21:21]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PCS_EB_OVERFLOW_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[22:22]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_PCS_EB_UNDERFLOW_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[23:23]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_LOOPBACK_LOCK_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[24:24]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_LOOPBACK_DONE_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[25:25]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_INT_TX_IMP_CAL_DONE</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[26:26]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>SAR_DONE</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[27:27]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>RX_TERMINATION_CHANGE</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[28:28]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>RX_STANDBY_CHANGE</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[29:29]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>INTR0_MASKED</name>
                  <description>INTR0 Masked</description>
                  <addressOffset>0x4C</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x3FFFFFFF</resetMask>
                  <fields>
                    <field>
                      <name>REG_INT_RATE_CHANGE_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_P0_CHANGE_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_P1_CHANGE_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[2:2]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_P2_CHANGE_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[3:3]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_P3_CHANGE_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[4:4]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_TX_SFT_REG_WDONE_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[5:5]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_PLL_LOCKED_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[6:6]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_POWER_GOOD_RXA_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_POWER_GOOD_RXCK_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[8:8]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_POWER_GOOD_RXD_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[9:9]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_OSA_ERROR_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[10:10]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_OSA_ALL_DONE_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[11:11]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_EQ_START_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[12:12]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_EYE_HIGHT_DONE_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[13:13]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_RX_EYE_MON_DONE_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[14:14]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_PLL_LOCKED_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[15:15]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_PLL_PWR_GOOD_LCPLL_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[16:16]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_PLL_PWR_GOOD_REF_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[17:17]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_PLL_PWR_GOOD_DIG_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[18:18]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_PCS_RX_ALIGNER_LOCK_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[19:19]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_PCS_RX_DETECTED_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[20:20]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_PCS_DECODE_ERR_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[21:21]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_PCS_EB_OVERFLOW_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[22:22]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_PCS_EB_UNDERFLOW_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[23:23]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_LOOPBACK_LOCK_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[24:24]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_LOOPBACK_DONE_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[25:25]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_INT_TX_IMP_CAL_DONE</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[26:26]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>SAR_DONE</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[27:27]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>RX_TERMINATION_CHANGE</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[28:28]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>RX_STANDBY_CHANGE</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[29:29]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>INTR1</name>
                  <description>INTR1 Cause.  These are the wakeup interrupts get reflected on interrupt_wakeup pin.</description>
                  <addressOffset>0x50</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x1</resetMask>
                  <fields>
                    <field>
                      <name>REG_INT_RX_LFPSDET_OUT</name>
                      <description>Indicates LFPS detected on RX pins</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>INTR1_SET</name>
                  <description>INTR1 Set</description>
                  <addressOffset>0x54</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x1</resetMask>
                  <fields>
                    <field>
                      <name>REG_INT_RX_LFPSDET_OUT</name>
                      <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>INTR1_MASK</name>
                  <description>INTR1 Mask</description>
                  <addressOffset>0x58</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x1</resetMask>
                  <fields>
                    <field>
                      <name>REG_INT_RX_LFPSDET_OUT_MASK</name>
                      <description>Mask bit for corresponding bit in interrupt request register.</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>INTR1_MASKED</name>
                  <description>INTR1 Masked</description>
                  <addressOffset>0x5C</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x1</resetMask>
                  <fields>
                    <field>
                      <name>REG_INT_RX_LFPSDET_OUT_MASKD</name>
                      <description>Logical and of corresponding request and mask bits.</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>TX_AFE_CTRL_0</name>
                  <description>Tx AFE control register #0</description>
                  <addressOffset>0x60</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x144630E8</resetValue>
                  <resetMask>0x3FFFFFFF</resetMask>
                  <fields>
                    <field>
                      <name>REG_TX_AFE_EN</name>
                      <description>Enable signal for Tx</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_DRV_EN</name>
                      <description>Enable signal for Tx driver</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_CML2CMOS_EN</name>
                      <description>Enable signal for CML2CMOS clock converter</description>
                      <bitRange>[2:2]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>TX_SERIALIZER_RST</name>
                      <description>Reset for Serializer. During rate change this reset has to be toggled</description>
                      <bitRange>[3:3]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_VCPREG_EN</name>
                      <description>voltage regulator charge pump enable</description>
                      <bitRange>[4:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_VCPREG_SEL</name>
                      <description>charge pump output voltage selection</description>
                      <bitRange>[8:5]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_CPCLK_SEL</name>
                      <description>charge pump clock frequency selection</description>
                      <bitRange>[9:9]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_VREG_CLK_EN</name>
                      <description>clock regulator enable</description>
                      <bitRange>[10:10]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_VREG_CLK_SEL</name>
                      <description>clock regulator output voltage selection</description>
                      <bitRange>[14:11]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_VREG_DRV_EN</name>
                      <description>Driver regulator enable</description>
                      <bitRange>[15:15]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_VREG_DRV_SEL</name>
                      <description>Driver regulator output voltage selection</description>
                      <bitRange>[19:16]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_TX_PULL_DN</name>
                      <description>Control bit to make txp/n pads low</description>
                      <bitRange>[20:20]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_TX_LOOPBK_EN</name>
                      <description>Analog Serial Loopback Enable</description>
                      <bitRange>[21:21]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_TX_DCD_CTRL</name>
                      <description>Duty cycle control for internal high speed clock</description>
                      <bitRange>[25:22]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_TX_DETECTRX_TRIM</name>
                      <description>Enable receiver detection threshold selection</description>
                      <bitRange>[27:26]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_TX_ELECIDLE_DRV</name>
                      <description>Electricle idle driver stregnth control
00: Hi-Z
01: weak drive strength (default)
10: Moderate drive strength
11: strongest drive strength</description>
                      <bitRange>[29:28]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>TX_AFE_CTRL_1</name>
                  <description>Tx AFE control register #1</description>
                  <addressOffset>0x64</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x7FFBF</resetMask>
                  <fields>
                    <field>
                      <name>REG_TX_AFE_TX_ICAL_TRIM</name>
                      <description>Input current  trim for output Impedance calibration</description>
                      <bitRange>[5:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_BURNIN_EN</name>
                      <description>burnin enable for internal regulator</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_TX_ADFT_EN</name>
                      <description>ADFT enable</description>
                      <bitRange>[8:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_TX_ADFT</name>
                      <description>TX adft control</description>
                      <bitRange>[13:9]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_TX_DDFT</name>
                      <description>TX ddft control</description>
                      <bitRange>[18:14]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>TX_AFE_RXDETECT_CNT</name>
                  <description>Tx AFE TxDetectRx wait counter</description>
                  <addressOffset>0x6C</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x3F64</resetValue>
                  <resetMask>0xFFFF</resetMask>
                  <fields>
                    <field>
                      <name>RXDETECT_WAIT_CNT</name>
                      <description>Time to wait from TX PULL UP assertion to when the rxdetect output of the AFE is sampled.
Runs on 100MHz PERI clock. Default 1us</description>
                      <bitRange>[7:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>PULLUP_ASSERT_DLY</name>
                      <description>Time from txdetectrx PIPE input to when the TX PULL UP input of the AFE is asserted</description>
                      <bitRange>[15:8]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>TX_AFE_OVERRIDE_0</name>
                  <description>Tx AFE override 0 register</description>
                  <addressOffset>0x70</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x3F3FFF</resetMask>
                  <fields>
                    <field>
                      <name>REG_TX_AFE_TX_PULL_UP_OVRD_EN</name>
                      <description>Override TX pull-up</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_TX_PULL_UP_OVRD_VALUE</name>
                      <description>Control bit to make txp/n pads high</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_TX_SER_EN_OVRD_EN</name>
                      <description>Override Serializer enable input of AFE</description>
                      <bitRange>[2:2]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_TX_SER_EN_OVRD_VALUE</name>
                      <description>Serializer Enable control
    0 - Serializer disabled  
    1 - Serilizer enabled</description>
                      <bitRange>[3:3]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_TX_HSCLK_DRV_EN_OVRD_EN</name>
                      <description>Override high speed clock driver enable</description>
                      <bitRange>[4:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_TX_HSCLK_DRV_EN_OVRD_VALUE</name>
                      <description>Enable signal for high speed clock that drives the final driver</description>
                      <bitRange>[5:5]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>TX_AFE_SER_RESET_OVRD_EN</name>
                      <description>Reset for Serializer data path
0 - Serializer data path reset is controlled by FW
1 - Serializer data path is dynamically controlled 
Serializer brought out of reset 6 PCLK cycles before serializer is enabled and is disabled 8 PCLK cycles after HS data stops. Note that this only resets the datapath flops/clock - nothing is done to the clock generation</description>
                      <bitRange>[6:6]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>TX_AFE_SER_RESET_OVRD_VALUE</name>
                      <description>Serializer datapath reset value when driven by FW</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_TX_DETECTRX_OVRD_EN</name>
                      <description>Override receiver detection</description>
                      <bitRange>[8:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_TX_DETECTRX_OVRD_VALUE</name>
                      <description>Enable receiver detection</description>
                      <bitRange>[9:9]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_TX_ELECIDLE_OVRD_EN</name>
                      <description>Override TX electrical Idle</description>
                      <bitRange>[10:10]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_TX_ELECIDLE_OVRD_VALUE</name>
                      <description>Enable TX electrical idle</description>
                      <bitRange>[11:11]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_TX_LFPS_OVRD_EN</name>
                      <description>Override LFPS input</description>
                      <bitRange>[12:12]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_TX_LFPS_OVRD_VALUE</name>
                      <description>Enable LFPS signaling</description>
                      <bitRange>[13:13]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_TX_ZTRIM_OVRD_EN</name>
                      <description>Override Ztrim input of AFE</description>
                      <bitRange>[16:16]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_TX_ZTRIM_OVRD_VALUE</name>
                      <description>Automatic impedance calibration trim bits</description>
                      <bitRange>[21:17]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>TX_AFE_DEBUG</name>
                  <description>Tx AFE debug register</description>
                  <addressOffset>0x78</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x3</resetMask>
                  <fields>
                    <field>
                      <name>REG_TX_AFE_DDFT_OUT1</name>
                      <description>DDFT output</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>REG_TX_AFE_DDFT_OUT2</name>
                      <description>DDFT output</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>TX_AFE_STATUS</name>
                  <description>Tx AFE status register</description>
                  <addressOffset>0x7C</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFF</resetMask>
                  <fields>
                    <field>
                      <name>ZCAL_STATUS</name>
                      <description>1: Calibration found a valid code. Code in ZCAL_CODE
0: Fail.Reached final value without finding valid code</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>ZCAL_CODE</name>
                      <description>Calibration code</description>
                      <bitRange>[5:1]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>ZCAL_COMP_OUT</name>
                      <description>Comparator Output</description>
                      <bitRange>[6:6]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>TX_DETECTRX_OUT</name>
                      <description>Exteranl Rx detect output</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>TX_AFE_ZTRIM</name>
                  <description>Tx AFE impedance calibration register</description>
                  <addressOffset>0x84</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x3E04</resetValue>
                  <resetMask>0x73FFF</resetMask>
                  <fields>
                    <field>
                      <name>ZCAL_EN</name>
                      <description>Impedance calibration enable</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ZCAL_MODE</name>
                      <description>0: Increment through the codes
1: Decrement through the codes</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ZCAL_COMP_WAIT</name>
                      <description>impedance calibration comperator wait delay
0: 0.5us
1: 1us (default)
2: 2us
3: 4us</description>
                      <bitRange>[3:2]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ZCAL_START_CODE</name>
                      <description>Impedance calibration trim force enable</description>
                      <bitRange>[8:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ZCAL_FINAL_CODE</name>
                      <description>Impedance calibration trim force</description>
                      <bitRange>[13:9]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ZCAL_CURR_STATE</name>
                      <description>Calibration State for debug</description>
                      <bitRange>[18:16]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>TX_AFE_CFG</name>
                  <description>Tx AFE configuration control register</description>
                  <addressOffset>0x90</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x1</resetMask>
                  <fields>
                    <field>
                      <name>REG_TX_CFG_WRITE_DONE</name>
                      <description>Tx AFE config shift register write done.</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>TX_AFE_CFG_SFT_W_0</name>
                  <description>Tx AFE configuration control shift write register #0</description>
                  <addressOffset>0x94</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x3FFFFF</resetValue>
                  <resetMask>0x3FFFFF</resetMask>
                  <fields>
                    <field>
                      <name>REG_TX_CFG_SFT_W_0</name>
                      <description>Tx AFE config shift register write</description>
                      <bitRange>[21:0]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>TX_AFE_CFG_SFT_W_1</name>
                  <description>Tx AFE configuration control shift write register #1</description>
                  <addressOffset>0x98</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x3FFFFF</resetValue>
                  <resetMask>0x3FFFFF</resetMask>
                  <fields>
                    <field>
                      <name>REG_TX_CFG_SFT_W_1</name>
                      <description>Tx AFE config shift register write</description>
                      <bitRange>[21:0]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>TX_AFE_CFG_SFT_W_2</name>
                  <description>Tx AFE configuration control shift write register #2</description>
                  <addressOffset>0x9C</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x3FFFFF</resetValue>
                  <resetMask>0x3FFFFF</resetMask>
                  <fields>
                    <field>
                      <name>REG_TX_CFG_SFT_W_2</name>
                      <description>Tx AFE config shift register write</description>
                      <bitRange>[21:0]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>TX_AFE_CFG_SFT_W_3</name>
                  <description>Tx AFE configuration control shift write register #3</description>
                  <addressOffset>0xA0</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x3FFFFF</resetValue>
                  <resetMask>0x3FFFFF</resetMask>
                  <fields>
                    <field>
                      <name>REG_TX_CFG_SFT_W_3</name>
                      <description>Tx AFE config shift register write</description>
                      <bitRange>[21:0]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>TX_AFE_CFG_SFT_W_4</name>
                  <description>Tx AFE configuration control shift write register #4</description>
                  <addressOffset>0xA4</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x3FFFFF</resetValue>
                  <resetMask>0x3FFFFF</resetMask>
                  <fields>
                    <field>
                      <name>REG_TX_CFG_SFT_W_4</name>
                      <description>Tx AFE config shift register write</description>
                      <bitRange>[21:0]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>TX_AFE_CFG_SFT_W_5</name>
                  <description>Tx AFE configuration control shift write register #5</description>
                  <addressOffset>0xA8</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x3FFFFF</resetValue>
                  <resetMask>0x3FFFFF</resetMask>
                  <fields>
                    <field>
                      <name>REG_TX_CFG_SFT_W_5</name>
                      <description>Tx AFE config shift register write</description>
                      <bitRange>[21:0]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>TX_AFE_CFG_SFT_W_6</name>
                  <description>Tx AFE configuration control shift write register #6</description>
                  <addressOffset>0xAC</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x3FFFFF</resetValue>
                  <resetMask>0x3FFFFF</resetMask>
                  <fields>
                    <field>
                      <name>REG_TX_CFG_SFT_W_6</name>
                      <description>Tx AFE config shift register write</description>
                      <bitRange>[21:0]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>TX_AFE_CFG_SFT_W_7</name>
                  <description>Tx AFE configuration control shift write register #7</description>
                  <addressOffset>0xB0</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x3FFFFF</resetValue>
                  <resetMask>0x3FFFFF</resetMask>
                  <fields>
                    <field>
                      <name>REG_TX_CFG_SFT_W_7</name>
                      <description>Tx AFE config shift register write</description>
                      <bitRange>[21:0]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>TX_AFE_CFG_SFT_R</name>
                  <description>Tx AFE configuration control shift read register for debug</description>
                  <addressOffset>0xB4</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFF</resetMask>
                  <fields>
                    <field>
                      <name>REG_TX_CFG_SFT_R</name>
                      <description>Tx AFE config shift register read for debug. Support only 1st register</description>
                      <bitRange>[7:0]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>ADC</name>
                  <description>Analog to Digital Converter register #0</description>
                  <addressOffset>0xC0</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x408000</resetValue>
                  <resetMask>0x3FFFFFFF</resetMask>
                  <fields>
                    <field>
                      <name>DAC_CNTRL</name>
                      <description>8-bit DAC Input. This register should be used if FW wants to control the ADC directly bypassing the SAR logic</description>
                      <bitRange>[7:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>MID_VAL</name>
                      <description>ADC starting mid value</description>
                      <bitRange>[15:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>LDO_TRIM</name>
                      <description>LDO trim : typ 1.15V, 1 percent step, 0.5 percent trim accuracy</description>
                      <bitRange>[19:16]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>LDO_EN</name>
                      <description>Enable LDO</description>
                      <bitRange>[20:20]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ISO_N</name>
                      <description>Output isolation control.  Active Low
0: All digital outputs are forced low</description>
                      <bitRange>[21:21]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>PD_LV</name>
                      <description>Block enable input
1 - All analog and DC paths cut off, outputs forced to known value
0 - Normal functionality</description>
                      <bitRange>[22:22]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DFT_MUXSEL</name>
                      <description>DFT control signal, active high
1 - DAC output is placed on dft_out</description>
                      <bitRange>[23:23]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VSEL</name>
                      <description>Comparator input voltage select:
000 - ana_in1 voltage (can be connected to a pad)
001 - ana_in2 voltage (can be connected to a pad)
010 - vbg voltage
011 - NPN voltage for temperature sensing
100-111: a&lt;0:3&gt;</description>
                      <bitRange>[26:24]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VREF_DAC_SEL</name>
                      <description>VREF DAC select:
00 - ldo output voltage
01 - vddio voltage
10 - vccd voltage
11 - N.A ( not connected)</description>
                      <bitRange>[28:27]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>SAR_EN</name>
                      <description>Setting this bit will enable the HW SAR logic.
Once the SAR_EN is one, Hardware will update the  SAR_OUT register after 8 cycles of clk_sar and clear this register.</description>
                      <bitRange>[29:29]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>ADC_STATUS</name>
                  <description>Analog to Digital Converter status register</description>
                  <addressOffset>0xC4</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFF01</resetMask>
                  <fields>
                    <field>
                      <name>CMP_OUT</name>
                      <description>ADC Comparator Output</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>SAR_OUT</name>
                      <description>ADC output resistance value
Stored 8-bit ADC value after the ID Pin voltage is sampled.</description>
                      <bitRange>[15:8]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PHYSS_LOOPBACK_CTRL_0</name>
                  <description>PHY Loopback control register #0</description>
                  <addressOffset>0xD4</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x77F</resetMask>
                  <fields>
                    <field>
                      <name>LOOPBACK_EN</name>
                      <description>Enable Loopback mode. This starts the loopback engine. First align symbols are generated and CDR is moved to lock to data mode after 256 clock cycles. After sufficient time is given for CDR to lock set LOOPBACK_START_PTTN to transition to the pattern phase</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>LOOPBACK_NO_AFE</name>
                      <description>When this bit is set, the loopback happens at the output of the PCS (Before the AFE)</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>LOOPBACK_START_PTTN</name>
                      <description>When Loopback is enabled, initially pattern generated for CDR lock - this data is ALIGN Symbol interpersed with PRS15 data. When this bit is set, the loopback engine transitions to the selected pattern</description>
                      <bitRange>[2:2]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>LOOPBACK_NO_8B_10B</name>
                      <description>When this bit is set and loopback is done in Gen1, 8B/10B encoding is bypassed</description>
                      <bitRange>[3:3]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>LOOPBACK_PTTN</name>
                      <description>Loopback Pattern
0: User pattern
1: 8bit incremental pattern
2: PRBS7
3: PRBS15
4: PRBS31
This field is not synchronized. This field should be set before Loopback is enabled and only changed after PHYSS_LOOPBACK_STATUS_1.LOOPBACK_DONE is set</description>
                      <bitRange>[6:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>LOOPBACK_NO_RX</name>
                      <description>This bit when set, allows the TX transmit to be turned on, but ignores all RX. This can be used to characterize the TX. PHYSS_LOOPBACK_STATUS_1 should be ignored</description>
                      <bitRange>[8:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>TX_ONE_ZERO</name>
                      <description>This bit when set, drives 10 pattern on the TX. This should be only set along with LOOPBACK_NO_RX. Should not be set independently</description>
                      <bitRange>[9:9]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>SAMPLE_RX_AFE_OUT</name>
                      <description>Setting this bit triggers a 64-bit sample of the RX AFE output to be captured. This bit is cleared by HW when the sample is stored. Sample available in PHYSS_LOOPBACK_DEBUG_1/2 registers</description>
                      <bitRange>[10:10]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PHYSS_LOOPBACK_DEBUG_0</name>
                  <description>PHY Loopback debug register #0</description>
                  <addressOffset>0xD8</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFFFFFFFF</resetMask>
                  <fields>
                    <field>
                      <name>RX_AFE_DATA_0</name>
                      <description>Data sampled at RX AFE output</description>
                      <bitRange>[31:0]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PHYSS_LOOPBACK_DEBUG_1</name>
                  <description>PHY Loopback debug register #1</description>
                  <addressOffset>0xDC</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFFFFFFFF</resetMask>
                  <fields>
                    <field>
                      <name>RX_AFE_DATA_1</name>
                      <description>Data sampled at RX AFE output</description>
                      <bitRange>[31:0]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PHYSS_LOOPBACK_STATUS_1</name>
                  <description>PHY Loopback status register #1</description>
                  <addressOffset>0xE0</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xF7FFFF</resetMask>
                  <fields>
                    <field>
                      <name>LOOPBACK_ERR_COUNT</name>
                      <description>Count of loopback Errors. Error monitoring is started only after Alignment is achieved. Alignment is available in INTR0.reg_int_loopback_lock. Read this register only after stopping LOOPBACK</description>
                      <bitRange>[15:0]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>LOOPBACK_STATUS</name>
                      <description>This field gets set when LOOPBACK_EN is cleared
0: LOOPBACK PASS
1: Alignment did not happen until LOOBACK_EN is cleared
2: errors seen after alignment
3: Error counter saturated</description>
                      <bitRange>[17:16]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>LOOPBACK_DONE</name>
                      <description>1: Loopback completed. Status reflected in LOOPBACK_STATUS</description>
                      <bitRange>[18:18]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>LOOPBACK_GEN_STATE</name>
                      <description>0 - IDLE State
1 - ALIGN State
2 - DATA State
3 - DONE (transitionary state - refer to DONE Interrupt instead)</description>
                      <bitRange>[21:20]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>LOOPBACK_CHK_STATE</name>
                      <description>0 - IDLE State
1 - ALIGN State
2 - DATA State
3 - DONE (transitionary state - refer to DONE Interrupt instead)</description>
                      <bitRange>[23:22]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PHYSS_LOOPBACK_USER_0</name>
                  <description>PHY Loopback user pattern register #0</description>
                  <addressOffset>0xE4</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFFFFFFFF</resetMask>
                  <fields>
                    <field>
                      <name>REG_LOOPBACK_USER_0</name>
                      <description>Loopback user pattern[31:0] register</description>
                      <bitRange>[31:0]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PHYSS_LOOPBACK_USER_1</name>
                  <description>PHY Loopback user pattern register #1</description>
                  <addressOffset>0xE8</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFFFFFFFF</resetMask>
                  <fields>
                    <field>
                      <name>REG_LOOPBACK_USER_1</name>
                      <description>Loopback user pattern[63:32] register</description>
                      <bitRange>[31:0]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PHYSS_DDFT_MUX_SEL</name>
                  <description>PHY DDFT selection</description>
                  <addressOffset>0xF0</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x7FFBFBF</resetMask>
                  <fields>
                    <field>
                      <name>DDFT0_SEL</name>
                      <description>DDFT0 mux selection
[43:42] TX DDFT output
[41:40] RX DDFT output
[39:38] PLL DDFT output
37 - ADC Comparator output
36 - G2 EB overflow
35 - G2 EB underflow
34 - curr 8b10b disparity
33 - RX locked
32 - RX aligned
31 - G1 EB overflow
30 - G1 EB underflow
29 - rx aligner stay_locked
28 - Hunt for rx alignment
27 - high speed data present in U0
26 - High speed data present
25 - MAsk LFPS detection
24 - Warm reset detected
23 - AFE Zcal comparator output
22 - RX present
21 - TX AFE RXDETECT output
20 - TX AFE pullup
19 - protocol loopback enable
18 - CDR lock to reference
17 - TX AFE hs clk drv enable
16 - TX AFE LFPS Enable
15 - TX Electilde
14 - TX Serializer enable
13 - P3
12 - P2
11 - P1
10 - P0
9 - P3 exit phy status
8 - P3 Enter phy status
7 - Pclk enable
6 - PIPE TX ELECIDLE
5 - PIPE - RX ELECIDLE
4 - PIPE - RX Termination
3 - PIPE - Rate bit 0
2 - PIPE - RX_EQ_TRAINING
1 - HS DDFT[1]
0 - HS DDFT[0]</description>
                      <bitRange>[5:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DDFT0_POLARITY</name>
                      <description>0: Non-inverted
1: Inverted</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DDFT1_SEL</name>
                      <description>DDFT1 mux selection
[43:42] TX DDFT output
[41:40] RX DDFT output
[39:38] PLL DDFT output
37 - ADC Comparator output
36 - G2 EB overflow
35 - G2 EB underflow
34 - curr 8b10b disparity
33 - RX locked
32 - RX aligned
31 - G1 EB overflow
30 - G1 EB underflow
29 - rx aligner stay_locked
28 - Hunt for rx alignment
27 - high speed data present in U0
26 - High speed data present
25 - MAsk LFPS detection
24 - Warm reset detected
23 - AFE Zcal comparator output
22 - RX present
21 - TX AFE RXDETECT output
20 - TX AFE pullup
19 - protocol loopback enable
18 - CDR lock to reference
17 - TX AFE hs clk drv enable
16 - TX AFE LFPS Enable
15 - TX Electilde
14 - TX Serializer enable
13 - P3
12 - P2
11 - P1
10 - P0
9 - P3 exit phy status
8 - P3 Enter phy status
7 - Pclk enable
6 - PIPE TX ELECIDLE
5 - PIPE - RX ELECIDLE
4 - PIPE - RX Termination
3 - PIPE - Rate bit 0
2 - PIPE - RX_EQ_TRAINING
1 - HS DDFT[1]
0 - HS DDFT[0]</description>
                      <bitRange>[13:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DDFT1_POLARITY</name>
                      <description>0: Non-inverted
1: Inverted</description>
                      <bitRange>[15:15]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>HS_DDFT_EN</name>
                      <description>DDFT output is available on TXP/TXN</description>
                      <bitRange>[16:16]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>HS_DDFT0_SEL</name>
                      <description>HS DDFT0 mux selection
[31:18] - 1'b0
17 - 1'b1
16 - Skip found
15 - G2 New alignment found
14 - rx_start_block
13 - rx_data_valid
12 - G2 Skip removal
11 -G2 Skip addition
10 - RX _ERROR
9- g1_skip_removal
8 - g1_skip_addition
7 - hs_data_error
6 - 8b10b_enc_disp
5 - 8b10b_enc_err_1
4 - 8b10b_ecn_err_0
3 - tx_data_valid
2 - tx_start_block
1-phy_status_rate_change
0 - clk_pclk</description>
                      <bitRange>[21:17]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>HS_DDFT1_SEL</name>
                      <description>HS DDFT1 mux selection
17 - 1'b1
16 - Skip found
15 - G2 New alignment found
14 - rx_start_block
13 - rx_data_valid
12 - G2 Skip removal
11 -G2 Skip addition
10 - RX _ERROR
9- g1_skip_removal
8 - g1_skip_addition
7 - hs_data_error
6 - 8b10b_enc_disp
5 - 8b10b_enc_err_1
4 - 8b10b_ecn_err_0
3 - tx_data_valid
2 - tx_start_block
1-phy_status_rate_change
0 - clk_pclk</description>
                      <bitRange>[26:22]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PIPE_RX_CTRL</name>
                  <description>Configuration for PIPE RX</description>
                  <addressOffset>0xF4</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x8F0000</resetValue>
                  <resetMask>0x1FFFFFFF</resetMask>
                  <fields>
                    <field>
                      <name>RSVD_CFG</name>
                      <description>N/A</description>
                      <bitRange>[15:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>HS_ERROR_DEBOUNCE</name>
                      <description>When exiting P0, the HS data errors are monitored to identify end of HS data. This register specifies the delay from the detection of HS data to when the HS data is considered OFF. 
Allowed values are 1-1F</description>
                      <bitRange>[20:16]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>HS_DATA_ALIGN</name>
                      <description>This register specifies the number of alignment patterns required to move to aligner locked state. The aligner will only exit from locked state on seeing HS_ERROR_DEBOUNCE data errors</description>
                      <bitRange>[25:21]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>FORCE_REALIGN</name>
                      <description>This bit will force the aligner out of Locked state to unaligned state. Clear and reset this bit to cause alignment</description>
                      <bitRange>[26:26]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>CDR_L2R_ON_POWER_MODE</name>
                      <description>This register bit indicates if the CDR lock 2 reference mode has to change on the power-mode signal or on detecting HS data errors. When entering low power mode, if HS data is still present on the RX lines, it could be identified spuriously as LFPS. To prevent this, the HS data is detected through HS Errors. This behaviour can be bypassed by setting this bit</description>
                      <bitRange>[27:27]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VCC_SEL_LFPS_DETECT</name>
                      <description>LFPS power supply select.</description>
                      <bitRange>[28:28]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>LOW_POWER_CTRL</name>
                  <description>Low Power configuration</description>
                  <addressOffset>0xF8</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x2F5000</resetValue>
                  <resetMask>0x7FFFFFF</resetMask>
                  <fields>
                    <field>
                      <name>LFPS_FILTER</name>
                      <description>This register specifies the valid LFPS to declare LFPS reception when in P0 power state. AFE LFPS output can toggle when HS data is present. This filter ignores SPURIOS LFPS toggles. The counter operates on the PERI clock domain - nominally 100MHz. Two modes are supported
P0_FILTER - The AFE output is filtered for programmed duration in high-speed data state. High Speed data is determined to be present when RX_EQ training is asserted and absent when high-speed data errors are detected in non-P0 state.
NON_P3_FILTER - The AFE output is filtered as long as the PERI clock is present. In U3, if Deepsleep is entered, the Filter has to be disabled</description>
                      <bitRange>[15:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>HW_CTRL_DELAY</name>
                      <description>CTLE/DFE/DESERIALIZER are turned on in P0 and turned off in P0 exit. This register specifies the delay from the power mode change to when these blocks are turned on/off. In PCLK cycles Allowed values 1 - 1F</description>
                      <bitRange>[20:16]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>LFPS_MASK_ON_TX_DATA</name>
                      <description>This config bit determines when the LFPS mask is applied in P0 state
0 - Mask applies as soon as P0 is entered
1 - Mask applies only after TX Data transmission starts in P0</description>
                      <bitRange>[21:21]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DISABLE_LFPS_FILTER</name>
                      <description>When the LFPS_FILTER valuye is updated, the FILTER has to be disabled</description>
                      <bitRange>[22:22]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>LFPS_FILTER_MODE</name>
                      <description>0 - P0_FILTER mode
1 - NON_P3_FILTER mode</description>
                      <bitRange>[23:23]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>FORCE_CDR_LOCK_TO_DATA</name>
                      <description>When this bit is set, the RX CDR moves to lock to data state</description>
                      <bitRange>[24:24]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>FORCE_CDR_LOCK_TO_REFERENCE</name>
                      <description>When this bit is set, the RX CDR moves to lock to reference state</description>
                      <bitRange>[25:25]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>BYPASS_FILTER_U3_WAKEUP</name>
                      <description>Setting this bit bypasses the 50ns Glitch filter on LFPS for U3 Wakeup</description>
                      <bitRange>[26:26]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>CDR_SW_CTRL</name>
                  <description>Configuration for CDR mode switching</description>
                  <addressOffset>0xFC</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0xC8000C8</resetValue>
                  <resetMask>0xFFFFFFF</resetMask>
                  <fields>
                    <field>
                      <name>L2D_START_DELAY</name>
                      <description>The CDR moves from Lock-2-reference mode to Lock-2-Data mode when P0 is entered. This delay controls  when the CDR transition happens w.r.t the P0 transition</description>
                      <bitRange>[19:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>L2R_START_DELAY</name>
                      <description>The CDR moves from Lock-2-Data to Lock-2-Reference when P0 is exited when PIPE_RX_CTRL.CDR_L2R_ON_POWER_MODE is set. This delay controls when the CDR transition happens w.r.t the P0 transition in this case</description>
                      <bitRange>[27:20]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
              </cluster>
              <cluster>
                <name>USB40PHY_RX</name>
                <description>PHY Rx registers</description>
                <addressOffset>0x00000800</addressOffset>
                <register>
                  <name>RX_SDM_CFG0</name>
                  <description>Sigma-Delta Modulator (SDM) Configuration</description>
                  <addressOffset>0x0</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0xCD</resetValue>
                  <resetMask>0xFF</resetMask>
                  <fields>
                    <field>
                      <name>DIVF_INTEGER</name>
                      <description>Feedback Divider Ratio integer vlaue (not required if SSM is present)</description>
                      <bitRange>[7:0]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_SDM_CFG1</name>
                  <description>Sigma-Delta Modulator (SDM) Configuration</description>
                  <addressOffset>0x4</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x5555</resetValue>
                  <resetMask>0xFFFF</resetMask>
                  <fields>
                    <field>
                      <name>DIVF_FRAC_MSB</name>
                      <description>Feedback Divider Ratio fractional vlaue (not required if SSM is used)</description>
                      <bitRange>[15:0]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_SDM_CFG2</name>
                  <description>Sigma-Delta Modulator (SDM) Configuration</description>
                  <addressOffset>0x8</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x1</resetValue>
                  <resetMask>0x3</resetMask>
                  <fields>
                    <field>
                      <name>DIVF_FRAC_LSB</name>
                      <description>Feedback Divider Ratio fractional vlaue (not required if SSM is used)</description>
                      <bitRange>[1:0]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_SDM_CFG3</name>
                  <description>Sigma-Delta Modulator (SDM) Configuration</description>
                  <addressOffset>0xC</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x1</resetValue>
                  <resetMask>0x1F</resetMask>
                  <fields>
                    <field>
                      <name>SDM_ENABLE</name>
                      <description>Sigma-Delta modulator enable, (active low power down), SSM will be down too</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DITHER_EN</name>
                      <description>Sigma-Delta Modulator dither enable</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DITHER_GAIN</name>
                      <description>Sigma-Delta Modulator dither gain, specifies number of dither bits</description>
                      <bitRange>[4:2]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_DFE_CFG0</name>
                  <description>DFE FSM (DFE) Configuration</description>
                  <addressOffset>0x10</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x4008</resetValue>
                  <resetMask>0xFF9F</resetMask>
                  <fields>
                    <field>
                      <name>OVRD_VGATAP</name>
                      <description>VGA tap Coefficient setting for override</description>
                      <bitRange>[4:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>OVRD_VGATAP_EN</name>
                      <description>VGA tap override enable</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>OVRD_DFETAP1</name>
                      <description>DFE tap 1 Coefficient setting for overrid</description>
                      <bitRange>[14:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>OVRD_DFETAP1_EN</name>
                      <description>DFE tap 1 override enable</description>
                      <bitRange>[15:15]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_DFE_CFG1</name>
                  <description>DFE FSM (DFE) Configuration</description>
                  <addressOffset>0x14</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x4040</resetValue>
                  <resetMask>0xFFFF</resetMask>
                  <fields>
                    <field>
                      <name>OVRD_DFETAP2</name>
                      <description>DFE tap 2 Coefficient setting for overrid</description>
                      <bitRange>[6:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>OVRD_DFETAP2_EN</name>
                      <description>DFE tap 2 override enable</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>OVRD_DFETAP3</name>
                      <description>DFE tap 3 Coefficient setting for overrid</description>
                      <bitRange>[14:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>OVRD_DFETAP3_EN</name>
                      <description>DFE tap 3 override enable</description>
                      <bitRange>[15:15]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_DFE_CFG2</name>
                  <description>DFE FSM (DFE) Configuration</description>
                  <addressOffset>0x18</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0xB79E</resetValue>
                  <resetMask>0xFFFF</resetMask>
                  <fields>
                    <field>
                      <name>DFE_SLICEPOINTVALUE</name>
                      <description>slice point value in error slicers, positive</description>
                      <bitRange>[5:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DFE_SLICEPOINTSIGN1</name>
                      <description>1: error slicer 1 has positive slice point; 0: negative</description>
                      <bitRange>[6:6]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DFE_SLICEPOINTSIGN2</name>
                      <description>1: error slicer 2 has positive slice point; 0: negative</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VGA_MU</name>
                      <description>mu/16 multiplier for VGA tap0 adaptation</description>
                      <bitRange>[11:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DFE_MU</name>
                      <description>mu/16 multiplier for DFE taps adaptation</description>
                      <bitRange>[15:12]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_DFE_CFG3</name>
                  <description>DFE FSM (DFE) Configuration</description>
                  <addressOffset>0x1C</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x3</resetValue>
                  <resetMask>0x7FFF</resetMask>
                  <fields>
                    <field>
                      <name>DFE_BAL_AVRG</name>
                      <description># of cycles averaging tap updates</description>
                      <bitRange>[2:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VGA_BALANCE_SCALE</name>
                      <description>Scaling for VGA adaptation balances when subtracting error/non_error cases</description>
                      <bitRange>[4:3]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DFE_BALANCE_SCALE</name>
                      <description>Scaling for DFE adaptation balances when subtracting error/non_error cases</description>
                      <bitRange>[6:5]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VGA_POLARITY</name>
                      <description>VGA tap polarity swapping, default 0</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DFE_POLARITY</name>
                      <description>DFE taps polarity swapping, default 0</description>
                      <bitRange>[8:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VGA_ADAPT_EN</name>
                      <description>VGA adaptation enable, active high</description>
                      <bitRange>[9:9]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DFE_ENABLE</name>
                      <description>DFE adaptation enable, active high</description>
                      <bitRange>[10:10]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VGA_FREEZE</name>
                      <description>freeze VGA adaptation with present values</description>
                      <bitRange>[11:11]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DFE_FREEZE</name>
                      <description>freeze DFE adaptation with all present values</description>
                      <bitRange>[12:12]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DFE_QUALIFIER_INV</name>
                      <description>Bits invertion for the qualifier bits</description>
                      <bitRange>[13:13]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DFE_RESETB</name>
                      <description>DFE FSM reset, active low, reinitializes everything</description>
                      <bitRange>[14:14]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_DFE_STAT0</name>
                  <description>DFE FSM (DFE) status</description>
                  <addressOffset>0x20</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x7F1F</resetMask>
                  <fields>
                    <field>
                      <name>VGATAP</name>
                      <description>VGA tap, gain control (Note, Dynamic async to CSR clock, need sync or being frozen for read)</description>
                      <bitRange>[4:0]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>DFETAP1</name>
                      <description>DFE tap 1 DAC input (Note, Dynamic async to CSR clock, need sync or being frozen for read)</description>
                      <bitRange>[14:8]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_DFE_STAT1</name>
                  <description>DFE FSM (DFE) status</description>
                  <addressOffset>0x24</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x7F7F</resetMask>
                  <fields>
                    <field>
                      <name>DFETAP2</name>
                      <description>DFE tap 2 DAC input (Note, Dynamic async to CSR clock, need sync or being frozen for read)</description>
                      <bitRange>[6:0]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>DFETAP3</name>
                      <description>DFE tap 3 DAC input (Note, Dynamic async to CSR clock, need sync or being frozen for read)</description>
                      <bitRange>[14:8]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_DFE_STAT2</name>
                  <description>DFE FSM (DFE) status</description>
                  <addressOffset>0x28</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x7F7F</resetMask>
                  <fields>
                    <field>
                      <name>ERRSLIC1DELTA</name>
                      <description>Error slicer 1 offset+(sign)delta</description>
                      <bitRange>[6:0]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>ERRSLIC2DELTA</name>
                      <description>Error slicer 2 offset+(sign)delta</description>
                      <bitRange>[14:8]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_OSA_CFG0</name>
                  <description>Offset Calibration FSM (OSA) Configuration</description>
                  <addressOffset>0x2C</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x4040</resetValue>
                  <resetMask>0xFFFF</resetMask>
                  <fields>
                    <field>
                      <name>OVRD_EDGSLICE1OS</name>
                      <description>Edge slicer 1 offset adjustment override</description>
                      <bitRange>[6:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>OVRD_EDGSLICE1OS_EN</name>
                      <description>Edge slicer 1 offset adjustment override enable</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>OVRD_EDGSLICE2OS</name>
                      <description>Edge slicer 2 offset adjustment override</description>
                      <bitRange>[14:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>OVRD_EDGSLICE2OS_EN</name>
                      <description>Edge slicer 2 offset adjustment override enable</description>
                      <bitRange>[15:15]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_OSA_CFG1</name>
                  <description>Offset Calibration FSM (OSA) Configuration</description>
                  <addressOffset>0x30</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x4040</resetValue>
                  <resetMask>0xFFFF</resetMask>
                  <fields>
                    <field>
                      <name>OVRD_DATSLICE1OS</name>
                      <description>Data slicer 1 offset adjustment override</description>
                      <bitRange>[6:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>OVRD_DATSLICE1OS_EN</name>
                      <description>Data slicer 1 offset adjustment override enable</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>OVRD_DATSLICE2OS</name>
                      <description>Data slicer 2 offset adjustment override</description>
                      <bitRange>[14:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>OVRD_DATSLICE2OS_EN</name>
                      <description>Data slicer 2 offset adjustment override enable</description>
                      <bitRange>[15:15]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_OSA_CFG2</name>
                  <description>Offset Calibration FSM (OSA) Configuration</description>
                  <addressOffset>0x34</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x4040</resetValue>
                  <resetMask>0xFFFF</resetMask>
                  <fields>
                    <field>
                      <name>OVRD_ERRSLICE1OS</name>
                      <description>Error slicer 1 offset adjustment override</description>
                      <bitRange>[6:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>OVRD_ERRSLICE1OS_EN</name>
                      <description>Error slicer 1 offset adjustment override enable</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>OVRD_ERRSLICE2OS</name>
                      <description>Error slicer 2 offset adjustment override</description>
                      <bitRange>[14:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>OVRD_ERRSLICE2OS_EN</name>
                      <description>Error slicer 2 offset adjustment override enable</description>
                      <bitRange>[15:15]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_OSA_CFG3</name>
                  <description>Offset Calibration FSM (OSA) Configuration</description>
                  <addressOffset>0x38</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x4040</resetValue>
                  <resetMask>0xFFFF</resetMask>
                  <fields>
                    <field>
                      <name>OVRD_ROAMSLICE1OS</name>
                      <description>Roam slicer 1 offset adjustment override</description>
                      <bitRange>[6:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>OVRD_ROAMSLICE1OS_EN</name>
                      <description>Roam slicer 1 offset adjustment override enable</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>OVRD_ROAMSLICE2OS</name>
                      <description>Roam slicer 2 offset adjustment override</description>
                      <bitRange>[14:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>OVRD_ROAMSLICE2OS_EN</name>
                      <description>Roam slicer 2 offset adjustment override enable</description>
                      <bitRange>[15:15]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_OSA_CFG4</name>
                  <description>Offset Calibration FSM (OSA) Configuration</description>
                  <addressOffset>0x3C</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x40</resetValue>
                  <resetMask>0xFF</resetMask>
                  <fields>
                    <field>
                      <name>OVRD_AFEOSDAC</name>
                      <description>AFE offset adjustment override</description>
                      <bitRange>[6:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>OVRD_AFEOSDAC_EN</name>
                      <description>AFE offset adjustment override enable</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_OSA_CFG5</name>
                  <description>Offset Calibration FSM (OSA) Configuration</description>
                  <addressOffset>0x40</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x3FF</resetMask>
                  <fields>
                    <field>
                      <name>OSA_DFE_START</name>
                      <description>DFE offset calibration start, AFE calibration will follow</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>OSA_AFE_START</name>
                      <description>AFE offset calibration on demand start</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>OSA_RESETB</name>
                      <description>AFE offset calibration block reset, active low</description>
                      <bitRange>[2:2]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>OSA_ALL_DONE_OVRD</name>
                      <description>AFE offset calibration all done signal override</description>
                      <bitRange>[3:3]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>OSA_ERROR_BITS_MASK</name>
                      <description>Mask bits for osa error, active high</description>
                      <bitRange>[7:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>OSA_DFE_POLARITY</name>
                      <description>Polarity inversion for offset setting of slicers</description>
                      <bitRange>[8:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>OSA_AFE_POLARITY</name>
                      <description>Polarity inversion for offset setting of AFE</description>
                      <bitRange>[9:9]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_OSA_STAT0</name>
                  <description>Offset Calibration FSM (OSA) status</description>
                  <addressOffset>0x44</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x7F7F</resetMask>
                  <fields>
                    <field>
                      <name>EDGSLICE1OS</name>
                      <description>Edge slicer 1 adjusted offset</description>
                      <bitRange>[6:0]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>EDGSLICE2OS</name>
                      <description>Edge slicer 2 adjusted offset</description>
                      <bitRange>[14:8]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_OSA_STAT1</name>
                  <description>Offset Calibration FSM (OSA) status</description>
                  <addressOffset>0x48</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x7F7F</resetMask>
                  <fields>
                    <field>
                      <name>DATSLICE1OS</name>
                      <description>Edge slicer 1 adjusted offset</description>
                      <bitRange>[6:0]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>DATSLICE2OS</name>
                      <description>Edge slicer 2 adjusted offset</description>
                      <bitRange>[14:8]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_OSA_STAT2</name>
                  <description>Offset Calibration FSM (OSA) status</description>
                  <addressOffset>0x4C</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x7F7F</resetMask>
                  <fields>
                    <field>
                      <name>ERRSLICE1OS</name>
                      <description>Error slicer 1 adjusted offset</description>
                      <bitRange>[6:0]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>ERRSLICE2OS</name>
                      <description>Error slicer 2 adjusted offset</description>
                      <bitRange>[14:8]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_OSA_STAT3</name>
                  <description>Offset Calibration FSM (OSA) status</description>
                  <addressOffset>0x50</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x7F7F</resetMask>
                  <fields>
                    <field>
                      <name>ROAMSLICE1OS</name>
                      <description>Roam slicer 1 adjusted offset</description>
                      <bitRange>[6:0]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>ROAMSLICE2OS</name>
                      <description>Roam slicer 2 adjusted offset</description>
                      <bitRange>[14:8]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_OSA_STAT4</name>
                  <description>Offset Calibration FSM (OSA) status</description>
                  <addressOffset>0x54</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x7F</resetMask>
                  <fields>
                    <field>
                      <name>AFEOSDAC</name>
                      <description>AFE adjusted offset</description>
                      <bitRange>[6:0]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_OSA_STAT5</name>
                  <description>Offset Calibration FSM (OSA) status</description>
                  <addressOffset>0x58</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x77</resetMask>
                  <fields>
                    <field>
                      <name>OSA_DFE_DONE</name>
                      <description>Offset calibration for DFE blocks (summer+slicer) is completed</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>OSA_AFE_DONE</name>
                      <description>Offset calibration for AFE Blocks (AGC+CTLE) is completed</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>OSA_ALL_DONE</name>
                      <description>All offset calibrations are completed</description>
                      <bitRange>[2:2]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>OSA_DFE_ERROR</name>
                      <description>There has been some error during offset calibration for DFE blocks</description>
                      <bitRange>[4:4]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>OSA_AFE_ERROR</name>
                      <description>There has been some error during offset calibration for AFE blocks</description>
                      <bitRange>[5:5]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>OSA_ERROR</name>
                      <description>There has been some error during offset calibration for one the blocks, output as interupt, read specific error at osa_err_bits#.</description>
                      <bitRange>[6:6]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_OSA_STAT6</name>
                  <description>Offset Calibration FSM (OSA) status</description>
                  <addressOffset>0x5C</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFFFF</resetMask>
                  <fields>
                    <field>
                      <name>OSA_ERR_BITS0</name>
                      <description>Error bits indicating what went wrong in which block
osa_err_bits0[3:0] - Data slicer1 errors, osa_err_bits[7:4] - Data slicer2 errors
osa_err_bits0[11:8] - Error slicer1 errors, osa_err_bits[15:12] - Error slicer2 errors
Bit0:	Measured offset is less than low limit
Bit1:	Offset adjustment value reached zero during sweep down
Bit2:	Measured offset is more than high limit
Bit3:	Offset adjustment value reached full scale (127) during sweep up</description>
                      <bitRange>[15:0]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_OSA_STAT7</name>
                  <description>Offset Calibration FSM (OSA) status</description>
                  <addressOffset>0x60</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFFFF</resetMask>
                  <fields>
                    <field>
                      <name>OSA_ERR_BITS1</name>
                      <description>Error bits indicating what went wrong in which block
osa_err_bits1[3:0] - Edge slicer1 errors, osa_err_bits[7:4] - Edge slicer2 errors
osa_err_bits1[11:8] - Roam slicer1 errors, osa_err_bits[15:12] - Roam slicer2 errors
Bit0/1/2/3 &amp; 8/9/10/11 - have same descriptions as mentioned in RX_OSA_STAT6</description>
                      <bitRange>[15:0]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_OSA_STAT8</name>
                  <description>Offset Calibration FSM (OSA) status</description>
                  <addressOffset>0x64</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xF</resetMask>
                  <fields>
                    <field>
                      <name>OSA_ERR_BITS2</name>
                      <description>Error bits indicating what went wrong in which block
osa_err_bits2[3:0] - AFE errors
Bit0/1/2/3 - explanations are mentioned in RX_OSA_STAT6</description>
                      <bitRange>[3:0]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_CTLE_CFG0</name>
                  <description>CTLE controls Configuration</description>
                  <addressOffset>0x68</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x400</resetValue>
                  <resetMask>0x1F03</resetMask>
                  <fields>
                    <field>
                      <name>CTLE_EYEHT_EN</name>
                      <description>Enable eye hieght measurement for CTLE adaptation</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>EYEHT_START_CNT</name>
                      <description>Start error count for CTLE adaptation</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>CTLE_STG1_CMADJ</name>
                      <description>Adjust CTLE cap values for desired EQ</description>
                      <bitRange>[10:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>CTLE_CAP_FZERO_EN</name>
                      <description>Adjust CTLE resistor values for desired EQ</description>
                      <bitRange>[11:11]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>CTLE_CAP_GAIN_ADJ</name>
                      <description>CTLE gain setting through the capacitor voltage divider, fix setting at initialization of CTLE and not part of the vga adaptation</description>
                      <bitRange>[12:12]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_CTLE_CFG1</name>
                  <description>CTLE controls Configuration</description>
                  <addressOffset>0x6C</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x808</resetValue>
                  <resetMask>0xFFFF</resetMask>
                  <fields>
                    <field>
                      <name>CTLE_STG1RES</name>
                      <description>Adjust CTLE stage 1 resistor value</description>
                      <bitRange>[3:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>CTLE_STG1CAP</name>
                      <description>Adjust CTLE stage 1 cap value</description>
                      <bitRange>[6:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>CTLE_STG1BOOST</name>
                      <description>CTLE stage 1 boost</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>CTLE_STG2RES</name>
                      <description>Adjust CTLE stage 2 resistor value</description>
                      <bitRange>[11:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>CTLE_STG2CAP</name>
                      <description>Adjust CTLE stage 2 cap value</description>
                      <bitRange>[14:12]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>CTLE_STG2BOOST</name>
                      <description>CTLE stage 2 boost</description>
                      <bitRange>[15:15]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_CTLE_STAT0</name>
                  <description>CTLE controls status</description>
                  <addressOffset>0x70</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFFFF</resetMask>
                  <fields>
                    <field>
                      <name>EYEHT_ERR_CNT</name>
                      <description>Error count for CTLE adaptation</description>
                      <bitRange>[15:0]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_CTLE_STAT1</name>
                  <description>CTLE controls status</description>
                  <addressOffset>0x74</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x1</resetMask>
                  <fields>
                    <field>
                      <name>EYEHT_CNT_DONE</name>
                      <description>Error count for CTLE adaptation is done</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_EM_CFG0</name>
                  <description>Eye monitor FSM (EM) Configuration</description>
                  <addressOffset>0x78</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFFFF</resetMask>
                  <fields>
                    <field>
                      <name>EYE_WORD_CNT</name>
                      <description>eye word count</description>
                      <bitRange>[2:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DATA_SAMPLE_DELAY</name>
                      <description>data sample delay</description>
                      <bitRange>[5:3]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ROAM_SAMPLE_DELAY</name>
                      <description>roam sample delay</description>
                      <bitRange>[8:6]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>EM_CTRL_UNUSED</name>
                      <description>unused control bits</description>
                      <bitRange>[11:9]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>EN_EYE_ODD</name>
                      <description>enable odd eye</description>
                      <bitRange>[12:12]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>EN_EYE_EVEN</name>
                      <description>enable even eye</description>
                      <bitRange>[13:13]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>START_COUNT</name>
                      <description>Start count command for eye monitor controller</description>
                      <bitRange>[14:14]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>EN_EYEMON</name>
                      <description>Enable eye monotor controller and analog related circuitry</description>
                      <bitRange>[15:15]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_EM_CFG1</name>
                  <description>Eye monitor FSM (EM) Configuration</description>
                  <addressOffset>0x7C</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x80</resetValue>
                  <resetMask>0xFFFF</resetMask>
                  <fields>
                    <field>
                      <name>ROAM_SLICEPOINT</name>
                      <description>roam slicer 1 &amp; 2 slice point amplitude</description>
                      <bitRange>[5:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ROAM_SLICEPOINTSIGN1</name>
                      <description>roam slicer 1 slicepoint, 1:positive, 0:negative</description>
                      <bitRange>[6:6]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ROAM_SLICEPOINTSIGN2</name>
                      <description>roam slicer 2 slicepoint, 1:positive, 0:negative</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>PIROAMPSEL</name>
                      <description>roam phase interpolator value</description>
                      <bitRange>[14:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>PIROAMPSEL_EN</name>
                      <description>roam phase interpolator enable</description>
                      <bitRange>[15:15]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_EM_STAT0</name>
                  <description>Eye monitor FSM (EM) status</description>
                  <addressOffset>0x80</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFFFF</resetMask>
                  <fields>
                    <field>
                      <name>EYE_ERROR</name>
                      <description>Eye information output (place holder if required)</description>
                      <bitRange>[15:0]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_EM_STAT1</name>
                  <description>Eye monitor FSM (EM) status</description>
                  <addressOffset>0x84</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFFFD</resetMask>
                  <fields>
                    <field>
                      <name>EYE_DONE</name>
                      <description>eye monitor on going count cycle initiated by start_count is completed</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>RX_ROAMSLIC1OS</name>
                      <description>roam slicer 1 offset (offset null + slicepoint)</description>
                      <bitRange>[8:2]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>RX_ROAMSLIC2OS</name>
                      <description>roam slicer 2 offset (offset null + slicepoint)</description>
                      <bitRange>[15:9]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_DFEA_CFG0</name>
                  <description>DFE Analog Configuration</description>
                  <addressOffset>0x88</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x4444</resetValue>
                  <resetMask>0xFFFF</resetMask>
                  <fields>
                    <field>
                      <name>DFEMAINADJ</name>
                      <description>Adjust summer tail current</description>
                      <bitRange>[2:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DFE_PDB</name>
                      <description>DFE main power down, active low</description>
                      <bitRange>[3:3]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DFETAP1ADJ</name>
                      <description>Adjust DFE tap1 weight</description>
                      <bitRange>[6:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DFETAP1_PDB</name>
                      <description>DFE tap1 power down, active low</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DFETAP2ADJ</name>
                      <description>Adjust DFE tap2 weight</description>
                      <bitRange>[10:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DFETAP2_PDB</name>
                      <description>DFE tap1 power down, active low</description>
                      <bitRange>[11:11]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DFETAP3ADJ</name>
                      <description>Adjust DFE tap3 weight</description>
                      <bitRange>[14:12]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DFETAP3_PDB</name>
                      <description>DFE tap1 power down, active low</description>
                      <bitRange>[15:15]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_OSAA_CFG0</name>
                  <description>Offset Calibration Analog Configuration</description>
                  <addressOffset>0x8C</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x4FFF</resetValue>
                  <resetMask>0x7FFF</resetMask>
                  <fields>
                    <field>
                      <name>ADJEDGESLIC1</name>
                      <description>Adjust edge slicer 1 offset DAC full scale range</description>
                      <bitRange>[2:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ADJEDGESLIC2</name>
                      <description>Adjust edge slicer 2 offset DAC full scale range</description>
                      <bitRange>[5:3]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ADJDATSLIC1</name>
                      <description>Adjust data slicer 1 offset DAC full scale range</description>
                      <bitRange>[8:6]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ADJDATSLIC2</name>
                      <description>Adjust dara slicer 2 offset DAC full scale range</description>
                      <bitRange>[11:9]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ADJERRSLIC1</name>
                      <description>Adjust error slicer 1 offset DAC full scale range</description>
                      <bitRange>[14:12]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_OSAA_CFG1</name>
                  <description>Offset Calibration Analog Configuration</description>
                  <addressOffset>0x90</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x524</resetValue>
                  <resetMask>0xFFF</resetMask>
                  <fields>
                    <field>
                      <name>ADJERRSLIC2</name>
                      <description>Adjust error slicer 2 offset DAC full scale range</description>
                      <bitRange>[2:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ADJROAMSLIC1</name>
                      <description>Adjust roam slicer 1 offset DAC full scale range</description>
                      <bitRange>[5:3]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ADJROAMSLIC2</name>
                      <description>Adjust roam slicer 2 offset DAC full scale range</description>
                      <bitRange>[8:6]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>AFEOSBIASADJ</name>
                      <description>Adjust AFE offset DAC full scale range</description>
                      <bitRange>[11:9]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_AFE_CFG</name>
                  <description>Analog Front End (AFE) Configuration</description>
                  <addressOffset>0x94</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x104</resetValue>
                  <resetMask>0x3FF</resetMask>
                  <fields>
                    <field>
                      <name>CMADJ</name>
                      <description>Adjusts input common-mode voltage</description>
                      <bitRange>[2:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>TERM_EN</name>
                      <description>Enable for 50 Ohm (nominal) termination</description>
                      <bitRange>[3:3]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>TERM_TRIM_CFG</name>
                      <description>value of term_trim input from processor</description>
                      <bitRange>[8:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>LPBK_EN</name>
                      <description>Loopback path enable</description>
                      <bitRange>[9:9]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_EMA_CFG</name>
                  <description>Eye Monitor Analog Configuration</description>
                  <addressOffset>0x98</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x17</resetMask>
                  <fields>
                    <field>
                      <name>PICAPSEL</name>
                      <description>Phase Interpolator cap select</description>
                      <bitRange>[2:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>PI_PDB</name>
                      <description>Eye monitor phase interpolator powe down</description>
                      <bitRange>[4:4]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_REFCKSEL_CFG</name>
                  <description>Reference Clock Select (REFCLKSEL) Configuration</description>
                  <addressOffset>0x9C</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x1</resetMask>
                  <fields>
                    <field>
                      <name>LOCK2REF_SEL</name>
                      <description>Reference Clock MUX Select between 25 or 100 MHz</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_DIVH_CFG</name>
                  <description>HS Divider (DIVH) Configuration</description>
                  <addressOffset>0xA0</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x11F</resetMask>
                  <fields>
                    <field>
                      <name>RECCLK_DIVH</name>
                      <description>DIVH Divider Ratio, HSREF Clock</description>
                      <bitRange>[4:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>RECCLK_EN</name>
                      <description>High-Speed Ref Clk Output Enable</description>
                      <bitRange>[8:8]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_PFD_CFG</name>
                  <description>Phase/Frequency Detector (PFD) Configuration</description>
                  <addressOffset>0xA4</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x8</resetValue>
                  <resetMask>0xF</resetMask>
                  <fields>
                    <field>
                      <name>PFDDELAY</name>
                      <description>Adjust dead-zone feedback delay</description>
                      <bitRange>[3:0]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_CP_CFG</name>
                  <description>Charge Pump (CP) Configuration</description>
                  <addressOffset>0xA8</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x55</resetValue>
                  <resetMask>0x77</resetMask>
                  <fields>
                    <field>
                      <name>IPUP_ADJ</name>
                      <description>Charge pump up current adjustment</description>
                      <bitRange>[2:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>IPDN_ADJ</name>
                      <description>Charge pump down current adjustment</description>
                      <bitRange>[6:4]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_LF_CFG</name>
                  <description>Loop Filter (LF) Configuration</description>
                  <addressOffset>0xAC</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x3</resetMask>
                  <fields>
                    <field>
                      <name>LPF_ADJ</name>
                      <description>Loop filter adjustment</description>
                      <bitRange>[1:0]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_BIASGEN_CFG0</name>
                  <description>Bias Generator (BIASGEN) Configuration</description>
                  <addressOffset>0xB0</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x924</resetValue>
                  <resetMask>0xFFF</resetMask>
                  <fields>
                    <field>
                      <name>AFEBIASSET0</name>
                      <description>Adjust bias for stages of AFE/CTLE  - LSb</description>
                      <bitRange>[11:0]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_BIASGEN_CFG1</name>
                  <description>Bias Generator (BIASGEN) Configuration</description>
                  <addressOffset>0xB4</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x2424</resetValue>
                  <resetMask>0x7F3F</resetMask>
                  <fields>
                    <field>
                      <name>AFEBIASSET1</name>
                      <description>Adjust bias for stages of AFE/CTLE - Msb</description>
                      <bitRange>[5:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>CFG_BIAS</name>
                      <description>Adjust bias currents</description>
                      <bitRange>[13:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>BIAS_PDB</name>
                      <description>Bias power down, active low</description>
                      <bitRange>[14:14]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_GNRL_CFG</name>
                  <description>General Controls Configuration</description>
                  <addressOffset>0xB8</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x3</resetValue>
                  <resetMask>0x3FFF</resetMask>
                  <fields>
                    <field>
                      <name>BUS_BIT_MODE</name>
                      <description>RX output data bus width mose, 0:16, 1:20, 2:32, 3:40</description>
                      <bitRange>[1:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DESERRESETB</name>
                      <description>De-serializer reset, active low</description>
                      <bitRange>[2:2]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DATA_RATE</name>
                      <description>0: 10G half rate, 1:5G full rate</description>
                      <bitRange>[3:3]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>CLKGEN_PDB</name>
                      <description>Clock generation loop (PD+CP+VCO,etc.) powerdown, active low</description>
                      <bitRange>[4:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>LOWPWR</name>
                      <description>AFE low power mode for 5 Gb/s data rate</description>
                      <bitRange>[5:5]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ERR_PATH_EN</name>
                      <description>DFE error path clocking enable, active high</description>
                      <bitRange>[6:6]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ROM_PATH_EN</name>
                      <description>DFE roam path clocking enable, power down</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>EDGE_DESER_EN</name>
                      <description>Edge deserializer power down</description>
                      <bitRange>[8:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>SUMEVN_PDB</name>
                      <description>DFE even path summer power down</description>
                      <bitRange>[9:9]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>SUMODD_PDB</name>
                      <description>DFE odd path summer power down</description>
                      <bitRange>[10:10]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>SUMVDD_PULLDOWN</name>
                      <description>Summers output pull down</description>
                      <bitRange>[11:11]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VCO_ADJ</name>
                      <description>VCO range adjust bit</description>
                      <bitRange>[12:12]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>CLKINV</name>
                      <description>Invert phase of pclk</description>
                      <bitRange>[13:13]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_VREG_CFG0</name>
                  <description>Regulators Configuration</description>
                  <addressOffset>0xBC</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x7777</resetValue>
                  <resetMask>0xFFFF</resetMask>
                  <fields>
                    <field>
                      <name>VCPREGSEL</name>
                      <description>RX CP regulated supply voltage select</description>
                      <bitRange>[3:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VREGRXASEL</name>
                      <description>RX analog regulated supply voltage select</description>
                      <bitRange>[7:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VREGRXCKSEL</name>
                      <description>RX clock regulated supply voltage select</description>
                      <bitRange>[11:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VREGRXDSEL</name>
                      <description>RX digital regulated supply voltage select</description>
                      <bitRange>[15:12]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_VREG_CFG1</name>
                  <description>Regulators Configuration</description>
                  <addressOffset>0xC0</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x7F</resetMask>
                  <fields>
                    <field>
                      <name>VCPREG_PDB</name>
                      <description>charg-pump voltage supply power down, active low</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VREGRXA_PDB</name>
                      <description>RX analog regulated supply power down, active low</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VREGRXCK_PDB</name>
                      <description>RX clock regulated supply power down, active low</description>
                      <bitRange>[2:2]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VREGRXD_PDB</name>
                      <description>RX digital regulated supply power down, active low</description>
                      <bitRange>[3:3]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VCPREG_BPB</name>
                      <description>RX regulator charge pump bypass, active low</description>
                      <bitRange>[4:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>CPCLK_SEL</name>
                      <description>Clock select for Charge pump</description>
                      <bitRange>[5:5]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>BURNIN_EN</name>
                      <description>Enable Burn-In mode</description>
                      <bitRange>[6:6]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_VREG_STAT</name>
                  <description>Regulators Status</description>
                  <addressOffset>0xC4</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x7</resetMask>
                  <fields>
                    <field>
                      <name>POWER_GOOD_RXA</name>
                      <description>pwr_good_rxa for read as status</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>POWER_GOOD_RXCK</name>
                      <description>pwr_good_rxck for read as status</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>POWER_GOOD_RXD</name>
                      <description>pwr_good_rxd for read as status</description>
                      <bitRange>[2:2]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_SD_CFG</name>
                  <description>Signal detect/LFPS Configuration</description>
                  <addressOffset>0xC8</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x4</resetValue>
                  <resetMask>0xF</resetMask>
                  <fields>
                    <field>
                      <name>LFPS_VTH</name>
                      <description>LFPS threshold levels setting</description>
                      <bitRange>[2:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>LFPSDET_PDB</name>
                      <description>LFPS detect power down (active low)</description>
                      <bitRange>[3:3]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_SD_STAT</name>
                  <description>Signal detect/LFPS Status</description>
                  <addressOffset>0xCC</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x1</resetMask>
                  <fields>
                    <field>
                      <name>LFPSDET_OUT</name>
                      <description>LFPS output detected for read as status</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_LD_CFG</name>
                  <description>Lock Detect Configuration</description>
                  <addressOffset>0xD0</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x31</resetValue>
                  <resetMask>0xFF7</resetMask>
                  <fields>
                    <field>
                      <name>LOCKIN</name>
                      <description>Frequency detect tolerance = +/- 0.025 percent*2^lockin</description>
                      <bitRange>[2:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>FLOCKSEL</name>
                      <description>Filtered lock, #of refcklk cycles flock generated after lock  [2^(flocksel+8)]</description>
                      <bitRange>[5:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>LOCKOUTSEL</name>
                      <description>Lockup detect timer setting, cycles of refclk, 256 or 512</description>
                      <bitRange>[6:6]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>LUDDISABLE</name>
                      <description>Lockup detect disable</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>FD_OVRD</name>
                      <description>Force combinations of freq detect and ph detect en</description>
                      <bitRange>[9:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>RESETLOCKB</name>
                      <description>lock detect lock output reset, active low, will not activate lockup detect</description>
                      <bitRange>[10:10]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>LD_RESETB</name>
                      <description>lock detect main reset, active low</description>
                      <bitRange>[11:11]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_LD_STAT</name>
                  <description>Lock Detect Status</description>
                  <addressOffset>0xD4</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x1</resetMask>
                  <fields>
                    <field>
                      <name>PLL_LOCKED</name>
                      <description>flock for read as status</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_DFE_CFG4</name>
                  <description>DFE FSM (DFE) Configuration</description>
                  <addressOffset>0xD8</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x28</resetValue>
                  <resetMask>0xFF</resetMask>
                  <fields>
                    <field>
                      <name>INIT_VGATAP_VALUE</name>
                      <description>VGA tap initial adaptation start value</description>
                      <bitRange>[4:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>TAP_UPDATE_TRSHLD</name>
                      <description>threshold value for tap updates</description>
                      <bitRange>[7:5]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_HDWR_ENABLE</name>
                  <description>Configuration for hardware enable</description>
                  <addressOffset>0xDC</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x3F</resetMask>
                  <fields>
                    <field>
                      <name>CTLE_HDWR_ENABLE</name>
                      <description>Hardware control enable for AFE (CTLE+VGA) power down</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DFE_HDWR_ENABLE</name>
                      <description>N/A</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DESER_HDWR_ENABLE</name>
                      <description>Hardware control enable for deser reset</description>
                      <bitRange>[2:2]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>CDR_HDWR_ENABLE</name>
                      <description>Hardware control enable for holding CDR in lock-to-reference mode</description>
                      <bitRange>[3:3]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>SPARE_HDWR_ENABLE</name>
                      <description>Hardware control enable spare bits</description>
                      <bitRange>[5:4]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_ATEST_CFG</name>
                  <description>Analog Test Mux (ATEST) Configuration</description>
                  <addressOffset>0xE0</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFF3F</resetMask>
                  <fields>
                    <field>
                      <name>ADFT_CNTL</name>
                      <description>Analog test MUX Select</description>
                      <bitRange>[3:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ADFT_ENABLE</name>
                      <description>Analog test MUX Enable</description>
                      <bitRange>[4:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ADFT_IB20U_SEL</name>
                      <description>Analog test MUX ibias select</description>
                      <bitRange>[5:5]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ADFT_DAC_TEST</name>
                      <description>Analog test DAC current measurment</description>
                      <bitRange>[11:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ADFT_DFE_TEST</name>
                      <description>Analog test DFE taps current measurment</description>
                      <bitRange>[14:12]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ADFT_VREGDIV_EN</name>
                      <description>Analog test regulators output measurment, enables regulators ouputs resistive voltage divider</description>
                      <bitRange>[15:15]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>RX_DTEST_CFG</name>
                  <description>Digital Test Mux (DTEST) Configuration</description>
                  <addressOffset>0xE4</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xBF3F</resetMask>
                  <fields>
                    <field>
                      <name>DDFT0_SEL</name>
                      <description>Digital test MUX0 Select</description>
                      <bitRange>[5:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DDFT1_SEL</name>
                      <description>Digital test MUX1 Select</description>
                      <bitRange>[13:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DDFT_ENABLE</name>
                      <description>Digital test MUX Enable</description>
                      <bitRange>[15:15]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>SPARE_CFG</name>
                  <description>Spare Configuration</description>
                  <addressOffset>0xE8</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFFFF</resetMask>
                  <fields>
                    <field>
                      <name>SPARE_OUT</name>
                      <description>spare output pins</description>
                      <bitRange>[2:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>SPARE_FT_OUT</name>
                      <description>spare feedthrough outputs</description>
                      <bitRange>[15:3]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>SPARE_STAT</name>
                  <description>Spare Status</description>
                  <addressOffset>0xEC</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFFFF</resetMask>
                  <fields>
                    <field>
                      <name>SPARE_INPUTS</name>
                      <description>spare input pints</description>
                      <bitRange>[2:0]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>SPARE_FT_IN</name>
                      <description>spare feedthrough inputs</description>
                      <bitRange>[15:3]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>SPARE_HV_CFG</name>
                  <description>Spare Configuration for HV signlas</description>
                  <addressOffset>0xF0</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x7</resetMask>
                  <fields>
                    <field>
                      <name>SPARE_HV_CFG</name>
                      <description>spare output pins for HV</description>
                      <bitRange>[2:0]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
              </cluster>
              <cluster>
                <name>USB40PHY_PLL_SYS</name>
                <description>PHY PLL SYS registers</description>
                <addressOffset>0x00000900</addressOffset>
                <register>
                  <name>PLL_SDM_CFG</name>
                  <description>Sigma-Delta Modulator (SDM) Configuration</description>
                  <addressOffset>0x0</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x1</resetValue>
                  <resetMask>0x1F</resetMask>
                  <fields>
                    <field>
                      <name>SDM_ENABLE</name>
                      <description>Sigma-Delta modulator enable, (active low power down), SSM will be down too
Only 25MHz with no SSC can disable this</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DITHER_EN</name>
                      <description>Sigma-Delta Modulator dither enable</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DITHER_GAIN</name>
                      <description>dither gain value</description>
                      <bitRange>[4:2]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_SSM_CFG0</name>
                  <description>Spread Spectrun Modulator (SSM) Configuration</description>
                  <addressOffset>0x4</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x11D5</resetValue>
                  <resetMask>0xFFFF</resetMask>
                  <fields>
                    <field>
                      <name>DIVF_FRAC_MSB</name>
                      <description>Feedback Divider Ratio fractional vlaue (if SSM is not enabled these input goes to SDM)</description>
                      <bitRange>[7:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DIVF_INTEGER</name>
                      <description>Feedback Divider Ratio integer vlaue (if SSM is not enabled these input goes to SDM)</description>
                      <bitRange>[15:8]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_SSM_CFG1</name>
                  <description>Spread Spectrun Modulator (SSM) Configuration</description>
                  <addressOffset>0x8</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0xA155</resetValue>
                  <resetMask>0xE3FF</resetMask>
                  <fields>
                    <field>
                      <name>DIVF_FRAC_LSB</name>
                      <description>Feedback Divider Ratio fractional vlaue (if SSM is not enabled these input goes to SDM)</description>
                      <bitRange>[9:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>SPREAD</name>
                      <description>SSM modulation depth setting</description>
                      <bitRange>[15:13]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_SSM_CFG2</name>
                  <description>Spread Spectrun Modulator (SSM) Configuration</description>
                  <addressOffset>0xC</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x3AF9</resetValue>
                  <resetMask>0x7FFF</resetMask>
                  <fields>
                    <field>
                      <name>SSM_STEP_CNT</name>
                      <description>SSM modulation triangle new value update count</description>
                      <bitRange>[8:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>SSM_UPDATE_CNT</name>
                      <description>SSM modulation triangle number of steps count</description>
                      <bitRange>[13:9]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>SSM_ENABLE</name>
                      <description>Spread spectrum modulator enable, (active low power down), SDM can be active</description>
                      <bitRange>[14:14]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_AFC_CFG0</name>
                  <description>Automatic Frequency Control (AFC) Configuration</description>
                  <addressOffset>0x10</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x84</resetValue>
                  <resetMask>0xFFFF</resetMask>
                  <fields>
                    <field>
                      <name>AFC_VCTL_SET</name>
                      <description>N/A</description>
                      <bitRange>[2:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>AFC_VCMP_PDB</name>
                      <description>N/A</description>
                      <bitRange>[3:3]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>AFC_VCMP_SEL</name>
                      <description>N/A</description>
                      <bitRange>[7:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>AFC_OVRD_CAPSEL</name>
                      <description>Override value for capsel</description>
                      <bitRange>[14:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>AFC_OVRRIDEN</name>
                      <description>Override for capsel</description>
                      <bitRange>[15:15]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_AFC_CFG1</name>
                  <description>Automatic Frequency Control (AFC) Configuration</description>
                  <addressOffset>0x14</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x210E</resetValue>
                  <resetMask>0x3FFF</resetMask>
                  <fields>
                    <field>
                      <name>AFC_VCTL_HI_CNT</name>
                      <description>AFC vcontrol reset timer count</description>
                      <bitRange>[4:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>AFC_VCTL_LO_CNT</name>
                      <description>AFC vcontrol release timer count</description>
                      <bitRange>[9:5]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>AFC_VCTL_ENABLE_OVERRIDE</name>
                      <description>Override for afc_vctl_enable</description>
                      <bitRange>[10:10]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>AFC_VCTL_ENABLE_OVERRIDE_VALUE</name>
                      <description>Override value  for afc_vctl_enable</description>
                      <bitRange>[11:11]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>AFC_SEL_MIN</name>
                      <description>Capsel min value select</description>
                      <bitRange>[12:12]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>AFC_SEL_MAX</name>
                      <description>Capsel max value select</description>
                      <bitRange>[13:13]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_AFC_CFG2</name>
                  <description>Automatic Frequency Control (AFC) Configuration</description>
                  <addressOffset>0x18</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x28</resetValue>
                  <resetMask>0x7F</resetMask>
                  <fields>
                    <field>
                      <name>AFC_CLKDIVSEL</name>
                      <description>Refclk to FSM clk divide select</description>
                      <bitRange>[5:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>AFC_PDB</name>
                      <description>AFC active low power-down</description>
                      <bitRange>[6:6]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_AFC_STAT</name>
                  <description>Automatic Frequency Control (AFC) Status</description>
                  <addressOffset>0x1C</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x7F</resetMask>
                  <fields>
                    <field>
                      <name>CAPSEL</name>
                      <description>'capsel' value for read</description>
                      <bitRange>[6:0]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_AAC_CFG0</name>
                  <description>Automatic Amplitude Control (AAC) Configuration</description>
                  <addressOffset>0x20</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x6</resetValue>
                  <resetMask>0x3FF</resetMask>
                  <fields>
                    <field>
                      <name>AACREFSEL</name>
                      <description>Amplitude reference voltage select</description>
                      <bitRange>[3:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>AAC_OVRD_AACSEL</name>
                      <description>Override value for aacout</description>
                      <bitRange>[8:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>AAC_OVRRIDEN</name>
                      <description>AAC active low power-down</description>
                      <bitRange>[9:9]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_AAC_CFG1</name>
                  <description>Automatic Amplitude Control (AAC) Configuration</description>
                  <addressOffset>0x24</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x28</resetValue>
                  <resetMask>0x1FF</resetMask>
                  <fields>
                    <field>
                      <name>AAC_CLKDIVSEL</name>
                      <description>Refclk to FSM clk divide select</description>
                      <bitRange>[5:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>AAC_FRZCNT</name>
                      <description>Freeze the counter output (aacout)</description>
                      <bitRange>[6:6]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>AAC_NORECAL</name>
                      <description>No recalibration after 1st lock</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>AAC_PDB</name>
                      <description>No recalibration after 1st lock</description>
                      <bitRange>[8:8]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_AAC_STAT</name>
                  <description>Automatic Amplitude Control (AAC) Status</description>
                  <addressOffset>0x28</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x1F</resetMask>
                  <fields>
                    <field>
                      <name>AACSEL</name>
                      <description>'aacout' for read</description>
                      <bitRange>[4:0]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_REFCKSEL_CFG</name>
                  <description>Reference Clock Select (REFCLKSEL) Configuration</description>
                  <addressOffset>0x2C</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x4</resetValue>
                  <resetMask>0x7</resetMask>
                  <fields>
                    <field>
                      <name>REFCLKSEL</name>
                      <description>Reference Clock MUX Select</description>
                      <bitRange>[2:0]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_DIVR_CFG</name>
                  <description>Reference Clock Divider (DIVR) Configuration</description>
                  <addressOffset>0x30</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x2</resetValue>
                  <resetMask>0xF</resetMask>
                  <fields>
                    <field>
                      <name>LCDIVR</name>
                      <description>DIVR Divider Ratio</description>
                      <bitRange>[3:0]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_DIVP_CFG</name>
                  <description>Post Divider (DIVP) Configuration</description>
                  <addressOffset>0x34</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFF</resetMask>
                  <fields>
                    <field>
                      <name>LCDIVP</name>
                      <description>DIVP Divider Ratio, TX Clk</description>
                      <bitRange>[3:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>LCBYPASS</name>
                      <description>DIVP Divider Ratio, TX Clk</description>
                      <bitRange>[4:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>TX0_DIVP_PDB</name>
                      <description>DIVP Divider, power down, active low for output 0</description>
                      <bitRange>[5:5]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>TX1_DIVP_PDB</name>
                      <description>DIVP Divider, power down, active low for output 1</description>
                      <bitRange>[6:6]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>PLL_SYNC_ENABLE</name>
                      <description>pll_rstb synchronization enable, can be disable after sync is done</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_DIVH_CFG</name>
                  <description>HS Divider (DIVH) Configuration</description>
                  <addressOffset>0x38</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x3F</resetMask>
                  <fields>
                    <field>
                      <name>HSREF_DIVH</name>
                      <description>DIVH Divider Ratio, HSREF Clock</description>
                      <bitRange>[4:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>HSREF_EN</name>
                      <description>High-Speed Ref Clk Output Enable</description>
                      <bitRange>[5:5]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_PFD_CFG</name>
                  <description>Phase/Frequency Detector (PFD) Configuration</description>
                  <addressOffset>0x3C</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xF</resetMask>
                  <fields>
                    <field>
                      <name>PFDDELAY</name>
                      <description>Adjust dead-zone feedback delay</description>
                      <bitRange>[3:0]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_CP_CFG</name>
                  <description>Charge Pump (CP) Configuration</description>
                  <addressOffset>0x40</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x23</resetValue>
                  <resetMask>0x1FF</resetMask>
                  <fields>
                    <field>
                      <name>CFGRCP</name>
                      <description>Charge pump bias resistor adjustment</description>
                      <bitRange>[3:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ICPDAC</name>
                      <description>Charge pump current adjustment</description>
                      <bitRange>[7:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>CP_PDB</name>
                      <description>Charge pump power down, active low</description>
                      <bitRange>[8:8]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_LF_CFG</name>
                  <description>Loop Filter (LF) Configuration</description>
                  <addressOffset>0x44</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x9</resetValue>
                  <resetMask>0x1F</resetMask>
                  <fields>
                    <field>
                      <name>LF_RTUNE</name>
                      <description>N/A</description>
                      <bitRange>[2:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>LF_CTUNE</name>
                      <description>N/A</description>
                      <bitRange>[4:3]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_VCO_CFG</name>
                  <description>Voltage-Controlled Oscillator (VCO) Configuration</description>
                  <addressOffset>0x48</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x765</resetValue>
                  <resetMask>0xFFF</resetMask>
                  <fields>
                    <field>
                      <name>DCVARMODE</name>
                      <description>VCO fix varactors DC bias voltage setting</description>
                      <bitRange>[3:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VCOVARCM1</name>
                      <description>VCO varactor#1 common mode voltage trimming</description>
                      <bitRange>[7:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VCOVARCM2</name>
                      <description>VCO varactor#2 common mode voltage trimming</description>
                      <bitRange>[11:8]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_BIASGEN_CFG</name>
                  <description>Bias Generator (BIASGEN) Configuration</description>
                  <addressOffset>0x4C</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x1024</resetValue>
                  <resetMask>0x1F3F</resetMask>
                  <fields>
                    <field>
                      <name>CFG_BIAS</name>
                      <description>Adjust bias currents</description>
                      <bitRange>[5:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>TERM_TRIM</name>
                      <description>value for termination trim</description>
                      <bitRange>[12:8]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_GNRL_CFG</name>
                  <description>General Controls Configuration</description>
                  <addressOffset>0x50</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x7</resetMask>
                  <fields>
                    <field>
                      <name>PLL_PDB</name>
                      <description>Global PLL active low power-down</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>LKDT_RESETB</name>
                      <description>main lock detect reset, active low</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>RESETLOCKB</name>
                      <description>lock detect, lock output reset, used for re-locking, active low</description>
                      <bitRange>[2:2]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_VREG_CFG1</name>
                  <description>Regulators Configuration</description>
                  <addressOffset>0x54</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x6667</resetValue>
                  <resetMask>0xFFFF</resetMask>
                  <fields>
                    <field>
                      <name>VCPREGSEL</name>
                      <description>Adjust voltage for charg-pump regulator</description>
                      <bitRange>[3:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VREGLCPLLSEL</name>
                      <description>Adjust voltage for VCO Clock rate cells</description>
                      <bitRange>[7:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VREGREFSEL</name>
                      <description>Adjust voltage for REFCK rate cells</description>
                      <bitRange>[11:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VREGDIGSEL</name>
                      <description>Adjust voltage for async. Cells</description>
                      <bitRange>[15:12]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_VREG_CFG2</name>
                  <description>Regulators Configuration</description>
                  <addressOffset>0x58</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x7F</resetMask>
                  <fields>
                    <field>
                      <name>VCPREG_PDB</name>
                      <description>charge-pump regulator powr down, active low</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VREGLCPLL_PDB</name>
                      <description>LCPLL Regulator Power-Down</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VREGREF_PDB</name>
                      <description>REF Regulator Power-Down</description>
                      <bitRange>[2:2]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VREGDIG_PDB</name>
                      <description>DIG Regulator Power-Down</description>
                      <bitRange>[3:3]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VCPREG_BPB</name>
                      <description>CP regulator bypass</description>
                      <bitRange>[4:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>CPCLK_SEL</name>
                      <description>CP regulator clock frequency select</description>
                      <bitRange>[5:5]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>BURNIN</name>
                      <description>Enable Burn-In mode</description>
                      <bitRange>[6:6]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_VREG_STAT</name>
                  <description>Regulators Status</description>
                  <addressOffset>0x5C</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x7</resetMask>
                  <fields>
                    <field>
                      <name>PWR_GOOD_LCPLL</name>
                      <description>pwr_good_lcpll for read as status</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>PWR_GOOD_REF</name>
                      <description>pwr_good_ref for read as status</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>PWR_GOOD_DIG</name>
                      <description>pwr_good_dig for read as status</description>
                      <bitRange>[2:2]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_LD_CFG</name>
                  <description>Lock Detect Configuration</description>
                  <addressOffset>0x60</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x30</resetValue>
                  <resetMask>0x3F7</resetMask>
                  <fields>
                    <field>
                      <name>LOCKOS</name>
                      <description>Frequency detect tolerance = +/- 0.025 percent*2^lockin</description>
                      <bitRange>[2:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DLFCNTSEL</name>
                      <description>Filtered lock, #of refcklk cycles flock generated after lock  [2^(flocksel+8)]</description>
                      <bitRange>[5:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>LUDDIVSEL</name>
                      <description>Lockup detect timer setting, cycles of refclk, 256 or 512</description>
                      <bitRange>[6:6]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>LUDDISABLE</name>
                      <description>Lockup detect disable</description>
                      <bitRange>[7:7]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>CRS_FD_AUXCLK_SEL</name>
                      <description>Coarse frequency detect aux clock select</description>
                      <bitRange>[8:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>CRS_FD_DISABLE</name>
                      <description>Coarse frequency detect disable</description>
                      <bitRange>[9:9]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_LD_STAT</name>
                  <description>Lock Detect Status</description>
                  <addressOffset>0x64</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x1</resetMask>
                  <fields>
                    <field>
                      <name>FLOCK</name>
                      <description>flock for read as status</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_ATEST</name>
                  <description>Analog Test Mux (ATEST) Configuration</description>
                  <addressOffset>0x68</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0x3F</resetMask>
                  <fields>
                    <field>
                      <name>ADFT_SEL</name>
                      <description>Analog test MUX Select</description>
                      <bitRange>[3:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ADFT_ENABLE</name>
                      <description>Analog test MUX Enable</description>
                      <bitRange>[4:4]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ADFT_VREGDIV_EN</name>
                      <description>Analog test regulators output measurment, enables regulators ouputs resistive voltage divider</description>
                      <bitRange>[5:5]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>PLL_DTEST</name>
                  <description>Digital Test Mux (DTEST) Configuration</description>
                  <addressOffset>0x6C</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xBF3F</resetMask>
                  <fields>
                    <field>
                      <name>DDFT0_SEL</name>
                      <description>Digital test MUX0 Select</description>
                      <bitRange>[5:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DDFT1_SEL</name>
                      <description>Digital test MUX1 Select</description>
                      <bitRange>[13:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>DDFT_ENABLE</name>
                      <description>Digital test MUX Enable</description>
                      <bitRange>[15:15]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>SPARE_CFG</name>
                  <description>Spare Configuration</description>
                  <addressOffset>0x70</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFFFB</resetMask>
                  <fields>
                    <field>
                      <name>SPARE_OUT</name>
                      <description>spare output pins</description>
                      <bitRange>[1:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>SPARE_FT_OUT</name>
                      <description>spare feedthrough outputs</description>
                      <bitRange>[15:3]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>SPARE_STAT</name>
                  <description>Spare Status</description>
                  <addressOffset>0x74</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFFFF</resetMask>
                  <fields>
                    <field>
                      <name>SPARE_INPUTS</name>
                      <description>spare input pins</description>
                      <bitRange>[2:0]</bitRange>
                      <access>read-only</access>
                    </field>
                    <field>
                      <name>SPARE_FT_IN</name>
                      <description>spare feedthrough inputs</description>
                      <bitRange>[15:3]</bitRange>
                      <access>read-only</access>
                    </field>
                  </fields>
                </register>
              </cluster>
            </cluster>
          </cluster>
          <cluster>
            <dim>2</dim>
            <dimIncrement>65536</dimIncrement>
            <name>USB32DEV_ADAPTER_USB32DEV_DMA[%s]</name>
            <description>USB32 DMA Adapter registers. 
0x10000 is for Ingress and 0x20000 for egress Adapter</description>
            <addressOffset>0x00010000</addressOffset>
            <cluster>
              <dim>16</dim>
              <dimIncrement>128</dimIncrement>
              <name>SCK[%s]</name>
              <description>Socket Registers</description>
              <addressOffset>0x00008000</addressOffset>
              <register>
                <name>SCK_DSCR</name>
                <description>Descriptor Chain Pointer</description>
                <addressOffset>0x0</addressOffset>
                <size>32</size>
                <access>read-write</access>
                <resetValue>0x0</resetValue>
                <resetMask>0xFFFFFFFF</resetMask>
                <fields>
                  <field>
                    <name>DSCR_NUMBER</name>
                    <description>Descriptor number of currently active descriptor.  A value of 0xFFFF designates no (more) active descriptors available.  When activating a socket CPU shall write number of first descriptor in here. Only modify this field when go_suspend=1 or go_enable=0</description>
                    <bitRange>[15:0]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>DSCR_COUNT</name>
                    <description>Number of descriptors still left to process.  This value is unrelated to actual number of descriptors in the list.  It is used only to generate an interrupt to the CPU when the value goes low or zero (or both).  When this value reaches 0 it will wrap around to 255.  The socket will not suspend or be otherwise affected unless the descriptor chains ends with 0xFFFF descriptor number.</description>
                    <bitRange>[23:16]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>DSCR_LOW</name>
                    <description>The low watermark for dscr_count.  When dscr_count is equal or less than dscr_low the status bit dscr_is_low is set and an interrupt can be generated (depending on int mask).</description>
                    <bitRange>[31:24]</bitRange>
                    <access>read-write</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>SCK_SIZE</name>
                <description>Transfer Size Register</description>
                <addressOffset>0x4</addressOffset>
                <size>32</size>
                <access>read-write</access>
                <resetValue>0x0</resetValue>
                <resetMask>0xFFFFFFFF</resetMask>
                <fields>
                  <field>
                    <name>TRANS_SIZE</name>
                    <description>The number of bytes or buffers (depends on unit bit in SCK_STATUS) that are part of this transfer.  A value of 0 signals an infinite/undetermined transaction size.
Valid data bytes remaining in the last buffer beyond the transfer size will be read by socket and passed on to the core. FW must ensure that no additional bytes beyond the transfer size are present in the last buffer.                                                                          Note: For non-zero TRANS_SIZE in ingress sockets, if the number of bytes that are part of the transfer exceed the TRANS_SIZE, the socket will wrap up the buffer on EOP regardless of whether the buffer is full or not.</description>
                    <bitRange>[31:0]</bitRange>
                    <access>read-write</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>SCK_COUNT</name>
                <description>Transfer Count Register</description>
                <addressOffset>0x8</addressOffset>
                <size>32</size>
                <access>read-write</access>
                <resetValue>0x0</resetValue>
                <resetMask>0xFFFFFFFF</resetMask>
                <fields>
                  <field>
                    <name>TRANS_COUNT</name>
                    <description>The number of bytes or buffers (depends on unit bit in SCK_STATUS) that have been transferred through this socket so far.  If trans_size is &gt;0 and trans_count&gt;=trans_size the  'trans_done' bits in SCK_STATUS is both set.  If SCK_STATUS.susp_trans=1 the socket is also suspended and the 'suspend' bit set. This count is updated only when a descriptor is completed and the socket proceeds to the next one.
Exception: When socket suspends with PARTIAL_BUF=1, this value has been (incorrectly) incremented by 1 (UNIT=1) or DSCR_SIZE.BYTE_COUNT (UNIT=0).  Firmware must correct this before resuming the socket.</description>
                    <bitRange>[31:0]</bitRange>
                    <access>read-write</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>SCK_STATUS</name>
                <description>Socket Status Register</description>
                <addressOffset>0xC</addressOffset>
                <size>32</size>
                <access>read-write</access>
                <resetValue>0x4E00000</resetValue>
                <resetMask>0xFFFF8FFF</resetMask>
                <fields>
                  <field>
                    <name>AVL_COUNT</name>
                    <description>Number of available (free for ingress, occupied for egress) descriptors beyond the current one.  This number is incremented by the adapter whenever an event is received on this socket and decremented whenever it activates a new descriptor. This value is used to create a signal to the IP Cores that indicates at least one buffer is available beyond the current one (sck_more_buf_avl).</description>
                    <bitRange>[4:0]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>AVL_MIN</name>
                    <description>Minimum number of available buffers required by the adapter before activating a new one.  This can be used to guarantee a minimum number of buffers available with old data to implement rollback.  If AVL_ENABLE, the socket will remain in STALL state until AVL_COUNT&gt;AVL_MIN.        NOTE: Because of issue captured in CDT_005539-348, the only valid values for AVL_MIN are 1,2,4 and 8.</description>
                    <bitRange>[9:5]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>AVL_ENABLE</name>
                    <description>Enables the functioning of AVL_COUNT and AVL_MIN. When 0, it will disable both stalling on AVL_MIN and generation of the sck_more_buf_avl signal described above.</description>
                    <bitRange>[10:10]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>SCK_ZLP_ALWAYS</name>
                    <description>When enabled, an EOT with len==0 will use the next descriptor and generate a ZLP.  When disabled and EOT with len==0 wraps the current descriptor with no ZLP (the new behavior)</description>
                    <bitRange>[11:11]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>STATE</name>
                    <description>Internal operating state of the socket.  This field is used for debugging and to safely modify active sockets (see go_suspend).</description>
                    <bitRange>[17:15]</bitRange>
                    <access>read-only</access>
                    <enumeratedValues>
                      <enumeratedValue>
                        <name>DESCR</name>
                        <description>Descriptor state. This is the default initial state indicating the descriptor registers are NOT valid in the Adapter. The Adapter will start loading the descriptor from memory if the socket becomes enabled and not suspended. Suspend has no effect on any other state.</description>
                        <value>0</value>
                      </enumeratedValue>
                      <enumeratedValue>
                        <name>STALL</name>
                        <description>Stall state. Socket is stalled waiting for data to be loaded into the Fetch Queue or waiting for an event.</description>
                        <value>1</value>
                      </enumeratedValue>
                      <enumeratedValue>
                        <name>ACTIVE</name>
                        <description>Active state. Socket is available for core data transfers.</description>
                        <value>2</value>
                      </enumeratedValue>
                      <enumeratedValue>
                        <name>EVENT</name>
                        <description>Event state. Core transfer is done. Descriptor is being written back to memory and an event is being generated if enabled.</description>
                        <value>3</value>
                      </enumeratedValue>
                      <enumeratedValue>
                        <name>CHECK1</name>
                        <description>Check states. An active socket gets here based on the core's EOP request to check the Transfer size and determine whether the buffer should be wrapped up. Depending on result, socket will either go back to Active state or move to the Event state.</description>
                        <value>4</value>
                      </enumeratedValue>
                      <enumeratedValue>
                        <name>SUSPENDED</name>
                        <description>Socket is suspended</description>
                        <value>5</value>
                      </enumeratedValue>
                      <enumeratedValue>
                        <name>CHECK2</name>
                        <description>Check states. An active socket gets here based on the core's EOP request to check the Transfer size and determine whether the buffer should be wrapped up. Depending on result, socket will either go back to Active state or move to the Event state.</description>
                        <value>6</value>
                      </enumeratedValue>
                      <enumeratedValue>
                        <name>WAITING</name>
                        <description>Waiting for confirmation that event was sent.</description>
                        <value>7</value>
                      </enumeratedValue>
                    </enumeratedValues>
                  </field>
                  <field>
                    <name>ZLP_RCVD</name>
                    <description>Indicates the socket received a ZLP</description>
                    <bitRange>[18:18]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>SUSPENDED</name>
                    <description>Indicates the socket is currently in suspend state.  In suspend mode there is no active descriptor; any previously active descriptor has been wrapped up, copied back to memory and SCK_DSCR.dscr_number has been updated using DSCR_CHAIN as needed.  If the next descriptor is known (SCK_DSCR.dscr_number!=0xFFFF), this descriptor will be loaded after the socket resumes from suspend state.
A socket can only be resumed by changing go_suspend from 1 to 0.  If the socket is suspended while go_suspend=0, it must first be set and then again cleared.</description>
                    <bitRange>[19:19]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>ENABLED</name>
                    <description>Indicates the socket is currently enabled when asserted.  After go_enable is changed, it may take some time for enabled to make the same change.  This value can be polled to determine this fact.</description>
                    <bitRange>[20:20]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>TRUNCATE</name>
                    <description>Enable (1) or disable (0) truncating of BYTE_COUNT when TRANS_COUNT+BYTE_COUNT&gt;=TRANS_SIZE.  When enabled, ensures that an ingress transfer never contains more bytes then allowed.  This function is needed to implement burst-based prototocols that can only transmit full bursts of more than 1 byte.</description>
                    <bitRange>[21:21]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>EN_PROD_EVENTS</name>
                    <description>Enable (1) or disable (0) sending of produce events from any descriptor in this socket.  If 0, events will be suppressed, and the descriptor will not be copied back into memory when completed.</description>
                    <bitRange>[22:22]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>EN_CONS_EVENTS</name>
                    <description>Enable (1) or disable (0) sending of consume events from any descriptor in this socket.  If 0, events will be suppressed, and the descriptor will not be copied back into memory when completed.</description>
                    <bitRange>[23:23]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>SUSP_PARTIAL</name>
                    <description>When set, the socket will suspend before activating a descriptor with BYTE_COUNT&lt;BUFFER_SIZE.
This is relevant for egress sockets only.</description>
                    <bitRange>[24:24]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>SUSP_LAST</name>
                    <description>When set, the socket will suspend before activating a descriptor with TRANS_COUNT+BUFFER_SIZE&gt;=TRANS_SIZE.  This is relevant for both ingress and egress sockets. As captured in CDT_005539-345, due to a bug, when socket suspends on SUS_LAST, the SCK_COUNT value reflected is TRANS_COUNT+BUFFER_SIZE even though the actual bytes transferred by the socket is TRANS_COUNT only.</description>
                    <bitRange>[25:25]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>SUSP_TRANS</name>
                    <description>When set, the socket will suspend when trans_count &gt;= trans_size.  This equation is checked (and hence the socket will suspend) only at the boundary of buffers and packets (ie. buffer wrapup or EOP assertion).</description>
                    <bitRange>[26:26]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>SUSP_EOP</name>
                    <description>When set, the socket will suspend after wrapping up the first buffer with dscr.eop=1.  Note that this function will work the same for both ingress and egress sockets.</description>
                    <bitRange>[27:27]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>WRAPUP</name>
                    <description>Setting this bit will forcibly wrap-up a socket, whether it is out of data or not.  This option is intended mainly for ingress sockets, but works also for egress sockets.  Any remaining data in fetch buffers is ignored, in write buffers is flushed.  Transaction and buffer counts are updated normally, and suspend behavior also happens normally (depending on various other settings in this register).G45</description>
                    <bitRange>[28:28]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>UNIT</name>
                    <description>Indicates whether descriptors (1) or bytes (0) are counted by trans_count and trans_size.  Descriptors are counting regardless of whether they contain any data or have eop set.</description>
                    <bitRange>[29:29]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>GO_SUSPEND</name>
                    <description>Directs a socket to go into suspend mode when the current descriptor completes.  The main use of this bit is to safely append descriptors to an active socket without actually suspending it (in most cases). The process is outlined in more detail in the architecture spec, and looks as follows:
1: GO_SUSPEND=1
2: modify the chain in memory
3: check if active descriptor is 0xFFFF or last in chain
4: if so, make corrections as neccessary (complicated)
5: clear any pending suspend interrupts (SCK_INTR[9:5])
6: GO_SUSPEND=0
Note that the socket resumes only when SCK_INTR[9:5]=0 and GO_SUSPEND=0.</description>
                    <bitRange>[30:30]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>GO_ENABLE</name>
                    <description>Indicates whether socket is enabled.  When go_enable is cleared while socket is active, ongoing transfers are aborted after an unspecified amount of time.  No update occurs from the descriptor registers back into memory.  When go_enable is changed from 0 to 1, the socket will reload the active descriptor from memory regardless of the contents of DSCR_ registers. The socket will not wait for an EVENT to become active if the descriptor is available and ready for transfer (has space or data). 
The 'enabled' bit indicates whether the socket is actually enabled or not.  This field lags go_enable by an short but unspecificied of time.</description>
                    <bitRange>[31:31]</bitRange>
                    <access>read-write</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>SCK_INTR</name>
                <description>Socket Interrupt Request Register</description>
                <addressOffset>0x10</addressOffset>
                <size>32</size>
                <access>read-write</access>
                <resetValue>0x0</resetValue>
                <resetMask>0x7FF</resetMask>
                <fields>
                  <field>
                    <name>PRODUCE_EVENT</name>
                    <description>Indicates that a produce event has been transmitted since last cleared.</description>
                    <bitRange>[0:0]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>CONSUME_EVENT</name>
                    <description>Indicates that a consume event has been transmitted since last cleared.</description>
                    <bitRange>[1:1]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>DSCR_IS_LOW</name>
                    <description>Indicates that dscr_count has fallen below its watermark dscr_low.  If dscr_count wraps around to 255 dscr_is_low will remain asserted until cleared by s/w</description>
                    <bitRange>[2:2]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>DSCR_NOT_AVL</name>
                    <description>Indicates the no descriptor is available.  Not available means that the current descriptor number is 0xFFFF.  Note that this bit will remain asserted until cleared by s/w, regardless of whether a new descriptor number is loaded.</description>
                    <bitRange>[3:3]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>STALL</name>
                    <description>Indicates the socket has stalled, waiting for an event signaling its descriptor has become available. Note that this bit will remain asserted until cleared by s/w, regardless of whether the socket resumes.</description>
                    <bitRange>[4:4]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>SUSPEND</name>
                    <description>Indicates the socket has gone into suspend mode.  This may be caused by any hardware initiated condition (e.g. DSCR_NOT_AVL, any of the SUSP_*) or by setting GO_SUSPEND=1.  Note that this bit will remain asserted until cleared by s/w, regardless of whether the suspend condition is resolved.  
Note that the socket resumes only when SCK_INTR[9:5]=0 and GO_SUSPEND=0.</description>
                    <bitRange>[5:5]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>ERROR</name>
                    <description>Indicates the socket is suspended because of an error condition (internal to the adapter) - if error=1 then suspend=1 as well.  Possible error causes are:
- dscr_size.buffer_error bit already set in the descriptor.
- dscr_size.byte_count &gt; dscr_size.buffer_size 
- core writes into an inactive socket.
- core did not consume all the data in the buffer.
Note that the socket resumes only when SCK_INTR[9:5]=0 and GO_SUSPEND=0.</description>
                    <bitRange>[6:6]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>TRANS_DONE</name>
                    <description>Indicates that TRANS_COUNT has reached the limit TRANS_SIZE.  This flag is only set when SUSP_TRANS=1.  Note that because TRANS_COUNT is updated only at the granularity of entire buffers, it is possible that TRANS_COUNT exceeds TRANS_SIZE before the socket suspends.  Software must detect and deal with these situations.  When asserting EOP to the adapter on ingress, the trans_count is not updated unless the socket actually suspends (see SUSP_TRANS).
Note that the socket resumes only when SCK_INTR[9:5]=0 and GO_SUSPEND=0.</description>
                    <bitRange>[7:7]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>PARTIAL_BUF</name>
                    <description>Indicates that the (egress) socket was suspended because of SUSP_PARTIAL condition.  Note that the socket resumes only when SCK_INTR[9:5]=0 and GO_SUSPEND=0.</description>
                    <bitRange>[8:8]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>LAST_BUF</name>
                    <description>Indicates that the socket was suspended because of SUSP_LAST condition.  Note that the socket resumes only when SCK_INTR[9:5]=0 and GO_SUSPEND=0.</description>
                    <bitRange>[9:9]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>EVENT_RCVD</name>
                    <description>Indicates that an event has been received. (For a consuming socket this means a produce event has been received. For a producing socket this means a consume event has been received.)</description>
                    <bitRange>[10:10]</bitRange>
                    <access>read-write</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>SCK_INTR_MASK</name>
                <description>Socket Interrupt Mask Register</description>
                <addressOffset>0x14</addressOffset>
                <size>32</size>
                <access>read-write</access>
                <resetValue>0x0</resetValue>
                <resetMask>0x7FF</resetMask>
                <fields>
                  <field>
                    <name>PRODUCE_EVENT</name>
                    <description>1: Report interrupt to CPU</description>
                    <bitRange>[0:0]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>CONSUME_EVENT</name>
                    <description>1: Report interrupt to CPU</description>
                    <bitRange>[1:1]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>DSCR_IS_LOW</name>
                    <description>1: Report interrupt to CPU</description>
                    <bitRange>[2:2]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>DSCR_NOT_AVL</name>
                    <description>1: Report interrupt to CPU</description>
                    <bitRange>[3:3]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>STALL</name>
                    <description>1: Report interrupt to CPU</description>
                    <bitRange>[4:4]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>SUSPEND</name>
                    <description>1: Report interrupt to CPU</description>
                    <bitRange>[5:5]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>ERROR</name>
                    <description>1: Report interrupt to CPU</description>
                    <bitRange>[6:6]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>TRANS_DONE</name>
                    <description>1: Report interrupt to CPU</description>
                    <bitRange>[7:7]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>PARTIAL_BUF</name>
                    <description>1: Report interrupt to CPU</description>
                    <bitRange>[8:8]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>LAST_BUF</name>
                    <description>1: Report interrupt to CPU</description>
                    <bitRange>[9:9]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>EVENT_RCVD</name>
                    <description>1: Report interrupt to CPU</description>
                    <bitRange>[10:10]</bitRange>
                    <access>read-write</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>DSCR_BUFFER</name>
                <description>Descriptor buffer base address register</description>
                <addressOffset>0x20</addressOffset>
                <size>32</size>
                <access>read-write</access>
                <resetValue>0x0</resetValue>
                <resetMask>0xFFFFFFFF</resetMask>
                <fields>
                  <field>
                    <name>BUFFER_ADDR</name>
                    <description>The base address of the buffer where data is written.  This address is not necessarily word-aligned to allow for header/trailer/length modification.</description>
                    <bitRange>[30:0]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>MARKER</name>
                    <description>A marker that is provided by s/w and can be observed by the IP.  It's meaning is defined by the IP that uses it.  This bit has no effect on the other DMA mechanisms.</description>
                    <bitRange>[31:31]</bitRange>
                    <access>read-write</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>DSCR_SYNC</name>
                <description>Descriptor synchronization pointers register</description>
                <addressOffset>0x24</addressOffset>
                <size>32</size>
                <access>read-write</access>
                <resetValue>0x0</resetValue>
                <resetMask>0xFFFFFFFF</resetMask>
                <fields>
                  <field>
                    <name>CONS_SCK</name>
                    <description>The socket number of the consuming socket to which the produce event shall be sent.
If cons_ip and cons_sck matches the socket's IP and socket number then the matching socket becomes consuming socket.</description>
                    <bitRange>[7:0]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>CONS_IP</name>
                    <description>The IP number of the consuming socket to which the produce event shall be sent.  Use 0x3F to designate ARM CPU (so software) as consumer; the event will be lost in this case and an interrupt should also be generated to observe this condition.</description>
                    <bitRange>[13:8]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>EN_CONS_EVENT</name>
                    <description>Enable sending of a consume events from this descriptor only.  Events are sent only if SCK_STATUS.en_consume_ev=1.  When events are disabled, the adapter also does not update the descriptor in memory to clear its occupied bit.</description>
                    <bitRange>[14:14]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>EN_CONS_INT</name>
                    <description>Enable generation of a consume event interrupt for this descriptor only.  This interrupt will only be seen by the CPU if SCK_STATUS.int_mask has this interrupt enabled as well.  Note that this flag influences the logging of the interrupt in SCK_STATUS; it has no effect on the reporting of the interrupt to the CPU like SCK_STATUS.int_mask does.</description>
                    <bitRange>[15:15]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>PROD_SCK</name>
                    <description>The socket number of the producing socket to which the consume event shall be sent. If prod_ip and prod_sck matches the socket's IP and socket number then the matching socket becomes consuming socket.</description>
                    <bitRange>[23:16]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>PROD_IP</name>
                    <description>The IP number of the producing socket to which the consume event shall be sent. Use 0x3F to designate ARM CPU (so software) as producer; the event will be lost in this case and an interrupt should also be generated to observe this condition.</description>
                    <bitRange>[29:24]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>EN_PROD_EVENT</name>
                    <description>Enable sending of a produce events from this descriptor only.  Events are sent only if SCK_STATUS.en_produce_ev=1.  If 0, events will be suppressed, and the descriptor will not be copied back into memory when completed.</description>
                    <bitRange>[30:30]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>EN_PROD_INT</name>
                    <description>Enable generation of a produce event interrupt for this descriptor only. This interrupt will only be seen by the CPU if SCK_STATUS. int_mask has this interrupt enabled as well.  Note that this flag influences the logging of the interrupt in SCK_STATUS; it has no effect on the reporting of the interrupt to the CPU like SCK_STATUS.int_mask does.</description>
                    <bitRange>[31:31]</bitRange>
                    <access>read-write</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>DSCR_CHAIN</name>
                <description>Descriptor Chain Pointers Register</description>
                <addressOffset>0x28</addressOffset>
                <size>32</size>
                <access>read-write</access>
                <resetValue>0x0</resetValue>
                <resetMask>0xFFFFFFFF</resetMask>
                <fields>
                  <field>
                    <name>RD_NEXT_DSCR</name>
                    <description>Descriptor number of the next task for consumer. A value of 0xFFFF signals end of this list.</description>
                    <bitRange>[15:0]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>WR_NEXT_DSCR</name>
                    <description>Descriptor number of the next task for producer. A value of 0xFFFF signals end of this list.</description>
                    <bitRange>[31:16]</bitRange>
                    <access>read-write</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>DSCR_SIZE</name>
                <description>Descriptor Size Register</description>
                <addressOffset>0x2C</addressOffset>
                <size>32</size>
                <access>read-write</access>
                <resetValue>0x0</resetValue>
                <resetMask>0xFFFFFFFF</resetMask>
                <fields>
                  <field>
                    <name>BYTE_COUNT_MSB</name>
                    <description>When this bit is 1 and BYTE_COUNT is '0', it indicates that byte count is 64KB</description>
                    <bitRange>[0:0]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>EOP</name>
                    <description>A marker indicating this descriptor refers to the last buffer of a packet or transfer. Packets/transfers may span more than one buffer.  The producing IP provides this marker by providing the EOP signal to its DMA adapter.  The consuming IP observes this marker by inspecting its EOP return signal from its own DMA adapter. For more information see section on packets, buffers and transfers in DMA chapter.</description>
                    <bitRange>[1:1]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>BUFFER_ERROR</name>
                    <description>Indicates the buffer data is valid (0) or in error (1).</description>
                    <bitRange>[2:2]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>BUFFER_OCCUPIED</name>
                    <description>Indicates the buffer is in use (1) or empty (0).  A consumer will interpret this as:
0: Buffer is empty, wait until filled.
1: Buffer has data that can be consumed
A produce will interpret this as:
0: Buffer is ready to be filled
1: Buffer is occupied, wait until empty</description>
                    <bitRange>[3:3]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>BUFFER_SIZE</name>
                    <description>The size of the buffer in multiples of 16 bytes. (When BUFFSIZE_64KB_EN is '1', this indicates the size of the buffer in multiples of 32 bytes.)</description>
                    <bitRange>[15:4]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>BYTE_COUNT</name>
                    <description>The number of data bytes present in the buffer.  An occupied buffer is not always full, in particular when variable length packets are transferred.</description>
                    <bitRange>[31:16]</bitRange>
                    <access>read-write</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>EVENT</name>
                <description>Event Communication Register</description>
                <addressOffset>0x7C</addressOffset>
                <size>32</size>
                <access>write-only</access>
                <resetValue>0x0</resetValue>
                <resetMask>0x1FFFF</resetMask>
                <fields>
                  <field>
                    <name>ACTIVE_DSCR</name>
                    <description>The active descriptor number for which the event is sent.</description>
                    <bitRange>[15:0]</bitRange>
                    <access>write-only</access>
                  </field>
                  <field>
                    <name>EVENT_TYPE</name>
                    <description>Type of event
0: Consume event descriptor is marked empty - BUFFER_OCCUPIED=0)
1: Produce event descriptor is marked full = BUFFER_OCCUPIED=1)</description>
                    <bitRange>[16:16]</bitRange>
                    <access>write-only</access>
                  </field>
                </fields>
              </register>
            </cluster>
            <cluster>
              <name>SCK_GBL</name>
              <description>General DMA Registers</description>
              <addressOffset>0x0000FF00</addressOffset>
              <register>
                <name>SCK_INTR</name>
                <description>Socket Interrupt Request Register</description>
                <addressOffset>0x0</addressOffset>
                <size>32</size>
                <access>read-only</access>
                <resetValue>0x0</resetValue>
                <resetMask>0xFFFFFFFF</resetMask>
                <fields>
                  <field>
                    <name>SCKINTR</name>
                    <description>Socket &lt;x&gt; asserts interrupt when bit &lt;x&gt; is set in this vector.  Multiple bits may be set to 1 simultaneously.
This register is only as wide as the number of socket in the adapter; 256 is just the maximum width.  All other bits always return 0.</description>
                    <bitRange>[31:0]</bitRange>
                    <access>read-only</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>ADAPTER_CTRL</name>
                <description>Adapter Control Register</description>
                <addressOffset>0xF0</addressOffset>
                <size>32</size>
                <access>read-write</access>
                <resetValue>0xE000000</resetValue>
                <resetMask>0x3F33F4F1</resetMask>
                <fields>
                  <field>
                    <name>ADAPTER_EN</name>
                    <description>0: Adapter is disabled, Resets the adapter logic, this reset is an async reset.
1: Adapter is enabled.</description>
                    <bitRange>[0:0]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>ADAP_DATA_WR_PRIO</name>
                    <description>When this bit is set for only one adapter, priority is given during arbitration for data writes. When this bit is set or unset in both adapters, roundrobin arbitration happens between two data writes.</description>
                    <bitRange>[4:4]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>ADAP_DATA_RD_PRIO</name>
                    <description>When this bit is set for only one adapter, priority is given during arbitration for data reads. When this bit is set or unset in both adapters, roundrobin arbitration happens between two data reads.</description>
                    <bitRange>[5:5]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>ADAP_DESC_WR_PRIO_N</name>
                    <description>When this bit is '0' for only one adapter, priority is given during arbitration for descriptor writes over data writes. When this bit is set or unset in both adapters, roundrobin arbitration happens between two descriptor writes. By default, descriptor writes are given high priority over data writes.</description>
                    <bitRange>[6:6]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>ADAP_DESC_RD_PRIO_N</name>
                    <description>When this bit is '0' for only one adapter, priority is given during arbitration for descriptor reads over data reads. When this bit is set or unset in both adapters, roundrobin arbitration happens between two descriptor reads. By default, descriptor reads are given high priority over data reads.</description>
                    <bitRange>[7:7]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>SUSP_PARTIAL_NO_EVT_N</name>
                    <description>When low, ensures that no consume event is generated when SUSP_PARTIAL is enabled and BYTE_COUNT&lt;BUFFER_SIZE.</description>
                    <bitRange>[10:10]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>FQ_DEPTH_CTRL</name>
                    <description>Number of entries in the socket fetch Queue (FQ). Default is a value of '0', which means entire FQ_DEPTH defined by parameter is used. Because of FSM timing, the FQ depth must be atleast 5.</description>
                    <bitRange>[17:12]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>DEBUG_CAPTURE</name>
                    <description>When set, the internal debug signals will be captured in the Ingress Adapater RQ. This setting can be used for both Ingress and Egress adapters but not all debug signals being captured will be valid.</description>
                    <bitRange>[20:20]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>EN_UNALIGNED_READ_N</name>
                    <description>When low, the adapter will support reads from Unaligned Buffer Start Address. When set high, the dut will revert to A0 RTL and not support Unaligned Buffer Reads.</description>
                    <bitRange>[21:21]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>TR_OUT_DELAY</name>
                    <description>Number of cycles it takes to send out a trigger after a descriptor writeback condition is met. The default and minimum value for this register is 0x14 (20 Cycles). The max value that can be programmed is 0x3F</description>
                    <bitRange>[29:24]</bitRange>
                    <access>read-write</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>ADAPTER_DEBUG</name>
                <description>Adapter Debug Observation Register</description>
                <addressOffset>0xF4</addressOffset>
                <size>32</size>
                <access>read-only</access>
                <resetValue>0x0</resetValue>
                <resetMask>0xFFFFFFFF</resetMask>
                <fields>
                  <field>
                    <name>TS_COUNT</name>
                    <description>Internal adapter state for debug observation</description>
                    <bitRange>[3:0]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>TS_STATE</name>
                    <description>Internal adapter state for debug observation</description>
                    <bitRange>[6:4]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>TS_ID</name>
                    <description>Internal adapter state for debug observation</description>
                    <bitRange>[12:7]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>SS_COUNT</name>
                    <description>Internal adapter state for debug observation</description>
                    <bitRange>[21:13]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>SS_STATE</name>
                    <description>Internal adapter state for debug observation</description>
                    <bitRange>[22:22]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>SS_ID</name>
                    <description>Internal adapter state for debug observation</description>
                    <bitRange>[28:23]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>TS_ABORT</name>
                    <description>Internal adapter state for debug observation</description>
                    <bitRange>[29:29]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>BS_STATE</name>
                    <description>Internal adapter state for debug observation</description>
                    <bitRange>[31:30]</bitRange>
                    <access>read-only</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>ADAPTER_CONF</name>
                <description>Adapter Configuration Register</description>
                <addressOffset>0xF8</addressOffset>
                <size>32</size>
                <access>read-write</access>
                <resetValue>0x10000000</resetValue>
                <resetMask>0xFFFFFFFF</resetMask>
                <fields>
                  <field>
                    <name>SOCKET_ACTIVE_THRSHLD</name>
                    <description>Number of entries in a socket fetch queue (FQ) that must be present before sck_active asserts.  Default value is 0, which means the entire FQ must fill up before sck_active asserts.
NOTE: The default value for this field is the entire FQ_DEPTH which are different for Egress/Ingress.</description>
                    <bitRange>[5:0]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>STREAM_COUNT</name>
                    <description>Number of burst requests to issue without examining the FQ depth (because IP Core can guarantee immediate consumption).</description>
                    <bitRange>[14:6]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>STREAMING_MODE</name>
                    <description>0: Do not make fetch requests unless fetch queue has space to hold response (default).
1: Assume IP Core will drain all data as it comes in.  Place fetch requests on bus as fast as possible (DO NOT USE UNLESS YOU KNOW WHAT YOU ARE DOING).</description>
                    <bitRange>[15:15]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>TS_CYCLES</name>
                    <description>Minimum cycles between prefetch requests to the bus.  The adapter will wait for this number of cycles in between prefetch burst requests when activating a descriptor on a socket.  If TS_CYCLES=0, the requests will be sent back-to-back (assuming queues are not full).</description>
                    <bitRange>[19:16]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>ES_CYCLES</name>
                    <description>Minimum cycles between fetch requests to the bus under normal operation.  The adapter will wait for this number of cycles in between burst requests when refilling a fetch queue for a desriptor  If ES_CYCLES=0, the requests may be sent back-to-back (assuming queues are not full).</description>
                    <bitRange>[23:20]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>GBL_CYCLES</name>
                    <description>Minimum cycles between any fetch requests to the bus.  The adapter will wait for this number of cycles in between any fetch or prefetch burst requests when activating a descriptor on a socket.  If GBL_CYCLES=0, the requests may be sent back-to-back (assuming queues are not full).</description>
                    <bitRange>[27:24]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>MMIO_LOW_PRIORITY</name>
                    <description>Sets priority between MMIO and Core requests:
0: fair arbitration. MMIO is guaranteed to win the next cycle if there was a collision with the core request in the first cycle.
1: low priority. MMIO will never win if the core has a request.</description>
                    <bitRange>[28:28]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>SWITCH_HIGH_PRIORITY</name>
                    <description>Socket swicth higher priority than interconnect</description>
                    <bitRange>[29:29]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>TS_ABORT_EN</name>
                    <description>Allow TS to be aborted</description>
                    <bitRange>[30:30]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>DESCR_PF_EN_N</name>
                    <description>When low, enables new descriptor pre-fetch logic for improved latency</description>
                    <bitRange>[31:31]</bitRange>
                    <access>read-write</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>ADAPTER_STATUS</name>
                <description>Adapter Global Status Fields</description>
                <addressOffset>0xFC</addressOffset>
                <size>32</size>
                <access>read-only</access>
                <resetValue>0x0</resetValue>
                <resetMask>0x7FFFFFF</resetMask>
                <fields>
                  <field>
                    <name>TTL_SOCKETS</name>
                    <description>Total number of sockets in this adapter.  This number is different for each instance of the adapter and varies with the core IP needs.</description>
                    <bitRange>[7:0]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>IG_ONLY</name>
                    <description>First socket number that is ingress only.
0..IG_ONLY-1:   Sockets capable of both in and egress
IG_ONLY..TTL_SOCKETS-1:  Ingress sockets only</description>
                    <bitRange>[15:8]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>FQ_SIZE</name>
                    <description>Number of words in a socket fetch queue (FQ).  The total buffer space in the adapter is EG_SOCKETS*FQ_SIZE words of size WORD_SIZE.</description>
                    <bitRange>[24:16]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>WORD_SIZE</name>
                    <description>Internal word size of the prefetch queue (FQ); not the same as bus width of AHB bus or thread interface to the IP.
0: 32b
1: 64b
2: 128b
3: 256b</description>
                    <bitRange>[26:25]</bitRange>
                    <access>read-only</access>
                  </field>
                </fields>
              </register>
            </cluster>
          </cluster>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>LVDSSS</name>
      <description>LVDS IP Registers</description>
      <baseAddress>0x406C0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>262144</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <name>LVDS</name>
          <description>LVDS IP register map</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>CTL</name>
            <description>IP Control Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000007</resetMask>
            <fields>
              <field>
                <name>PHY_ENABLED</name>
                <description>0 - PHY is under reset(excluding non-retention config registers) untill re-enabled again
1 - PHY is enabled and out of reset</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LINK_ENABLED</name>
                <description>0 - LINK_LAYER is under reset(excluding non-retention config registers) untill re-enabled again
1 - LINK_LAYER is enabled and out of reset</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_ENABLED</name>
                <description>0 - DMA_LAYER is under reset(excluding non-retention config registers) untill re-enabled again
1 - DMA_LAYER is enabled and out of reset</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IP_ENABLED</name>
                <description>This bit is a master enable for complete IP, where as bits0,1,2 are enable bits to sub-modules with in IP.
0 - IP is held under reset(excluding non-retention config registers) untill re-enabled again.
1 - IP is enabled and out of reset.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>2</dim>
            <dimIncrement>4</dimIncrement>
            <name>LINK_CONFIG[%s]</name>
            <description>Link Configuration Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x181FF</resetMask>
            <fields>
              <field>
                <name>LVDS_MODE</name>
                <description>Controls if port is configured as LVCMOS or LVDS link.
0 - LVCMOS
1 - LVDS</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GEARING_RATIO</name>
                <description>Indicates geraing ratio used by lanes of the port
0 - 1:1 
1 - 2:1
2 - 4:1
3 - 8:1

In case of LVCMOS, Max gearing ratio to be used is 2:1</description>
                <bitRange>[2:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WIDE_LINK</name>
                <description>If set to 1, it implies both ports are combined to form a wide port.
This should be set only for Port-0. 
Port-1 should always have this bit programmed to 0.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NUM_LANES</name>
                <description>Indicates number of differential Lanes active for LVDS port. In case of LVCMOS indicates number of singled-ended Lanes active per port.

For LVDS (A0):
0 - 1x lane active. Ie Lane[0]
1 -  2x Lanes active. Ie Lane[1:0] 
2 -  4x lanes active. Ie Lane[3:0]
3 -  8x lanes active ie Lane[7:0]
4 -  16x lanes active ie { Lane1[7:0], Lane0[7:0] }

For LVDS (B0):
0 - 1x lane active
1 - 2x lanes active
|
N-1 - Nx lanes active
15 -  16x lanes active ie { Lane1[7:0], Lane0[7:0] }

For LVCMOS,
0 - 8-lines active. ie Lane[7:0]
1 - 16-lines active. ie Lane[15:0]
2 - 24-lines active. ie { Lane1[7:0], Lane0[15:0] }
3 - 32-lines active. ie { Lane1[15:0], Lane0[15:0] }

If 2-ports/links are combined to form a wide port, then GPIF-0 alone will serve this wider port and SW shouldn't enable GPIF-1</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TWO_BIT_SLV_FF</name>
                <description>1 - DUT is configured as 2-bit slave fifo interface
0 - DUT is configured for 5-bit slave fifo interface</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LINK_ENABLE</name>
                <description>When set Link/Port is enabled</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BYPASS_DDR_PHY</name>
                <description>This field is relevant only for lvcmos ddr interface (ie LVDS_MODE = 0 and GEARING_RATIO =1).
There are 2 methods in design to support lvcmos ddr interface.

Method1: 
    MDLL in PHY is used
    Only Rx is supported. Tx is not supported.
    Max interface clock frequency is 160MHz

Method2: 
    PHY+MDLL is bypassed
    Both Rx and Tx are supported.
    Max interface clock frequency is 80MHz

Set this field to 1, only when link/port has to support lvcmos ddr tx too.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>THREAD_INTLV_CTL</name>
            <description>Thread interleave control register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TH0_TH1_INTERLEAVED</name>
                <description>Each thread has dedicated resources like payload count, event count, flags etc.  And in general, only  resources of a thread, specified by FPGA driven commands are updated.

When this bit is set Thread 0 resources only are used for both 0 &amp; 1 threads. 

Sockets/buffers are still maintained separately for both thread 0 &amp; 1, irrespective of the value of this bit field.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH2_TH3_INTERLEAVED</name>
                <description>Each thread has dedicated resources like payload count, event count, flags etc.  And in general, only  resources of a thread, specified by FPGA driven commands are updated.

When this bit is set Thread 0 resources only are used for both 2 &amp; 3 threads. 

Sockets/buffers are still maintained separately for both thread 2 &amp; 3, irrespective of the value of this bit field.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LVDS_INTR_WD0</name>
            <description>LVDS Interrupt Request Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFC0FFFFF</resetMask>
            <fields>
              <field>
                <name>GPIF0_INTERRUPT</name>
                <description>Indicates that the interrupt is from GPIF block. Consult GPIF_INTR register</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>GPIF1_INTERRUPT</name>
                <description>Indicates that the interrupt is from GPIF block. Consult GPIF_INTR register</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PHY_LINK0_INTERRUPT</name>
                <description>Indicates that the interrupt is from PHY block. Consult PHY_INTR register</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PHY_LINK1_INTERRUPT</name>
                <description>Indicates that the interrupt is from PHY block. Consult PHY_INTR register</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>THREAD0_ERR</name>
                <description>Thread controller encountered an error and needs attention.  FW clears this bit after handling the error.  The error code is indicated in LVDS_ERROR.THREAD0_ERR_CODE</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>THREAD1_ERR</name>
                <description>Thread controller encountered an error and needs attention.  FW clears this bit after handling the error.  The error code is indicated in LVDS_ERROR.THREAD1_ERR_CODE</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>THREAD2_ERR</name>
                <description>Thread controller encountered an error and needs attention.  FW clears this bit after handling the error.  The error code is indicated in LVDS_ERROR.THREAD2_ERR_CODE</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>THREAD3_ERR</name>
                <description>Thread controller encountered an error and needs attention.  FW clears this bit after handling the error.  The error code is indicated in LVDS_ERROR.THREAD3_ERR_CODE</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK0_FF_OVER_FLOW</name>
                <description>Port 0 Fifo, at the interface of PHY and Linklayer has overflown</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK1_FF_OVER_FLOW</name>
                <description>Port 1 Fifo, at the interface of PHY and Linklayer has overflown</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK0_TRAINING_DONE</name>
                <description>Port 0 Training done</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK1_TRAINING_DONE</name>
                <description>Port 1 Training done</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK0_TRAINING_BLK_DETECTED</name>
                <description>Link Training block detected on  Port 0</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK1_TRAINING_BLK_DETECTED</name>
                <description>Link Training block detected on  Port 1</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK0_TRAINING_BLK_DET_FAILD</name>
                <description>Link Training block detection on  Port 0 failed</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK1_TRAINING_BLK_DET_FAILD</name>
                <description>Link Training block detection on  Port 1 failed</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>THREAD0_DATA_CRC_ERR</name>
                <description>CRC error occurred on Thread0 data</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>THREAD1_DATA_CRC_ERR</name>
                <description>CRC error occurred on Thread1 data</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>THREAD2_DATA_CRC_ERR</name>
                <description>CRC error occurred on Thread2 data</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>THREAD3_DATA_CRC_ERR</name>
                <description>CRC error occurred on Thread3 data</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK0_L1_ENTRY</name>
                <description>Port 0 L1 entry</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK1_L1_ENTRY</name>
                <description>Port 1 L1 entry</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK0_L1_EXIT</name>
                <description>Port 0 L1 exit</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK1_L1_EXIT</name>
                <description>Port 1 L1 exit</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK0_L3_ENTRY</name>
                <description>Port 0 L3 entry</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK1_L3_ENTRY</name>
                <description>Port 1 L3 entry</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LVDS_INTR_WD1</name>
            <description>LVDS Interrupt Request Register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TH0_HDR_FLGS_CLR_BIT0</name>
                <description>Flags which are cleared by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH0_HDR_FLGS_CLR_BIT1</name>
                <description>Flags which are cleared by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH0_HDR_FLGS_CLR_BIT2</name>
                <description>Flags which are cleared by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH0_HDR_FLGS_CLR_BIT3</name>
                <description>Flags which are cleared by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH1_HDR_FLGS_CLR_BIT0</name>
                <description>Flags which are cleared by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH1_HDR_FLGS_CLR_BIT1</name>
                <description>Flags which are cleared by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH1_HDR_FLGS_CLR_BIT2</name>
                <description>Flags which are cleared by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH1_HDR_FLGS_CLR_BIT3</name>
                <description>Flags which are cleared by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH2_HDR_FLGS_CLR_BIT0</name>
                <description>Flags which are cleared by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH2_HDR_FLGS_CLR_BIT1</name>
                <description>Flags which are cleared by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH2_HDR_FLGS_CLR_BIT2</name>
                <description>Flags which are cleared by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH2_HDR_FLGS_CLR_BIT3</name>
                <description>Flags which are cleared by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH3_HDR_FLGS_CLR_BIT0</name>
                <description>Flags which are cleared by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH3_HDR_FLGS_CLR_BIT1</name>
                <description>Flags which are cleared by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH3_HDR_FLGS_CLR_BIT2</name>
                <description>Flags which are cleared by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH3_HDR_FLGS_CLR_BIT3</name>
                <description>Flags which are cleared by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH0_HDR_FLGS_SET_BIT0</name>
                <description>Flags which are set by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH0_HDR_FLGS_SET_BIT1</name>
                <description>Flags which are set by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH0_HDR_FLGS_SET_BIT2</name>
                <description>Flags which are set by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH0_HDR_FLGS_SET_BIT3</name>
                <description>Flags which are set by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH1_HDR_FLGS_SET_BIT0</name>
                <description>Flags which are set by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH1_HDR_FLGS_SET_BIT1</name>
                <description>Flags which are set by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH1_HDR_FLGS_SET_BIT2</name>
                <description>Flags which are set by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH1_HDR_FLGS_SET_BIT3</name>
                <description>Flags which are set by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH2_HDR_FLGS_SET_BIT0</name>
                <description>Flags which are set by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH2_HDR_FLGS_SET_BIT1</name>
                <description>Flags which are set by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH2_HDR_FLGS_SET_BIT2</name>
                <description>Flags which are set by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH2_HDR_FLGS_SET_BIT3</name>
                <description>Flags which are set by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH3_HDR_FLGS_SET_BIT0</name>
                <description>Flags which are set by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH3_HDR_FLGS_SET_BIT1</name>
                <description>Flags which are set by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH3_HDR_FLGS_SET_BIT2</name>
                <description>Flags which are set by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH3_HDR_FLGS_SET_BIT3</name>
                <description>Flags which are set by LVDS commands to indicate frame/packet header/footer etc</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LVDS_INTR_MASK_WD0</name>
            <description>LVDS Interrupt Mask Register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFC0FFFFF</resetMask>
            <fields>
              <field>
                <name>GPIF0_INTERRUPT</name>
                <description>Mask for corresponding interrupt in LVDS_INTR
0 - Interrupt is masked
1 - interrupt is enabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GPIF1_INTERRUPT</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PHY_LINK0_INTERRUPT</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PHY_LINK1_INTERRUPT</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>THREAD0_ERR</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>THREAD1_ERR</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>THREAD2_ERR</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>THREAD3_ERR</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK0_FF_OVER_FLOW</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK1_FF_OVER_FLOW</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK0_TRAINING_DONE</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK1_TRAINING_DONE</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK0_TRAINING_BLK_DETECTED</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK1_TRAINING_BLK_DETECTED</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK0_TRAINING_BLK_DET_FAILD</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK1_TRAINING_BLK_DET_FAILD</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>THREAD0_DATA_CRC_ERR</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>THREAD1_DATA_CRC_ERR</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>THREAD2_DATA_CRC_ERR</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>THREAD3_DATA_CRC_ERR</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK0_L1_ENTRY</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK1_L1_ENTRY</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK0_L1_EXIT</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK1_L1_EXIT</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK0_L3_ENTRY</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK1_L3_ENTRY</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LVDS_INTR_MASK_WD1</name>
            <description>LVDS Interrupt Mask Register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TH0_HDR_FLGS_CLR</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH1_HDR_FLGS_CLR</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH2_HDR_FLGS_CLR</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH3_HDR_FLGS_CLR</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH0_HDR_FLGS_SET</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH1_HDR_FLGS_SET</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[23:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH2_HDR_FLGS_SET</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[27:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH3_HDR_FLGS_SET</name>
                <description>Mask for corresponding interrupt in LVDS_INTR</description>
                <bitRange>[31:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LVDS_INTR_MASKED_WD0</name>
            <description>LVDS Interrupt Generator</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFC0FFFFF</resetMask>
            <fields>
              <field>
                <name>GPIF0_INTERRUPT</name>
                <description>GPIF0 interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>GPIF1_INTERRUPT</name>
                <description>GPIF1 interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PHY_LINK0_INTERRUPT</name>
                <description>Phy interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PHY_LINK1_INTERRUPT</name>
                <description>Phy interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>THREAD0_ERR</name>
                <description>Thread0 error interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>THREAD1_ERR</name>
                <description>Thread1 error interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>THREAD2_ERR</name>
                <description>Thread2 error interrupt</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>THREAD3_ERR</name>
                <description>Thread3 error interrupt</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LNK0_FF_OVER_FLOW</name>
                <description>Port -0 fifo over flow interrupt</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LNK1_FF_OVER_FLOW</name>
                <description>Port -1 fifo over flow interrupt</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LNK0_TRAINING_DONE</name>
                <description>Port -0 training done interrupt</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LNK1_TRAINING_DONE</name>
                <description>Port -1 training done interrupt</description>
                <bitRange>[11:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LNK0_TRAINING_BLK_DETECTED</name>
                <description>Link Training block detected on Port 0 interrupt</description>
                <bitRange>[12:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LNK1_TRAINING_BLK_DETECTED</name>
                <description>Link Training block detected on Port 0 interrupt</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LNK0_TRAINING_BLK_DET_FAILD</name>
                <description>Link Training block detection on Port 0 failed interrupt</description>
                <bitRange>[14:14]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LNK1_TRAINING_BLK_DET_FAILD</name>
                <description>Link Training block detection on Port 1 failed interrupt</description>
                <bitRange>[15:15]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>THREAD0_DATA_CRC_ERR</name>
                <description>CRC error occurred on Thread0 data</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>THREAD1_DATA_CRC_ERR</name>
                <description>CRC error occurred on Thread1 data</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>THREAD2_DATA_CRC_ERR</name>
                <description>CRC error occurred on Thread2 data</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>THREAD3_DATA_CRC_ERR</name>
                <description>CRC error occurred on Thread3 data</description>
                <bitRange>[19:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LNK0_L1_ENTRY</name>
                <description>Port 0 L1 entry interrupt</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LNK1_L1_ENTRY</name>
                <description>Port 1 L1 entry interrupt</description>
                <bitRange>[27:27]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LNK0_L1_EXIT</name>
                <description>Port 0 L1 exit interrupt</description>
                <bitRange>[28:28]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LNK1_L1_EXIT</name>
                <description>Port 1 L1 exit interrupt</description>
                <bitRange>[29:29]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LNK0_L3_ENTRY</name>
                <description>Port 0 L3 entry interrupt</description>
                <bitRange>[30:30]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LNK1_L3_ENTRY</name>
                <description>Port 1 L3 entry interrupt</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LVDS_INTR_MASKED_WD1</name>
            <description>LVDS Interrupt Generator</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TH0_HDR_FLGS_CLR</name>
                <description>Thread 0 Flags interrupt</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TH1_HDR_FLGS_CLR</name>
                <description>Thread 1 Flags interrupt</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TH2_HDR_FLGS_CLR</name>
                <description>Thread 2 Flags interrupt</description>
                <bitRange>[11:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TH3_HDR_FLGS_CLR</name>
                <description>Thread 3 Flags interrupt</description>
                <bitRange>[15:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TH0_HDR_FLGS_SET</name>
                <description>Thread 0 Flags interrupt</description>
                <bitRange>[19:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TH1_HDR_FLGS_SET</name>
                <description>Thread 1 Flags interrupt</description>
                <bitRange>[23:20]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TH2_HDR_FLGS_SET</name>
                <description>Thread 2 Flags interrupt</description>
                <bitRange>[27:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TH3_HDR_FLGS_SET</name>
                <description>Thread 3 Flags interrupt</description>
                <bitRange>[31:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LVDS_INTR_SET_WD0</name>
            <description>LVDS Interrupt Set Register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFC0FFFF0</resetMask>
            <fields>
              <field>
                <name>THREAD0_ERR</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>THREAD1_ERR</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>THREAD2_ERR</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>THREAD3_ERR</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK0_FF_OVER_FLOW</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK1_FF_OVER_FLOW</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK0_TRAINING_DONE</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK1_TRAINING_DONE</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK0_TRAINING_BLK_DETECTED</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK1_TRAINING_BLK_DETECTED</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK0_TRAINING_BLK_DET_FAILD</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK1_TRAINING_BLK_DET_FAILD</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>THREAD0_DATA_CRC_ERR</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>THREAD1_DATA_CRC_ERR</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>THREAD2_DATA_CRC_ERR</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>THREAD3_DATA_CRC_ERR</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK0_L1_ENTRY</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK1_L1_ENTRY</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK0_L1_EXIT</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK1_L1_EXIT</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK0_L3_ENTRY</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK1_L3_ENTRY</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LVDS_INTR_SET_WD1</name>
            <description>LVDS Interrupt Set Register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TH0_HDR_FLGS_CLR</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH1_HDR_FLGS_CLR</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH2_HDR_FLGS_CLR</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH3_HDR_FLGS_CLR</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH0_HDR_FLGS_SET</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH1_HDR_FLGS_SET</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[23:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH2_HDR_FLGS_SET</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[27:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH3_HDR_FLGS_SET</name>
                <description>bit to set respecitve field in LVDS_INTR register</description>
                <bitRange>[31:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LVDS_ERROR</name>
            <description>LVDS Error Indicator Register</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>THREAD0_ERR_CODE</name>
                <description>The socket based link controller encountered an error and needs attention. Error codes are further described in BROS.  Corresponds to interrupt bit THREAD_ERROR. These error codes are valid only when corresponding THREAD_ERROR interrupt bit is set.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>TH0_DIR_ERROR</name>
                    <description>Write being done to a Read Socket or Read being done to a write skt</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH0_WR_OVERFLOW</name>
                    <description>Write exceeds the space available in the buffer</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH0_RD_UNDERRUN</name>
                    <description>Reads exceeds the byte count of the buffer</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH0_SCK_ACTIVE</name>
                    <description>Socket has gone inactive within a DMA Transfer</description>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH0_ADAP_OVERFLOW</name>
                    <description>Adapter Unable to service write request though buffer is available</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH0_ADAP_UNDERFLOW</name>
                    <description>Adapter Unable to service read request though buffer is available</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH0_READ_FORCE_END</name>
                    <description>A Read socket has been wrapped up</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH0_READ_BURST_ERR</name>
                    <description>A read socket with burstsize &gt; 0 is switched before 8-byte boundary</description>
                    <value>14</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>THREAD1_ERR_CODE</name>
                <description>The socket based link controller encountered an error and needs attention. Error codes are further described in BROS.  Corresponds to interrupt bit THREAD_ERROR.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>TH1_DIR_ERROR</name>
                    <description>Write being done to a Read Socket or Read being done to a write skt</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH1_WR_OVERFLOW</name>
                    <description>Write exceeds the space available in the buffer</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH1_RD_UNDERRUN</name>
                    <description>Reads exceeds the byte count of the buffer</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH1_SCK_ACTIVE</name>
                    <description>Socket has gone inactive within a DMA Transfer</description>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH1_ADAP_OVERFLOW</name>
                    <description>Adapter Unable to service write request though buffer is available</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH1_ADAP_UNDERFLOW</name>
                    <description>Adapter Unable to service read request though buffer is available</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH1_READ_FORCE_END</name>
                    <description>A Read socket has been wrapped up</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH1_READ_BURST_ERR</name>
                    <description>A read socket with burstsize &gt; 0 is switched before 8-byte boundary</description>
                    <value>14</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>THREAD2_ERR_CODE</name>
                <description>The socket based link controller encountered an error and needs attention. Error codes are further described in BROS.  Corresponds to interrupt bit THREAD_ERROR.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>TH2_DIR_ERROR</name>
                    <description>Write being done to a Read Socket or Read being done to a write skt</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH2_WR_OVERFLOW</name>
                    <description>Write exceeds the space available in the buffer</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH2_RD_UNDERRUN</name>
                    <description>Reads exceeds the byte count of the buffer</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH2_SCK_ACTIVE</name>
                    <description>Socket has gone inactive within a DMA Transfer</description>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH2_ADAP_OVERFLOW</name>
                    <description>Adapter Unable to service write request though buffer is available</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH2_ADAP_UNDERFLOW</name>
                    <description>Adapter Unable to service read request though buffer is available</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH2_READ_FORCE_END</name>
                    <description>A Read socket has been wrapped up</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH2_READ_BURST_ERR</name>
                    <description>A read socket with burstsize &gt; 0 is switched before 8-byte boundary</description>
                    <value>14</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>THREAD3_ERR_CODE</name>
                <description>The socket based link controller encountered an error and needs attention. Error codes are further described in BROS.  Corresponds to interrupt bit THREAD_ERROR.</description>
                <bitRange>[15:12]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>TH3_DIR_ERROR</name>
                    <description>Write being done to a Read Socket or Read being done to a write skt</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH3_WR_OVERFLOW</name>
                    <description>Write exceeds the space available in the buffer</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH3_RD_UNDERRUN</name>
                    <description>Reads exceeds the byte count of the buffer</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH3_SCK_ACTIVE</name>
                    <description>Socket has gone inactive within a DMA Transfer</description>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH3_ADAP_OVERFLOW</name>
                    <description>Adapter Unable to service write request though buffer is available</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH3_ADAP_UNDERFLOW</name>
                    <description>Adapter Unable to service read request though buffer is available</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH3_READ_FORCE_END</name>
                    <description>A Read socket has been wrapped up</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TH3_READ_BURST_ERR</name>
                    <description>A read socket with burstsize &gt; 0 is switched before 8-byte boundary</description>
                    <value>14</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>LVDS_EOP_EOT</name>
            <description>LVDS EOP/EOT configuration</description>
            <addressOffset>0x54</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EOP_EOT_CFG</name>
                <description>This register specifies how EOP bits are set or interpretted for Ingress and Egress sockets respectively. 
1: Packet mode behavior 
0: Stream mode behavior
See Architecture Spec for details.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>2</dim>
            <dimIncrement>4</dimIncrement>
            <name>LANE_FIFO_STS[%s]</name>
            <description>Lane fifo status Register</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x81FF01FF</resetMask>
            <fields>
              <field>
                <name>LANE0_FF_OVERFLOW</name>
                <description>Captures overflow status of the fifo used by each lane</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE1_FF_OVERFLOW</name>
                <description>Captures overflow status of the fifo used by each lane</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE2_FF_OVERFLOW</name>
                <description>Captures overflow status of the fifo used by each lane</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE3_FF_OVERFLOW</name>
                <description>Captures overflow status of the fifo used by each lane</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE4_FF_OVERFLOW</name>
                <description>Captures overflow status of the fifo used by each lane</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE5_FF_OVERFLOW</name>
                <description>Captures overflow status of the fifo used by each lane</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE6_FF_OVERFLOW</name>
                <description>Captures overflow status of the fifo used by each lane</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE7_FF_OVERFLOW</name>
                <description>Captures overflow status of the fifo used by each lane</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTRL_LANE_FF_OVERFLOW</name>
                <description>Captures overflow status of the fifo used by each lane</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE0_FF_UNDERFLOW</name>
                <description>Captures underflow status of the fifo used by each lane</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE1_FF_UNDERFLOW</name>
                <description>Captures underflow status of the fifo used by each lane</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE2_FF_UNDERFLOW</name>
                <description>Captures underflow status of the fifo used by each lane</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE3_FF_UNDERFLOW</name>
                <description>Captures underflow status of the fifo used by each lane</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE4_FF_UNDERFLOW</name>
                <description>Captures underflow status of the fifo used by each lane</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE5_FF_UNDERFLOW</name>
                <description>Captures underflow status of the fifo used by each lane</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE6_FF_UNDERFLOW</name>
                <description>Captures underflow status of the fifo used by each lane</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE7_FF_UNDERFLOW</name>
                <description>Captures underflow status of the fifo used by each lane</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTRL_LANE_FF_UNDERFLOW</name>
                <description>Captures underflow status of the fifo used by each lane</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNK_FF_UNDERFLOW</name>
                <description>Async Fifo, at the interface of PHY and Linklayer has underflow</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>2</dim>
            <dimIncrement>4</dimIncrement>
            <name>GPIF_CLK_SEL[%s]</name>
            <description>GPIF Clock selection Register</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x614</resetValue>
            <resetMask>0xF3F</resetMask>
            <fields>
              <field>
                <name>GPIF_CLK_SRC</name>
                <description>GPIF runs on clock which has different sources. This register field selects the clock sources.
0 - usb 480 MHz clock source
1 - HF clk (Max 150MHz)
2 - lvcmos interface clock. 

For LVCMOS mode, program this field to 2.
For LVDS mode, program this field to 0 or 1 (depending on data bandwidth to be supported).

Program this and next register field, such that, GPIF clock frequency is never less than MMIO clock freq div by 5(ie 100/5 = 20MHz).</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>USB_CLK_DIV_VAL</name>
                <description>This register field is valid only when GPIF clock source is USB 480MHz (OR) HF clock. 
0 - Invalid 
1 - Div by 2
2 - Div by 3
3 - Div by 4</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GATE_WAVEFORM_MEM_CLK</name>
                <description>Controls gating of clock to gpif waveform memory.
0 - clock to waveform memory is free running
1 - clock to waveform memory is active only during memory access

Always program this field to 1 for power savings</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LVCMOS_IF_CLK_100MHZ</name>
                <description>This field need to be set when LVCMOS SDR interface clock frequency is 100MHz or less than 100MHz. For rest of the modes(LVCMOS DDR or LVDS) this field need to be set to 0.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WAVEFORM_RAM_CG_DURATION</name>
                <description>Waveform memory clock changes dynamically between peri and other sources(usb, interface sdr clocks) based on GPIF_WAVEFORM_CTRL_STAT.WAVEFORM_VALID setting. This switch can cauise a glitch on output of clock mux. To avoid this clock inputs to mux are gated, whenever there is a transition on WAVEFORM_VALID. And mux select value is changed, when input clocks of mux are inactive(ie gated). This register filed controls duration of clock gate and  mux select is changed during half time of clock gate.

Don't modify default value.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USB_FRM_CNTR_CFG</name>
            <description>USB frame counter config</description>
            <addressOffset>0x6C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>SEL_USB32_FRM_CNT</name>
                <description>0 - select frame counter from USB2.0 IP
1 - select frame counter from USB3.2 IP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIME_STAMP_CLK_DW0</name>
            <description>Timestamp nanosecond counter</description>
            <addressOffset>0x70</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TS_WD0</name>
                <description>LSB 2-bytes of free running timestamp counter.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TS_WD1</name>
                <description>Middle 2-bytes of free running timestamp counter.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIME_STAMP_CLK_DW1</name>
            <description>Timestamp nanosecond counter</description>
            <addressOffset>0x74</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TS_WD2</name>
                <description>Middle 2-bytes of free running timestamp counter.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TS_WD3</name>
                <description>MSB 2-bytes of free running timestamp counter.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>2</dim>
            <dimIncrement>4</dimIncrement>
            <name>SCRSS_VALUE_CFG[%s]</name>
            <description>SCRSS value configuration select</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>TS_CNTR_BITS_4SCRSS</name>
                <description>Decides which 32-bits of 64-bit timestamp counter to be used
0 - lower 32bits of timestamp counter are used
1 - bits 39-8 of timestamp counter are used
2 - bits 41-10 of timestamp counter are used</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUS_INTRVL_BITS_4SCRSS</name>
                <description>Decides which bits of 14-bit frame counter/bus interval counter bits to be used
0 - lower 11bits of bus interval counter are used
1 - bits 13-3 of bus interval counter are used
2 - bits 13-0 of bus interval counter are used</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TRAINING_BLK_CFG</name>
            <description>Training block configuration</description>
            <addressOffset>0x90</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>ENABLE_LNK0_DESKEW</name>
                <description>enable data alignment of all lanes with in Port-0. When Wideport is enabled, this field decides if data alignment for all lanes of port-0 and 1 need to enabled or not. Always program these 2 register fields to 1</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE_LNK1_DESKEW</name>
                <description>enable data alignment of all lanes with in port-1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TRAINING_BLK</name>
            <description>Training block sequence bytes</description>
            <addressOffset>0x94</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x55AA55AA</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRAINING_BLK_BYT0</name>
                <description>Programmable 1st byte of the training block sequence to be expected on each lane, as part of port data alignment/deskew.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRAINING_BLK_BYT1</name>
                <description>Programmable 2nd byte of the training block sequence to be expected on each lane, as part of port data alignment/deskew.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRAINING_BLK_BYT2</name>
                <description>Programmable 3rd byte of the training block sequence to be expected on each lane, as part of port data alignment/deskew.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRAINING_BLK_BYT3</name>
                <description>Programmable 4th byte of the training block sequence to be expected on each lane, as part of port data alignment/deskew.</description>
                <bitRange>[31:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>2</dim>
            <dimIncrement>4</dimIncrement>
            <name>LINK_TRAINING_STS[%s]</name>
            <description>Training block detection status register</description>
            <addressOffset>0x98</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>LANE0_TRAINING_BLK_DTCTD</name>
                <description>Indicates if training block byte is detected by each lane of the port or not.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE1_TRAINING_BLK_DTCTD</name>
                <description>Indicates if training block byte is detected by each lane of the port or not.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE2_TRAINING_BLK_DTCTD</name>
                <description>Indicates if training block byte is detected by each lane of the port or not.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE3_TRAINING_BLK_DTCTD</name>
                <description>Indicates if training block byte is detected by each lane of the port or not.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE4_TRAINING_BLK_DTCTD</name>
                <description>Indicates if training block byte is detected by each lane of the port or not.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE5_TRAINING_BLK_DTCTD</name>
                <description>Indicates if training block byte is detected by each lane of the port or not.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE6_TRAINING_BLK_DTCTD</name>
                <description>Indicates if training block byte is detected by each lane of the port or not.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE7_TRAINING_BLK_DTCTD</name>
                <description>Indicates if training block byte is detected by each lane of the port or not.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTRL_LANE_TRAINING_BLK_DTCTD</name>
                <description>Indicates if training block byte is detected by each lane of the port or not.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE0_TRAINING_BLK_DTCT_FAILED</name>
                <description>Captures training block byte detection fail status of each lane.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE1_TRAINING_BLK_DTCT_FAILED</name>
                <description>Captures training block byte detection fail status of each lane.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE2_TRAINING_BLK_DTCT_FAILED</name>
                <description>Captures training block byte detection fail status of each lane.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE3_TRAINING_BLK_DTCT_FAILED</name>
                <description>Captures training block byte detection fail status of each lane.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE4_TRAINING_BLK_DTCT_FAILED</name>
                <description>Captures training block byte detection fail status of each lane.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE5_TRAINING_BLK_DTCT_FAILED</name>
                <description>Captures training block byte detection fail status of each lane.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE6_TRAINING_BLK_DTCT_FAILED</name>
                <description>Captures training block byte detection fail status of each lane.</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LANE7_TRAINING_BLK_DTCT_FAILED</name>
                <description>Captures training block byte detection fail status of each lane.</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTRL_LANE_TRAINING_BLK_DTCT_FAILED</name>
                <description>Captures training block byte detection fail status of each lane.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DDFT_MUX_SEL</name>
            <description>Debug Mux select</description>
            <addressOffset>0xA0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FF8FFF</resetMask>
            <fields>
              <field>
                <name>DDFT0_MUX_SEL</name>
                <description>Selects internal DUT signal that need to be observed on DDFT0 pin</description>
                <bitRange>[11:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DDFT1_MUX_SEL</name>
                <description>Selects internal DUT signal that need to be observed on DDFT1 pin</description>
                <bitRange>[26:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIO_DDFT_MUX_SEL</name>
            <description>Debug Mux select</description>
            <addressOffset>0xA4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FF8FFF</resetMask>
            <fields>
              <field>
                <name>GPIO_DDFT0_MUX_SEL</name>
                <description>Selects internal DUT signal that need to be observed on GPIO_DDFT0 pin</description>
                <bitRange>[11:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GPIO_DDFT1_MUX_SEL</name>
                <description>Selects internal DUT signal that need to be observed on GPIO_DDFT1 pin</description>
                <bitRange>[26:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOOPBACK_CFG</name>
            <description>Loopback Configuration register</description>
            <addressOffset>0xA8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>LINK0_PUT_LNK1_TESTER_EN</name>
                <description>Link 0 is 'port under test(PUT)' and link-1 is used as tester.
When set link-0 GPIF FSM is tested in loopback. Loopback program stored in HBWSS SRAM is executed and resulting stimulus is applied to link-0 interface.
Link which is executing loopback program (here Link-1) should be set as lvcmos SDR link.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LINK1_PUT_LNK0_TESTER_EN</name>
                <description>Link 1 is 'port under test(PUT)' and link-0 is used as tester.
When set link-1 GPIF FSM is tested in loopback. Loopback program stored in HBWSS SRAM is executed and resulting stimulus is applied to link-1 interface.
Link which is executing loopback program (here Link-0) should be set as lvcmos SDR link.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>2</dim>
            <dimIncrement>4</dimIncrement>
            <name>LVDS_CHAR_CFG[%s]</name>
            <description>LVDS lanes characterisation config register</description>
            <addressOffset>0xB0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x800001FF</resetMask>
            <fields>
              <field>
                <name>LVDS_DATA_LANE_EN</name>
                <description>Controls activation of LVDS data lanes. Each bit controls respective data lanes. Ie bit[0] controls data lane 0, bit[1] data lane 1 and so on.

0 - Lane in not activated
1 - Lane is activated</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LVDS_CTRL_LANE_EN</name>
                <description>Controls activation of LVDS Control lane.

0 - Lane in not activated
1 - Lane is activated

Note: CTRL lane and Data Lane 0 are mutually exclusive. Both of them should not be active at any time. This is because data driven on control/data lanes will occupy same bits in HBWSS SRAM memory.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LVDS_CHAR_EN</name>
                <description>Enables characterisation of LVDS lanes</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLK_GATE_DIS</name>
            <description>Thread controller Clock gate disable config register</description>
            <addressOffset>0xB8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>TH0_CLK_GATE_DISABLE</name>
                <description>By default clocks to unused thread controllers are gated to reduce power consumption. This register bit controls whether to enable or disable the clock gating of thread 0 controller.

0 - Enable clock gating of thread controller clock
1 - Disable clock gating of thread controller clock</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH1_CLK_GATE_DISABLE</name>
                <description>By default clocks to unused thread controllers are gated to reduce power consumption. This register bit controls whether to enable or disable the clock gating of thread 1 controller.

0 - Enable clock gating of thread controller clock
1 - Disable clock gating of thread controller clock</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH2_CLK_GATE_DISABLE</name>
                <description>By default clocks to unused thread controllers are gated to reduce power consumption. This register bit controls whether to enable or disable the clock gating of thread 2 controller.

0 - Enable clock gating of thread controller clock
1 - Disable clock gating of thread controller clock</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH3_CLK_GATE_DISABLE</name>
                <description>By default clocks to unused thread controllers are gated to reduce power consumption. This register bit controls whether to enable or disable the clock gating of thread 3 controller.

0 - Enable clock gating of thread controller clock
1 - Disable clock gating of thread controller clock</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>VERSION_SEL</name>
            <description>lvds ip version select</description>
            <addressOffset>0xBC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>A0_SEL</name>
                <description>LVDS IP verison select.
0: B0 version
1: A0 version

Never program this register. This field is provided as a fall back option to A0, if needed.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SKEW_MONITOR_A0_SEL</name>
                <description>Skew Monitor phase selection value control between A0 and B0
0: B0 version - Phase selection decided by deskew algortihm will not be disturbed/updated by Skew monitor. Skew monitor will just trigger interrupt, in case phase selected by deskew algo is no more able to sample data correctly over PVT variations.

1: A0 version - Phase selection decided by deskew algortihm will  be disturbed/updated by Skew monitor.

Never program this register. This field is provided as a fall back option to A0, if needed.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <cluster>
            <name>LVDS_LOW_PWR_INTR</name>
            <description>LVDS Low power and Wakeup Interrupt registers</description>
            <addressOffset>0x000000C0</addressOffset>
            <register>
              <name>LVDS_WAKEUP_INTR</name>
              <description>LVDS_WAKEUP Interrupt Request Register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>LNK0_L3_EXIT</name>
                  <description>port0 L3 exit interrupt</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LNK1_L3_EXIT</name>
                  <description>port1 L3 exit interrupt</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LVDS_WAKEUP_INTR_MASK</name>
              <description>LVDS_WAKEUP Interrupt Mask Register</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>LNK0_L3_EXIT</name>
                  <description>port0 L3 exit interrupt
0 - Interrupt is masked 
1 - interrupt is enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LNK1_L3_EXIT</name>
                  <description>port1 L3 exit interrupt</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LVDS_WAKEUP_INTR_MASKED</name>
              <description>LVDS_WAKEUP Interrupt Generator</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>LNK0_L3_EXIT</name>
                  <description>port0 L3 exit interrupt</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LNK1_L3_EXIT</name>
                  <description>port1 L3 exit interrupt</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LVDS_WAKEUP_INTR_SET</name>
              <description>LVDS_WAKEUP Interrupt Set Register</description>
              <addressOffset>0xC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>LNK0_L3_EXIT</name>
                  <description>port0 L3 exit interrupt</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LNK1_L3_EXIT</name>
                  <description>port1 L3 exit interrupt</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>2</dim>
              <dimIncrement>4</dimIncrement>
              <name>LOW_PWR_CTL[%s]</name>
              <description>Low power mode control register</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xA0093</resetValue>
              <resetMask>0x7F01F3</resetMask>
              <fields>
                <field>
                  <name>MASK_L1_ENTRY</name>
                  <description>When set, HW is disabled from entering L1 low power mode</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MASK_L3_ENTRY</name>
                  <description>When set, HW is disabled from entering L3 low power mode</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AUTO_MODE</name>
                  <description>0: FW controlls disabling of IOs
1: HW controlls disabling of Ios
Don't program this field. Leave it with default value.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SEL_ON_OFF</name>
                  <description>CPU can used this register to inform the hardware to drive the ON value or OFF value of IOs
0: Select OFF
1: Select ON
Don't program this field. Leave it with default value.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IO_OFF_VALUE</name>
                  <description>The Off value used by Hardware in Automode to turn off the IO's.
Don't program this field. Leave it with default value.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IO_ON_VALUE</name>
                  <description>The ON value used by Hardware to turn on the IO's.
Don't program this field. Leave it with default value.</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>L3_GPIO_CTL</name>
                  <description>Decides if GPIO or one of the LVCMOS CTL pin(default CTL[6]) is used by FPGA to push mxs40lvds in to L3 entry/exit
0 - CTL[3]
1 - GPIO</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>L3_TO_IO_OFF_DLY</name>
                  <description>Amount of delay between Link entering in to L3 and LVDS IO's being disabled by HW, in terms of MMIO clock cycles.</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
          <register>
            <dim>64</dim>
            <dimIncrement>4</dimIncrement>
            <name>TH0_TH1_METADATA_RAM[%s]</name>
            <description>Metadata Memory</description>
            <addressOffset>0x100</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>METADATA</name>
                <description>Metadata</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>64</dim>
            <dimIncrement>4</dimIncrement>
            <name>TH2_TH3_METADATA_RAM[%s]</name>
            <description>Metadata Memory</description>
            <addressOffset>0x200</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>METADATA</name>
                <description>Metadata</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <cluster>
            <dim>4</dim>
            <dimIncrement>512</dimIncrement>
            <name>THREAD[%s]</name>
            <description>Set of registers for a thread</description>
            <addressOffset>0x00000400</addressOffset>
            <register>
              <name>GPIF_DATA_CTRL</name>
              <description>Data Control Register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xF</resetMask>
              <fields>
                <field>
                  <name>ING_DATA_VALID</name>
                  <description>Indicates data available in INGRESS_DATA.  Cleared by s/w when data processed.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EG_DATA_VALID</name>
                  <description>Software writes 1 to indicate a valid word is present in the address register.  Hardware writes 0 to indicate that the data is used and new word can be written.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IN_ADDR_VALID</name>
                  <description>Indicates address available in INGRESS_ADDRESS.  Cleared by s/w when address processed.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EG_ADDR_VALID</name>
                  <description>Software writes 1 to indicate a valid word is present in the address register.  Hardware writes 0 to indicate that the data is used and new word can be written.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_INGRESS_DATA_WORD0</name>
              <description>Socket Ingress Data</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DATA</name>
                  <description>Ingress Data.  4 registers together will hold 128-bits of GPIF_BUS_CONFIG.BUS_WIDTH.  No packing/unpacking is done.  MSB's of combined value {WORD3, WORD2, WORD1, WORD0} will be 0s</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_INGRESS_DATA_WORD1</name>
              <description>Socket Ingress Data</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DATA</name>
                  <description>Ingress Data.  4 registers together will hold 128-bits of GPIF_BUS_CONFIG.BUS_WIDTH.  No packing/unpacking is done.  MSB's of combined value {WORD3, WORD2, WORD1, WORD0} will be 0s</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_INGRESS_DATA_WORD2</name>
              <description>Socket Ingress Data</description>
              <addressOffset>0xC</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DATA</name>
                  <description>Ingress Data.  4 registers together will hold 128-bits of GPIF_BUS_CONFIG.BUS_WIDTH.  No packing/unpacking is done.  MSB's of combined value {WORD3, WORD2, WORD1, WORD0} will be 0s</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_INGRESS_DATA_WORD3</name>
              <description>Socket Ingress Data</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DATA</name>
                  <description>Ingress Data.  4 registers together will hold 128-bits of GPIF_BUS_CONFIG.BUS_WIDTH.  No packing/unpacking is done.  MSB's of combined value {WORD3, WORD2, WORD1, WORD0} will be 0s</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_EGRESS_DATA_WORD0</name>
              <description>Socket Egress Data</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DATA</name>
                  <description>Egress Data.  Both WORD1 and WORD0 will old only 64-bits of GPIF_BUS_CONFIG.BUS_WIDTH.  No packing/unpacking is done.  MSB's of combined value {WORD1, WORD0} is ignored.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_EGRESS_DATA_WORD1</name>
              <description>Socket Egress Data</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DATA</name>
                  <description>Egress Data.  Both WORD1 and WORD0 will old only 64-bits of GPIF_BUS_CONFIG.BUS_WIDTH.  No packing/unpacking is done.  MSB's of combined value {WORD1, WORD0} is ignored.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_INGRESS_ADDRESS</name>
              <description>Thread Ingress Address</description>
              <addressOffset>0x1C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ADDRESS</name>
                  <description>Ingress Address</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_EGRESS_ADDRESS</name>
              <description>Thread Egress Address</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ADDRESS</name>
                  <description>Egress Address</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_THREAD_CONFIG</name>
              <description>Thread Configuration Register</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x10400</resetValue>
              <resetMask>0xBFFF0F9F</resetMask>
              <fields>
                <field>
                  <name>THREAD_NUM</name>
                  <description>Socket_number[3:0] = {THREAD_SOCK, THREAD_NUM}
Only in case of LVDS mode, when thread and socket are selected by FPGA separately, this 4-bit socket field is split in to 2 parts (thread and socket number). Here first thread need to be selected and then socket.
For rest of the modes, all the 4-bits are treated as socket number. And any 16 sockets can be assigned to any thread.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>THREAD_SOCK</name>
                  <description>Used in conjunction with THREAD_NUM field above.</description>
                  <bitRange>[3:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADAPTOR_NUM</name>
                  <description>This field will indicate DMA adaptor number used by sockets. HW will set this field to 0 for sockets 0-15(which will be used by Thread 0 and 1) and 1 for socket16-31(used by thread 2 and 3).</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WM_CFG</name>
                  <description>0: Assert partial flag when number of samples (remaining available for reading/writing) is less than or equal to the watermark.
1: Assert when samples are more than the watermark.</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BURST_SIZE</name>
                  <description>Log2 of burst size ( 1: 2 words, 2: 4 words, etc). Programmed to support systems that work with fixed burst sizes. A burst is defined as a portion of transfer that  unconditionally completes once initiated. The system must always transfer an entire burst before responding to a change in a partial flag . In transfers that involve short packet, the PIB HW will automatically append zeros/truncate data to do its part  in preserving the above mentioned definition of burst. Burst size is a power of 2 and must be programmed to a value greater than watermark when partial flag is used.Buffer sizes used should be integral multiple of the burst size. Maximum value is 14.  When value is &gt;0, any socket switching must occur on 8 byte boundaries.Besides, this field needs to be programmed to a non-zero value to support bandwidth&gt;200MBps on P-Port.</description>
                  <bitRange>[11:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WATERMARK</name>
                  <description>Watermark position. Indicates number words that would be subtracted from the end of usable space/data. Watermark needs to be programmed to a value greater than the round trip flag latency of the system. 

This latency is a sum of three quantities namely  (1) Benicia latency between seeing the end of the last burst that completely fills the buffer to the time the full/empty flag updates (can be calculated from generic gpif params), (2). Expected time of arrival of a flow control signal that would prevent the AP from issuing the next burst (as measured from the end of the burst) (3). Any additional group latency between the APs dma controller logic and the interface pins in both directions.

 'end of usable space/data' is calculated using one of the equations depending on the context. (1) For normal write transfers in either PP modes,  this is the size of the buffer to be produced into.  (2) For normal read transfers in either PP modes, this is the byte count of the buffer to be consumed. (3) For partial buffer read or write transfers in PP mode 1, this is the value of written by AP into the PP_DMA_SIZE register rounded up to an integral number of BURSTSIZE quanta.</description>
                  <bitRange>[29:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLE_THREAD_CTLR</name>
                  <description>Enables the threadcontroller for operation.  Can be set by firmware after initializing THEAD_SOCK and other fields.  Will be set by h/w when THREAD_SOCK register field of this register, is updated by h/w.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>VARW0</name>
              <description>Variable Register</description>
              <addressOffset>0x2C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>VARW0</name>
                  <description>Variable  Word 0</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>VARW1</name>
              <description>Variable Register</description>
              <addressOffset>0x30</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>VARW1</name>
                  <description>Variable Word 1</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PTSSS</name>
              <description>PTS snapshot register</description>
              <addressOffset>0x34</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>PTSSS_WD0</name>
                  <description>PTS timer value</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PTSSS_WD1</name>
                  <description>PTS timer value</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SCRSS_DW0</name>
              <description>SCR snapshot register</description>
              <addressOffset>0x38</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>SCRSS_WD0</name>
                  <description>LSB 2-bytes of SCR timer value</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SCRSS_WD1</name>
                  <description>Middle 2-bytes of SCR timer value</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SCRSS_DW1</name>
              <description>SCR snapshot register</description>
              <addressOffset>0x3C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>SCRSS_WD2</name>
                  <description>MSB 2-bytes of SCR timer, which is nothing but frame number</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>HDR_FLGS</name>
              <description>Header Flags</description>
              <addressOffset>0x40</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xF</resetMask>
              <fields>
                <field>
                  <name>FLG</name>
                  <description>Flags for indicating frame/line/packet header, footer etc.
These flags will be set or clear by FPGA. Setting/Clearing of these flags will raise an interrupt to CPU.</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>EVC_VAR0_DW0</name>
              <description>Event Count Variable0</description>
              <addressOffset>0x50</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>EVC_V0_WD0</name>
                  <description>Bytes 1 and 0 of 8-byte event counter</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EVC_V0_WD1</name>
                  <description>Bytes 2 and 3 of 8-byte event counter</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>EVC_VAR0_DW1</name>
              <description>Event Count Variable0</description>
              <addressOffset>0x54</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>EVC_V0_WD2</name>
                  <description>Bytes 5 and 4 of 8-byte event counter</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EVC_V0_WD3</name>
                  <description>Bytes 7 and 6 of 8-byte event counter</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>EVC_VAR1_DW0</name>
              <description>Event Count Variable1</description>
              <addressOffset>0x58</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>EVC_V1_WD0</name>
                  <description>Bytes 1 and 0 of 8-byte event counter</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EVC_V1_WD1</name>
                  <description>Bytes 2 and 3 of 8-byte event counter</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>EVC_VAR1_DW1</name>
              <description>Event Count Variable1</description>
              <addressOffset>0x5C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>EVC_V1_WD2</name>
                  <description>Bytes 5 and 4 of 8-byte event counter</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EVC_V1_WD3</name>
                  <description>Bytes 7 and 6 of 8-byte event counter</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PLC_DW0</name>
              <description>Payload Count register</description>
              <addressOffset>0x60</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>PLC_WD0</name>
                  <description>Bytes 1 and 0 of 8-byte data payload counter. Gets incremented during data transfers if EPC (Enable Payload Count), command was sent on LVDS control lane previously</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PLC_WD1</name>
                  <description>Bytes 3 and 2 of 8-byte of data payload counter. Gets incremented during data transfers if EPC (Enable Payload Count), command was sent on LVDS control lane previously</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PLC_DW1</name>
              <description>Payload Count register</description>
              <addressOffset>0x64</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>PLC_WD2</name>
                  <description>Bytes 5 and 4 of 8-byte data payload counter. Gets incremented during data transfers if EPC (Enable Payload Count), command was sent on LVDS control lane previously</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PLC_WD3</name>
                  <description>Bytes 7 and 6 of 8-byte of data payload counter. Gets incremented during data transfers if EPC (Enable Payload Count), command was sent on LVDS control lane previously</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PAYLOAD_CFG</name>
              <description>Payload Config register</description>
              <addressOffset>0x68</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>CNT_MDATA_AS_PAYLOAD</name>
                  <description>Include metadata as part of payload count</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CNT_CRC_AS_PAYLOAD</name>
                  <description>Include CRC  as part of payload count</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DCRC_CONFIG</name>
              <description>Data CRC Configuration register</description>
              <addressOffset>0x70</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x37</resetMask>
              <fields>
                <field>
                  <name>BIT_ENDIAN</name>
                  <description>Indicates the order in which the bits in each byte are brought through the CRC shift register.
0: LSb first
1: MSb first</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BYTE_ENDIAN</name>
                  <description>Indicates the order in which bytes in a 32b word are brought through the CRC shift register. This is independent from the endianness of the interface.
0: LSB first
1: MSB first</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CRC_ENABLE</name>
                  <description>Enables CRC calulation</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CRC_VAL_BIT_ENDIAN</name>
                  <description>Gives flexibility to change the order of CRC value bits
0: LSb first
1: MSb first

Valid only for Rx data path. Not valid for Tx Data</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CRC_VAL_BYTE_ENDIAN</name>
                  <description>Gives flexibility to change the order of CRC value bytes
0: LSB first
1: MSB first

Valid only for Rx data path. Not valid for Tx Data</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DCRC</name>
              <description>Data CRC</description>
              <addressOffset>0x74</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>INITIAL_VALUE</name>
                  <description>Initial CRC value. Whenever INITDCRC command is received, CRC calculator will be loaded with this initial value.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CRC_VALUE</name>
                  <description>Holds 16-bit CRC calculated on received payload data. Polynomila used is X16 + X12 + X5 + 1</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DCRC_STS</name>
              <description>Data CRC status</description>
              <addressOffset>0x78</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x80FFFFFF</resetMask>
              <fields>
                <field>
                  <name>CRC_RECEIVED</name>
                  <description>A CRC value received on the data inputs by the state machine</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CRC_ERR_CNT</name>
                  <description>Counts number of corrupted packets received by this thread</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CRC_ERROR</name>
                  <description>Indicates data packets received by this thread has CRC error. CRC calculted by FX3G2 on data driven by FPGA, doesn't match with CRC value provided by FPGA.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MCRC_CONFIG</name>
              <description>MetaData(or Header) CRC Configuration register</description>
              <addressOffset>0x80</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>MCRC_BIT_ENDIAN</name>
                  <description>Indicates the order in which the bits in each byte are brought through the CRC shift register.
0: LSb first
1: MSb first</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MCRC_BYTE_ENDIAN</name>
                  <description>Indicates the order in which bytes in a 32b word are brought through the CRC shift register. This is independent from the endianness of the interface.
0: LSB first
1: MSB first</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MCRC_ENABLE</name>
                  <description>Enables CRC calulation</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MCRC</name>
              <description>MetaData CRC</description>
              <addressOffset>0x84</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>INITIAL_VALUE</name>
                  <description>Initial CRC value. Whenever INITMCRC command is received, CRC calculator will be loaded with this initial value.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CRC_VALUE</name>
                  <description>Holds 16-bit CRC calculated on Header data. Polynomila used is X16 + X12 + X5 + 1</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>THREAD_DMA_INTF_CFG</name>
              <description>Thread controller DMA interface configuration</description>
              <addressOffset>0x88</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x5</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>RQ_EMPTY_DLY</name>
                  <description>Controls number of cycles by which, checking of  'thread_rq_empty' signal driven by DMA layer is to be delayed, after 'thread_cq_count' became 0.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MD0_CTRL</name>
              <description>Metadata-0 Control word</description>
              <addressOffset>0x90</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>MD_REF_CTL</name>
                  <description>Each bit of this field controls whether value present in Metadata ram is a constant or reference to a register, whose value should be used as Metadata.
0 - Metadata constant value
1 - Reference to Register Variable whose address is specified in Metadata</description>
                  <bitRange>[26:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MD_SIZE</name>
                  <description>Holds the size in bytes of metadata to be inserted.
Should be programmed to even number only (ie multiple of 2 bytes). Allowed values are 0, 2, 4, 6, 8......30.
0 - indicates 32 bytes
If Odd value is programmed, then it'll be converted to immediate upper even value and used(ie if programmed to 9, it'll be used as 10)</description>
                  <bitRange>[31:27]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MD1_CTRL</name>
              <description>Metadata-1 Control word</description>
              <addressOffset>0x94</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>MD_REF_CTL</name>
                  <description>Each bit of this field controls whether value present in Metadata ram is a constant or reference to a register, whose value should be used as Metadata.
0 - Metadata constant value
1 - Reference to Register Variable whose address is specified in Metadata</description>
                  <bitRange>[26:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MD_SIZE</name>
                  <description>Holds the size in bytes of metadata to be inserted.
Should be programmed to even number only (ie multiple of 2 bytes). Allowed values are 0, 2, 4, 6, 8......30.
0 - indicates 32 bytes
If Odd value is programmed, then it'll be converted to immediate upper even value and used(ie if programmed to 9, it'll be used as 10)</description>
                  <bitRange>[31:27]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MD2_CTRL</name>
              <description>Metadata-2 Control word</description>
              <addressOffset>0x98</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>MD_REF_CTL</name>
                  <description>Each bit of this field controls whether value present in Metadata ram is a constant or reference to a register, whose value should be used as Metadata.
0 - Metadata constant value
1 - Reference to Register Variable whose address is specified in Metadata</description>
                  <bitRange>[26:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MD_SIZE</name>
                  <description>Holds the size in bytes of metadata to be inserted.
Should be programmed to even number only (ie multiple of 2 bytes). Allowed values are 0, 2, 4, 6, 8......30.
0 - indicates 32 bytes
If Odd value is programmed, then it'll be converted to immediate upper even value and used(ie if programmed to 9, it'll be used as 10)</description>
                  <bitRange>[31:27]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MD3_CTRL</name>
              <description>Metadata-3 Control word</description>
              <addressOffset>0x9C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>MD_REF_CTL</name>
                  <description>Each bit of this field controls whether value present in Metadata ram is a constant or reference to a register, whose value should be used as Metadata.
0 - Metadata constant value
1 - Reference to Register Variable whose address is specified in Metadata</description>
                  <bitRange>[26:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MD_SIZE</name>
                  <description>Holds the size in bytes of metadata to be inserted.
Should be programmed to even number only (ie multiple of 2 bytes). Allowed values are 0, 2, 4, 6, 8......30.
0 - indicates 32 bytes
If Odd value is programmed, then it'll be converted to immediate upper even value and used(ie if programmed to 9, it'll be used as 10)</description>
                  <bitRange>[31:27]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
          <cluster>
            <dim>2</dim>
            <dimIncrement>12288</dimIncrement>
            <name>GPIF[%s]</name>
            <description>GPIF-II Configuration Registers</description>
            <addressOffset>0x00001000</addressOffset>
            <register>
              <name>GPIF_CONFIG</name>
              <description>GPIF Configuration Register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x40020</resetValue>
              <resetMask>0x7BCF7</resetMask>
              <fields>
                <field>
                  <name>CTRL_COMP_ENABLE</name>
                  <description>1: Enable the control Comparator
0: Disable it.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADDR_COMP_ENABLE</name>
                  <description>1: Enable the address Comparator
0: Disable it.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DATA_COMP_ENABLE</name>
                  <description>1: Enable the data Comparator
0: Disable it.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CLK_SOURCE</name>
                  <description>Controls if clock used for sampling LVCMOS interface signals is from PAD or from PLL. In other words, this bit decides who will drive LVCMOS clock pin, is it DUT or FPGA.
0: Clock is driven by External FPGA
1: DUT drives clock pin (PLL generated clock is routed on to lvcmos clock pin)</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SPARE0</name>
                  <description>Indicates whether DUT drives CLK pin or FPGA, in lvcmos mode.  No effect when CLK_SOURCE=0.
0: Do not output clock on CLK pin (typical of async mode)
1: Output clock on CLK pin (typical of sync master mode)</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EN_CLK_IN</name>
                  <description>Enable Rx circuit(or input enable) of LVCMOS clock pad. Always set to 1, when port is configured to LVCMOS mode.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DOUT_POP_EN</name>
                  <description>1: Use update_dout (alpha) to also trigger rq_pop (which is normally beta)
0: rq_pop is a separate beta</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENDIAN</name>
                  <description>Endianness of interface. Valid for lvcmos interface only. For LVDS interface it is always little endian, and this register field has to be set to 0 for lvds mode.
0: Little Endian
1: Big Endian</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADDR_COMP_TOGGLE</name>
                  <description>1: Comparator outputs true when any of the unmasked bits change value.
0: Comparator outputs true when bits match a target value.</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CTRL_COMP_TOGGLE</name>
                  <description>1: Comparator outputs true when any of the unmasked bits change value.
0: Comparator outputs true when bits match a target value.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DATA_COMP_TOGGLE</name>
                  <description>1: Comparator outputs true when any of the unmasked bits change value.
0: Comparator outputs true when bits match a target value.</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>THREAD_IN_STATE</name>
                  <description>0: Normal operation
1: The thread number for an operation comes from the state description rather than the THREAD_CONFIG register (see GPIF_Modes for more information)</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>THREAD_IN_CTL_BYT</name>
                  <description>0: Normal operation
1: The thread number for an operation comes from the control byte command rather than the THREAD_CONFIG register (see GPIF_Modes for more information)</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SOCKET_IN_CTL_BYT</name>
                  <description>0: Normal operation
1: The socket number for an operation comes from the control byte command rather than the THREAD_CONFIG register (see GPIF_Modes for more information)</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EOP_4M_FSM</name>
                  <description>Decides whether PKTEND control signal(in case of lvcmos or enhanced lvcmos) (or) EOP control byte command(lvds or enhanced lvcmos), to be routed via GPIF FSM OR bypass FSM.   
0 - PKTEND control signal generates EOP, bypassing GPIF FSM
1 - EOP generated by GPIF FSM, on receiving PKTEND control signal.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_BUS_CONFIG</name>
              <description>Bus Configuration Register</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x2000</resetValue>
              <resetMask>0xFF1DFFFF</resetMask>
              <fields>
                <field>
                  <name>TH0_PTS_TRIG_PRESENT</name>
                  <description>CTL[X] is used as thread0 PTS trigger and is used to take snapshot of timestamp counter.

By default X is 6. But any CTL pin can be used for this purpose using GPIF_CTL_FUNC1.TH0_PTS_TRIG_CTL_SEL

0 - use SPTSSS control byte command used for taking PTS snapshot of  timestamp counter
1 - use CTL pin for taking PTS snapshot</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TH1_PTS_TRIG_PRESENT</name>
                  <description>CTL[X] is used as thread0 PTS trigger and is used to take snapshot of timestamp counter.

By default X is 7. But any CTL pin can be used for this purpose using GPIF_CTL_FUNC1.TH0_PTS_TRIG_CTL_SEL</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TH2_PTS_TRIG_PRESENT</name>
                  <description>CTL[X] is used as thread0 PTS trigger and is used to take snapshot of timestamp counter.

By default X is 8. But any CTL pin can be used for this purpose using GPIF_CTL_FUNC1.TH0_PTS_TRIG_CTL_SEL</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TH3_PTS_TRIG_PRESENT</name>
                  <description>CTL[X] is used as thread0 PTS trigger and is used to take snapshot of timestamp counter.

By default X is 9. But any CTL pin can be used for this purpose using GPIF_CTL_FUNC1.TH0_PTS_TRIG_CTL_SEL</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADR_CTRL</name>
                  <description>Number of control lines overridden by address lines.  Control signals CTRL[15] to CTRL[16-ADR_CTRL] are not connected to pins.  Instead those pins are designated as address signals. Which address signals depends on the other mode fields above; see architecture spec for details.  In other words:  if ADR_CTRL=0 all CTRL lines are connected to pins, if ADR_CTRL=1, CTRL[15] is not connected and so on.</description>
                  <bitRange>[8:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CE_PRESENT</name>
                  <description>CTRL[X] is CE and should be used to disable DQ drivers.
By default X is 0. But any CTL pin can be used for this purpose using GPIF_CTL_FUNC0.CE_CTL_SEL</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WE_PRESENT</name>
                  <description>CTRL[X] is WE and should be used to disable DQ drivers
By default X is 1. But any CTL pin can be used for this purpose using GPIF_CTL_FUNC0.WE_CTL_SEL</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EM_VLD_PRESENT</name>
                  <description>When this bit is set to 1, CTRL[X] pin value will decide if DQ[15:8] will carry data or control byte information in LVCMOS Enhanced mode.
CTRL[X] = 0, then DQ[15:8] is carrying control_byte
CTRL[X] = 1, then DQ[15:8] is carrying data byte

By default X is 5. But any CTL pin can be used for this purpose using GPIF_CTL_FUNC0.EM_VLD_CTL_SEL</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OE_PRESENT</name>
                  <description>CTRL[X] is OE and should be used to tri-state DQ lines.
If WE_PRESENT=1 also, then OE will take precedence over WE.  In other words, when WE is asserted, then output drivers are off, regardless of value of OE input.

By default X is 2. But any CTL pin can be used for this purpose using GPIF_CTL_FUNC0.OE_CTL_SEL</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EM_VLD_MASK_CS_WR</name>
                  <description>Controls whether to mask CS and WR from passing to GPIF FSM, whenever EM_VLD control pin is asserted. This field is valid only when 'EM_VLD_PRESENT' is set to 1.

This field is a back up option and is receommended to always set this to 1.</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIO0_PRESENT</name>
                  <description>CTRL[7] is to be treated as IO that is driven out when the alpha specified in FIO0_CONF is asserted (ignore CTRL_BUS_DIRECTION)</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIO1_PRESENT</name>
                  <description>CTRL[8] is to be treated as IO that is driven out when the alpha specified in FIO1_CONF is asserted (ignore CTRL_BUS_DIRECTION)</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CNTR_PRESENT</name>
                  <description>CTRL[9] is connected to the selected control counter bit instead of a control signal</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SPARE2</name>
                  <description>0: Assert DRQ on deassertion of DACK
1: Assert DRQ on assertion of DACK
2: Deassert DRQ on deassertion of DACK
3: Deassert DRQ on assertion of DACK</description>
                  <bitRange>[19:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SPARE3</name>
                  <description>1: Assert DRQ on rising edge of DMA_READY. Typical case, DRQ_MODE=2, this bit 1.
0: Do nothing</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIO0_CONF</name>
                  <description>Designates control to be used to enable output drivers of FIO0 (CTRL[7])
0 to 3: Use the alpha 4 to 7 to switch FIO0 direction.
8-11: Use beta 0-3.</description>
                  <bitRange>[27:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIO1_CONF</name>
                  <description>Designates control to be used to enable output drivers of FIO1 (CTRL[8])
0 to 3: Use the alpha  4-7 to switch FIO1 direction.
8-11: Use beta 0-3.</description>
                  <bitRange>[31:28]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_BUS_CONFIG2</name>
              <description>Bus Configuration Register #2</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F3F3F07</resetMask>
              <fields>
                <field>
                  <name>STATE_FROM_CTRL</name>
                  <description>0: Normal operation
1,2,3: STATE7 indicates Lambda number to be used for state number bit 7
2,3: STATE6 indicates Lambda number to be used for state number bit 6
3: STATE5 indicates Lambda number to be used for state number bit 5</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STATE5</name>
                  <description>Lambda number to be used for state number bit 5</description>
                  <bitRange>[13:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STATE6</name>
                  <description>Lambda number to be used for state number bit 6</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STATE7</name>
                  <description>Lambda number to be used for state number bit 7</description>
                  <bitRange>[29:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_AD_CONFIG</name>
              <description>Address/Data configuration register</description>
              <addressOffset>0xC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF03FF</resetMask>
              <fields>
                <field>
                  <name>DQ_OEN_CFG</name>
                  <description>N/A</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>A_OEN_CFG</name>
                  <description>N/A</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AIN_SELECT</name>
                  <description>0: Connect AIN to the active socket number of thread specified by AIN_DATA
1: Connect AIN to INGRESS_ADDRESS register
2: Connect AIN to the socket pointed to by ADDRESS_THREAD register</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AOUT_SELECT</name>
                  <description>0:  Connect AOUT to ADDR_COUNTER
1: Connect AOUT to EGRESS_ADDRESS register
2: Connect AOUT to the socket pointed to by ADDRESS_THREAD register</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DOUT_SELECT</name>
                  <description>0: Connect DOUT to the socket pointed to by AIN_DATA or EGRESS_DATA register (as determined by beta 'register_access')
1: Connect DOUT to DATA_COUNTER</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AIN_DATA</name>
                  <description>This field determines which thread number to use for data accesses:
0: specified by A1:A0.
1: specified by DATA_THREAD
If AIN_SELECT=0 this field also determines the thread number for which to change the active socket on awq_push:
0: The active socket of thread A1:A0 is changed (3 bits only)
1: The active socket of thread DATA_THREAD is changed (full 5 bits)</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADDRESS_THREAD</name>
                  <description>Thread number to be used for addresses;only relevant when AIN_SELECT!=0
When this register is used to select the thread it must have been initialized by firmware.  When both are used, ADDRESS_THREAD must be different from DATA_THREAD.</description>
                  <bitRange>[17:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DATA_THREAD</name>
                  <description>Thread number to be used for data; only relevant when AIN_DATA=1
When this register is used to select the thread it must have been initialized by firmware.   When both are used, ADDRESS_THREAD must be different from DATA_THREAD.</description>
                  <bitRange>[19:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DQ_INP_EN_CFG</name>
                  <description>N/A</description>
                  <bitRange>[21:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>A_INP_EN_CFG</name>
                  <description>N/A</description>
                  <bitRange>[23:22]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_CTL_FUNC0</name>
              <description>CTL pin functional usage register #0</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x3020100</resetValue>
              <resetMask>0x1F1F1F1F</resetMask>
              <fields>
                <field>
                  <name>CE_CTL_SEL</name>
                  <description>This field can also be called as CTL_2_LAMBDA0.
Decides which of the avaialble 10x(narrow port)/20x(wide port) CTL pins should be used as CE. 
0 - CTL[0]
1 - CTL[1]
N - CTL[N]</description>
                  <bitRange>[4:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WE_CTL_SEL</name>
                  <description>This field can also be called as CTL_2_LAMBDA1.
Decides which of the avaialble 10x(narrow port)/20x(wide port) CTL pins should be used as WE. 
0 - CTL[0]
1 - CTL[1]
N - CTL[N]</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OE_CTL_SEL</name>
                  <description>This field can also be called as CTL_2_LAMBDA2.
Decides which of the avaialble 10x(narrow port)/20x(wide port) CTL pins should be used as OE. 
0 - CTL[0]
1 - CTL[1]
N - CTL[N]</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>L3_ENTRY_SEL</name>
                  <description>This field can also be called as CTL_2_LAMBDA3.
Decides which of the avaialble 10x(narrow port)/20x(wide port) CTL pins should be used as L3_ENTRY pin. 
0 - CTL[0]
1 - CTL[1]
N - CTL[N]</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_CTL_FUNC1</name>
              <description>CTL pin functional usage register #1</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x7060504</resetValue>
              <resetMask>0x1F1F1F1F</resetMask>
              <fields>
                <field>
                  <name>PKTEND_SEL</name>
                  <description>This field can also be called as CTL_2_LAMBDA4.
Decides which of the avaialble 10x(narrow port)/20x(wide port) CTL pins should be used as PKTEND signal. 
0 - CTL[0]
1 - CTL[1]
N - CTL[N]</description>
                  <bitRange>[4:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EM_VLD_CTL_SEL</name>
                  <description>This field can also be called as CTL_2_LAMBDA5.
Decides which of the avaialble 10x(narrow port)/20x(wide port) CTL pins should be used as EM_VLD. 
0 - CTL[0]
1 - CTL[1]
N - CTL[N]</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TH0_PTS_TRIG_CTL_SEL</name>
                  <description>This field can also be called as CTL_2_LAMBDA6.
Decides which of the avaialble 10x(narrow port)/20x(wide port) CTL pins should be used as thread0 PTS trigger. 
0 - CTL[0]
1 - CTL[1]
N - CTL[N]</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TH1_PTS_TRIG_CTL_SEL</name>
                  <description>This field can also be called as CTL_2_LAMBDA7.
Decides which of the avaialble 10x(narrow port)/20x(wide port) CTL pins should be used as thread1 PTS trigger. 
0 - CTL[0]
1 - CTL[1]
N - CTL[N]</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_CTL_FUNC2</name>
              <description>CTL pin functional usage register #2</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xB0A0908</resetValue>
              <resetMask>0x1F1F1F1F</resetMask>
              <fields>
                <field>
                  <name>TH2_PTS_TRIG_CTL_SEL</name>
                  <description>This field can also be called as CTL_2_LAMBDA8.
Decides which of the avaialble 10x(narrow port)/20x(wide port) CTL pins should be used as thread2 PTS trigger. 
0 - CTL[0]
1 - CTL[1]
N - CTL[N]</description>
                  <bitRange>[4:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TH3_PTS_TRIG_CTL_SEL</name>
                  <description>This field can also be called as CTL_2_LAMBDA9.
Decides which of the avaialble 10x(narrow port)/20x(wide port) CTL pins should be used as thread3 PTS trigger. 
0 - CTL[0]
1 - CTL[1]
N - CTL[N]</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CTL_2_LAMBDA10_SEL</name>
                  <description>Decides which of the avaialble 10x(narrow port)/20x(wide port) CTL pins should be used as Lambda[10] signal. 
0 - CTL[0]
1 - CTL[1]
N - CTL[N]</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CTL_2_LAMBDA11_SEL</name>
                  <description>Decides which of the avaialble 10x(narrow port)/20x(wide port) CTL pins should be used as Lambda[11] signal. 
0 - CTL[0]
1 - CTL[1]
N - CTL[N]</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_CTL_FUNC3</name>
              <description>CTL pin functional usage register #3</description>
              <addressOffset>0x1C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xF0E0D0C</resetValue>
              <resetMask>0x1F1F1F1F</resetMask>
              <fields>
                <field>
                  <name>CTL_2_LAMBDA12_SEL</name>
                  <description>Decides which of the avaialble 10x(narrow port)/20x(wide port) CTL pins should be used as Lambda[12] signal. 
0 - CTL[0]
1 - CTL[1]
N - CTL[N]</description>
                  <bitRange>[4:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CTL_2_LAMBDA13_SEL</name>
                  <description>Decides which of the avaialble 10x(narrow port)/20x(wide port) CTL pins should be used as Lambda[13] signal. 
0 - CTL[0]
1 - CTL[1]
N - CTL[N]</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CTL_2_LAMBDA14_SEL</name>
                  <description>Decides which of the avaialble 10x(narrow port)/20x(wide port) CTL pins should be used as Lambda[14] signal. 
0 - CTL[0]
1 - CTL[1]
N - CTL[N]</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CTL_2_LAMBDA15_SEL</name>
                  <description>Decides which of the avaialble 10x(narrow port)/20x(wide port) CTL pins should be used as Lambda[15] signal. 
0 - CTL[0]
1 - CTL[1]
N - CTL[N]</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_CTL_FUNC4</name>
              <description>CTL pin functional usage register #4</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x13121110</resetValue>
              <resetMask>0x1F1F1F1F</resetMask>
              <fields>
                <field>
                  <name>CTL_2_LAMBDA16_SEL</name>
                  <description>Decides which of the avaialble 10x(narrow port)/20x(wide port) CTL pins should be used as Lambda[16] signal. 
0 - CTL[0]
1 - CTL[1]
N - CTL[N]</description>
                  <bitRange>[4:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CTL_2_LAMBDA17_SEL</name>
                  <description>Decides which of the avaialble 10x(narrow port)/20x(wide port) CTL pins should be used as Lambda[17] signal. 
0 - CTL[0]
1 - CTL[1]
N - CTL[N]</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CTL_2_LAMBDA18_SEL</name>
                  <description>Decides which of the avaialble 10x(narrow port)/20x(wide port) CTL pins should be used as Lambda[18] signal. 
0 - CTL[0]
1 - CTL[1]
N - CTL[N]</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CTL_2_LAMBDA19_SEL</name>
                  <description>Decides which of the avaialble 10x(narrow port)/20x(wide port) CTL pins should be used as Lambda[19] signal. 
0 - CTL[0]
1 - CTL[1]
N - CTL[N]</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_STATUS</name>
              <description>GPIF Status Register</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0xF0000</resetValue>
              <resetMask>0xFFFF07FF</resetMask>
              <fields>
                <field>
                  <name>GPIF_DONE</name>
                  <description>1: GPIF has reached the DONE state.  Non sticky.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GPIF_FSM_INTR</name>
                  <description>Indicates that GPIF state machine has raised an interrupt.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SWITCH_TIMEOUT</name>
                  <description>Indicates that the SWITCH_TIMEOUT was reached (see WAVEFORM_SWITCH).
This bit clears when a new WAVEFORM_SWTICH is initiated.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CRC_ERROR</name>
                  <description>Indicates that an incorrect CRC was received</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ADDR_COUNT_HIT</name>
                  <description>Address counter is at limit</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DATA_COUNT_HIT</name>
                  <description>Data counter is at limit</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CTRL_COUNT_HIT</name>
                  <description>Control counter is at limit</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ADDR_COMP_HIT</name>
                  <description>Address comparator hits</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DATA_COMP_HIT</name>
                  <description>Data comparator hits</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CTRL_COMP_HIT</name>
                  <description>Control comparator hits</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WAVEFORM_BUSY</name>
                  <description>CPU tried to access waveform memory w/o clearing WAVEFORM_VALID</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EG_DATA_EMPTY</name>
                  <description>Indicates corresponding EGRESS_DATA register is empty</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>IN_DATA_VALID</name>
                  <description>Indicates corresponding INGRESS_DATA register is full.</description>
                  <bitRange>[23:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>INTERRUPT_STATE</name>
                  <description>State that raised the interrupt through GPIF_INTR. Pl. note that these bits do not have individual interrupt and mask bits in GPIF_INTR and GPIF_MASK</description>
                  <bitRange>[31:24]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_INTR</name>
              <description>GPIF Interrupt Request Register</description>
              <addressOffset>0x30</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1FFF07FF</resetMask>
              <fields>
                <field>
                  <name>GPIF_DONE</name>
                  <description>Interrupt request corresponding to same bit in GPIF_STATUS</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GPIF_FSM_INTR</name>
                  <description>Interrupt request corresponding to same bit in GPIF_STATUS</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWITCH_TIMEOUT</name>
                  <description>Interrupt request corresponding to same bit in GPIF_STATUS</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CRC_ERROR</name>
                  <description>Interrupt request corresponding to same bit in GPIF_STATUS</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADDR_COUNT_HIT</name>
                  <description>Interrupt request corresponding to same bit in GPIF_STATUS</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DATA_COUNT_HIT</name>
                  <description>Interrupt request corresponding to same bit in GPIF_STATUS</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CTRL_COUNT_HIT</name>
                  <description>Interrupt request corresponding to same bit in GPIF_STATUS</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADDR_COMP_HIT</name>
                  <description>Interrupt request corresponding to same bit in GPIF_STATUS</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DATA_COMP_HIT</name>
                  <description>Interrupt request corresponding to same bit in GPIF_STATUS</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CTRL_COMP_HIT</name>
                  <description>Interrupt request corresponding to same bit in GPIF_STATUS</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WAVEFORM_BUSY</name>
                  <description>Interrupt request corresponding to same bit in GPIF_STATUS</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EG_DATA_EMPTY_BIT0</name>
                  <description>Interrupt request corresponding to same bit in GPIF_STATUS</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EG_DATA_EMPTY_BIT1</name>
                  <description>Interrupt request corresponding to same bit in GPIF_STATUS</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EG_DATA_EMPTY_BIT2</name>
                  <description>Interrupt request corresponding to same bit in GPIF_STATUS</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EG_DATA_EMPTY_BIT3</name>
                  <description>Interrupt request corresponding to same bit in GPIF_STATUS</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IN_DATA_VALID_BIT0</name>
                  <description>Interrupt request corresponding to same bit in GPIF_STATUS</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IN_DATA_VALID_BIT1</name>
                  <description>Interrupt request corresponding to same bit in GPIF_STATUS</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IN_DATA_VALID_BIT2</name>
                  <description>Interrupt request corresponding to same bit in GPIF_STATUS</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IN_DATA_VALID_BIT3</name>
                  <description>Interrupt request corresponding to same bit in GPIF_STATUS</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GPIF_ERR</name>
                  <description>An error occurred in the GPIF.  FW clears this bit after handling the error.  The error code is indicated in GPIF_ERR_CODE</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>INVLD_CMD_DET</name>
                  <description>Unspecified command identified on LVDS Control Byte</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LINK_IDLE</name>
                  <description>Continuous IDLE commands are received for programmable duration</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SPARE4</name>
                  <description>Interface clock is off for programmable duration</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SPARE5</name>
                  <description>Continuous IDLE commands are received for programmable duration</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_INTR_MASK</name>
              <description>GPIF Interrupt Mask Register</description>
              <addressOffset>0x34</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1FFF07FF</resetMask>
              <fields>
                <field>
                  <name>GPIF_DONE</name>
                  <description>Mask bit that controls reporting of corresponding bit in GPIF_INTR
0 - Interrupt is masked
1 - interrupt is enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GPIF_FSM_INTR</name>
                  <description>Mask bit that controls reporting of corresponding bit in GPIF_INTR</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWITCH_TIMEOUT</name>
                  <description>Mask bit that controls reporting of corresponding bit in GPIF_INTR</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CRC_ERROR</name>
                  <description>Mask bit that controls reporting of corresponding bit in GPIF_INTR</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADDR_COUNT_HIT</name>
                  <description>Mask bit that controls reporting of corresponding bit in GPIF_INTR</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DATA_COUNT_HIT</name>
                  <description>Mask bit that controls reporting of corresponding bit in GPIF_INTR</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CTRL_COUNT_HIT</name>
                  <description>Mask bit that controls reporting of corresponding bit in GPIF_INTR</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADDR_COMP_HIT</name>
                  <description>Mask bit that controls reporting of corresponding bit in GPIF_INTR</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DATA_COMP_HIT</name>
                  <description>Mask bit that controls reporting of corresponding bit in GPIF_INTR</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CTRL_COMP_HIT</name>
                  <description>Mask bit that controls reporting of corresponding bit in GPIF_INTR</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WAVEFORM_BUSY</name>
                  <description>Mask bit that controls reporting of corresponding bit in GPIF_INTR</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EG_DATA_EMPTY</name>
                  <description>Mask bit that controls reporting of corresponding bit in GPIF_INTR</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IN_DATA_VALID</name>
                  <description>Mask bit that controls reporting of corresponding bit in GPIF_INTR</description>
                  <bitRange>[23:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GPIF_ERR</name>
                  <description>Mask bit that controls reporting of corresponding bit in GPIF_INTR</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>INVLD_CMD_DET</name>
                  <description>Mask bit that controls reporting of corresponding bit in GPIF_INTR</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LINK_IDLE</name>
                  <description>Mask bit that controls reporting of corresponding bit in GPIF_INTR</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SPARE4</name>
                  <description>Mask bit that controls reporting of corresponding bit in GPIF_INTR</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SPARE5</name>
                  <description>Mask bit that controls reporting of corresponding bit in GPIF_INTR</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_INTR_MASKED</name>
              <description>GPIF Interrupt Generator</description>
              <addressOffset>0x38</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1FFF07FF</resetMask>
              <fields>
                <field>
                  <name>GPIF_DONE</name>
                  <description>interrupt raised by respective bit in GPIF_INTR register</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GPIF_FSM_INTR</name>
                  <description>interrupt raised by respective bit in GPIF_INTR register</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SWITCH_TIMEOUT</name>
                  <description>interrupt raised by respective bit in GPIF_INTR register</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CRC_ERROR</name>
                  <description>interrupt raised by respective bit in GPIF_INTR register</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ADDR_COUNT_HIT</name>
                  <description>interrupt raised by respective bit in GPIF_INTR register</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DATA_COUNT_HIT</name>
                  <description>interrupt raised by respective bit in GPIF_INTR register</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CTRL_COUNT_HIT</name>
                  <description>interrupt raised by respective bit in GPIF_INTR register</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ADDR_COMP_HIT</name>
                  <description>interrupt raised by respective bit in GPIF_INTR register</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DATA_COMP_HIT</name>
                  <description>interrupt raised by respective bit in GPIF_INTR register</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CTRL_COMP_HIT</name>
                  <description>interrupt raised by respective bit in GPIF_INTR register</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WAVEFORM_BUSY</name>
                  <description>interrupt raised by respective bit in GPIF_INTR register</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EG_DATA_EMPTY</name>
                  <description>interrupt raised by respective bit in GPIF_INTR register</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>IN_DATA_VALID</name>
                  <description>interrupt raised by respective bit in GPIF_INTR register</description>
                  <bitRange>[23:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GPIF_ERR</name>
                  <description>interrupt raised by respective bit in GPIF_INTR register</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>INVLD_CMD_DET</name>
                  <description>interrupt raised by respective bit in GPIF_INTR register</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LINK_IDLE</name>
                  <description>interrupt raised by respective bit in GPIF_INTR register</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SPARE4</name>
                  <description>interrupt raised by respective bit in GPIF_INTR register</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SPARE5</name>
                  <description>interrupt raised by respective bit in GPIF_INTR register</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_INTR_SET</name>
              <description>GPIF Interrupt Set Register</description>
              <addressOffset>0x3C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1FFF07FF</resetMask>
              <fields>
                <field>
                  <name>GPIF_DONE</name>
                  <description>bit to set respecitve field in GPIF_INTR register</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GPIF_FSM_INTR</name>
                  <description>bit to set respecitve field in GPIF_INTR register</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWITCH_TIMEOUT</name>
                  <description>bit to set respecitve field in GPIF_INTR register</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CRC_ERROR</name>
                  <description>bit to set respecitve field in GPIF_INTR register</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADDR_COUNT_HIT</name>
                  <description>bit to set respecitve field in GPIF_INTR register</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DATA_COUNT_HIT</name>
                  <description>bit to set respecitve field in GPIF_INTR register</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CTRL_COUNT_HIT</name>
                  <description>bit to set respecitve field in GPIF_INTR register</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADDR_COMP_HIT</name>
                  <description>bit to set respecitve field in GPIF_INTR register</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DATA_COMP_HIT</name>
                  <description>bit to set respecitve field in GPIF_INTR register</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CTRL_COMP_HIT</name>
                  <description>bit to set respecitve field in GPIF_INTR register</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WAVEFORM_BUSY</name>
                  <description>bit to set respecitve field in GPIF_INTR register</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EG_DATA_EMPTY</name>
                  <description>bit to set respecitve field in GPIF_INTR register</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IN_DATA_VALID</name>
                  <description>bit to set respecitve field in GPIF_INTR register</description>
                  <bitRange>[23:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GPIF_ERR</name>
                  <description>bit to set respecitve field in GPIF_INTR register</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>INVLD_CMD_DET</name>
                  <description>bit to set respecitve field in GPIF_INTR register</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LINK_IDLE</name>
                  <description>bit to set respecitve field in GPIF_INTR register</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SPARE4</name>
                  <description>bit to set respecitve field in GPIF_INTR register</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SPARE5</name>
                  <description>bit to set respecitve field in GPIF_INTR register</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_ERROR</name>
              <description>GPIF Error Register</description>
              <addressOffset>0x40</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1F</resetMask>
              <fields>
                <field>
                  <name>GPIF_ERR_CODE</name>
                  <description>Error code for the first error code since ERROR=1
Error codes are specified in detail the USB30PIB BROS.</description>
                  <bitRange>[4:0]</bitRange>
                  <access>read-only</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>IN_ADDR_OVER_WRITE</name>
                      <description>Attempt to push to the active address thread which is not dma_ready</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>EG_ADDR_NOT_VALID</name>
                      <description>Attempt to push to the active address thread which is not dma_ready</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DMA_DATA_RD_ERROR</name>
                      <description>Attempt to push to the active address thread which is not dma_ready</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DMA_DATA_WR_ERROR</name>
                      <description>Attempt to push to the active address thread which is not dma_ready</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DMA_ADDR_RD_ERROR</name>
                      <description>Attempt to push to the active address thread which is not dma_ready</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DMA_ADDR_WR_ERROR</name>
                      <description>Attempt to push to the active address thread which is not dma_ready</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INVALID_STATE_ERROR</name>
                      <description>statemachine has transitioned to an invalid state</description>
                      <value>8</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <dim>20</dim>
              <dimIncrement>4</dimIncrement>
              <name>GPIF_CTRL_BUS_DIRECTION[%s]</name>
              <description>Control Bus in/out direction</description>
              <addressOffset>0x50</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xF</resetMask>
              <fields>
                <field>
                  <name>INP_EN</name>
                  <description>Decides if CTRL signal is input or not
0 - Disable input circuit of CTRL pad
1 - Enable input circuit of CTRL pad</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OEN</name>
                  <description>Decides if CTRL signal is output or not
0 - Disable OEN of CTRL pad
1 - Enable OEN of CTRL pad</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BIDI_EN</name>
                  <description>Decides if CTRL signal is a bi-di or not
1 - Use CTRL pad as bi-di. Controlled via beta_c_oen signal</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OPEN_DRAIN_EN</name>
                  <description>Decides if CTRL pad is an open-drain IO or not
1 - Use CTRL pad as open-drain IO. Controlled via beta_c_oen signal</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_CTRL_BUS_DEFAULT</name>
              <description>Control bus default values</description>
              <addressOffset>0xB0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFF</resetMask>
              <fields>
                <field>
                  <name>DEFAULT</name>
                  <description>One bit for each CTRL signal indicating default value
0:  Asserted (see POLARITY)
1:  De-asserted (see POLARITY)</description>
                  <bitRange>[19:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_CTRL_BUS_POLARITY</name>
              <description>Control bus signal polarity</description>
              <addressOffset>0xB4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFF</resetMask>
              <fields>
                <field>
                  <name>POLARITY</name>
                  <description>One bit for each CTRL signal indicating polarity
0: Asserted when 1
1: Asserted when 0</description>
                  <bitRange>[19:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_CTRL_BUS_TOGGLE</name>
              <description>Control bus output toggle mode</description>
              <addressOffset>0xB8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFF</resetMask>
              <fields>
                <field>
                  <name>TOGGLE</name>
                  <description>One bit for each CTRL signal indicating toggle mode
0: Normal mode, set value from alpha/beta
1: Toggle mode, toggle value when alpha/beta is 1, do nothing when 0</description>
                  <bitRange>[19:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>20</dim>
              <dimIncrement>4</dimIncrement>
              <name>GPIF_CTRL_BUS_SELECT[%s]</name>
              <description>Control bus connection matrix register</description>
              <addressOffset>0x100</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1F</resetMask>
              <fields>
                <field>
                  <name>OMEGA_INDEX</name>
                  <description>For each omega, 5-bits specify what is driven at to the output:
0-3: Connect to alpha 4-7
8-11: Connect to beta 0-3
16-19: Empty/Full flags for thread 0-3
20-23: Partial Flag for thread 0-3
24: Empty/Full flag for current thread
25: Partial Flag for current thread
26: 1usec pulse signal
27-31: Connected to logic 0 (cannot be used together with CTRL_BUS_TOGGLE)</description>
                  <bitRange>[4:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_CTRL_COUNT_CONFIG</name>
              <description>Control counter configuration</description>
              <addressOffset>0x160</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x6</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>ENABLE</name>
                  <description>0: This counter is not used.
1: This counter is used.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DOWN_UP_CNTR</name>
                  <description>0: Down Count
1: Up Count</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RELOAD_CNTR</name>
                  <description>0: Saturate on reaching the limit
1: Reload on reaching the limit</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SW_RESET_CNTR</name>
                  <description>1: SW writes one to reset/load the counter
0: HW write 0 to signal that counter has reset</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CONNECT</name>
                  <description>Connect the specified bit of this counter to CTRL[9]</description>
                  <bitRange>[7:4]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_CTRL_COUNT_RESET</name>
              <description>Control counter reset register</description>
              <addressOffset>0x164</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>RESET_LOAD_VAL</name>
                  <description>Reset counter to this value. Reload to this value when limit is reached if specified.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_CTRL_COUNT_LIMIT</name>
              <description>Control counter limit register</description>
              <addressOffset>0x168</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFF</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>LIMIT_VAL</name>
                  <description>Stop counting when counter reaches this value</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_ADDR_COUNT_CONFIG</name>
              <description>Address counter configuration</description>
              <addressOffset>0x170</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x10A</resetValue>
              <resetMask>0xFF0F</resetMask>
              <fields>
                <field>
                  <name>ENABLE</name>
                  <description>0: This counter is not used.
1: This counter is used.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RELOAD</name>
                  <description>0: Saturate on reaching the limit
1: Reload on reaching the limit</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SW_RESET</name>
                  <description>1: SW writes one to reset/load the counter
0: HW write 0 to signal that counter has reset</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DOWN_UP</name>
                  <description>0: Down Count
1: Up Count</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>INCREMENT</name>
                  <description>8-bit quantity to be added/subtracted to the counter on each clock</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_ADDR_COUNT_RESET</name>
              <description>Address counter reset register</description>
              <addressOffset>0x174</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RESET_LOAD</name>
                  <description>Reset counter to this value. Reload to this value when limit is reached if specified.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_ADDR_COUNT_LIMIT</name>
              <description>Address counter limit register</description>
              <addressOffset>0x178</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LIMIT</name>
                  <description>Stop counting when counter reaches this value</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_STATE_COUNT_CONFIG</name>
              <description>State counter configuration</description>
              <addressOffset>0x180</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>ENABLE</name>
                  <description>0: This counter is not used.
1: This counter is used.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SW_RESET_STATE_CNT</name>
                  <description>1: SW writes one to reset/load the counter
0: HW write 0 to signal that counter has reset</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_STATE_COUNT_LIMIT</name>
              <description>State counter limit register</description>
              <addressOffset>0x184</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFF</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>LIMIT_VAL</name>
                  <description>Generate an output tick, reset and start counting again if enabled when this limit is reached..</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_DATA_COUNT_CONFIG</name>
              <description>Data counter configuration</description>
              <addressOffset>0x190</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x10A</resetValue>
              <resetMask>0xFF0F</resetMask>
              <fields>
                <field>
                  <name>ENABLE</name>
                  <description>0: This counter is not used.
1: This counter is used.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RELOAD</name>
                  <description>0: Saturate on reaching the limit
1: Reload on reaching the limit</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SW_RESET</name>
                  <description>1: SW writes one to reset/load the counter
0: HW write 0 to signal that counter has reset</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DOWN_UP</name>
                  <description>0: Down Count
1: Up Count</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>INCREMENT</name>
                  <description>8-bit quantity to be added/subtracted to the counter on each clock</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_DATA_COUNT_RESET_LSB</name>
              <description>Data counter reset register</description>
              <addressOffset>0x194</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RESET_LOAD</name>
                  <description>Reset counter to this value. Relload to this value when limit it reached if specified. LSB bits of reset counter value.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_DATA_COUNT_RESET_MSB</name>
              <description>Data counter reset register</description>
              <addressOffset>0x19C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RESET_LOAD</name>
                  <description>Reset counter to this value. Relload to this value when limit it reached if specified. MSB bits of reset counter value.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_DATA_COUNT_LIMIT_LSB</name>
              <description>Data counter limit register</description>
              <addressOffset>0x1A0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LIMIT</name>
                  <description>Reload data counter if this limit is reached and reload is enabled. LSB bits of limit value.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_DATA_COUNT_LIMIT_MSB</name>
              <description>Data counter limit register</description>
              <addressOffset>0x1A4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LIMIT</name>
                  <description>Reload data counter if this limit is reached and reload is enabled. MSB bits of limit value.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_CTRL_COMP_VALUE</name>
              <description>Control comparator value</description>
              <addressOffset>0x1A8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFF</resetMask>
              <fields>
                <field>
                  <name>COMP_VALUE</name>
                  <description>Output true when CTRL bus matches this value</description>
                  <bitRange>[19:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_CTRL_COMP_MASK</name>
              <description>Control comparator mask</description>
              <addressOffset>0x1AC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFF</resetMask>
              <fields>
                <field>
                  <name>CTRL_COMP_MASK</name>
                  <description>1: Bit at this bit position in the CTRL bus is to be used in comparison
0: Bit at this bit position is a don't-care for comparison</description>
                  <bitRange>[19:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_DATA_COMP_VALUE_WORD0</name>
              <description>Data comparator value</description>
              <addressOffset>0x1B0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>VALUE</name>
                  <description>Output true when Data  bus matches this value. {WD3, WD2, WD1, WD0}</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_DATA_COMP_VALUE_WORD1</name>
              <description>Data comparator value</description>
              <addressOffset>0x1B4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>VALUE</name>
                  <description>Output true when Data  bus matches this value</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_DATA_COMP_VALUE_WORD2</name>
              <description>Data comparator value</description>
              <addressOffset>0x1B8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>VALUE</name>
                  <description>Output true when Data  bus matches this value</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_DATA_COMP_VALUE_WORD3</name>
              <description>Data comparator value</description>
              <addressOffset>0x1BC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>VALUE</name>
                  <description>Output true when Data  bus matches this value</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_DATA_COMP_MASK_WORD0</name>
              <description>Data comparator mask</description>
              <addressOffset>0x1D0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>MASK</name>
                  <description>1: Bit at this bit position in the Data bus is to be used in comparision
0: Bit at this bit position is a don't-care for comparision</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_DATA_COMP_MASK_WORD1</name>
              <description>Data comparator mask</description>
              <addressOffset>0x1D4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>MASK</name>
                  <description>1: Bit at this bit position in the Data bus is to be used in comparision
0: Bit at this bit position is a don't-care for comparision</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_DATA_COMP_MASK_WORD2</name>
              <description>Data comparator mask</description>
              <addressOffset>0x1D8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>MASK</name>
                  <description>1: Bit at this bit position in the Data bus is to be used in comparision
0: Bit at this bit position is a don't-care for comparision</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_DATA_COMP_MASK_WORD3</name>
              <description>Data comparator mask</description>
              <addressOffset>0x1DC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>MASK</name>
                  <description>1: Bit at this bit position in the Data bus is to be used in comparision
0: Bit at this bit position is a don't-care for comparision</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_ADDR_COMP_VALUE</name>
              <description>Address comparator value</description>
              <addressOffset>0x1E0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>VALUE</name>
                  <description>Output true when Data  bus matches this value</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_ADDR_COMP_MASK</name>
              <description>Address comparator mask</description>
              <addressOffset>0x1E4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>MASK</name>
                  <description>1: Bit at this bit position in the CTRL bus is to be used in comparison
0: Bit at this bit position is a don't-care for comparison</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_LAMBDA_STAT0</name>
              <description>Lambda Status Register</description>
              <addressOffset>0x1F0</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x10000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LAMBDA</name>
                  <description>Current value of the Lambda Inputs</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_LAMBDA_STAT1</name>
              <description>Lambda Status Register</description>
              <addressOffset>0x1F4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LAMBDA</name>
                  <description>Current value of the Lambda Inputs</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_ALPHA_STAT</name>
              <description>Alpha Status Register</description>
              <addressOffset>0x1F8</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>ALPHA</name>
                  <description>Current value of the Alpha signals</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_BETA_STAT</name>
              <description>Beta Status Register</description>
              <addressOffset>0x1FC</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BETA_VAL</name>
                  <description>Current value of the Beta signals</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_WAVEFORM_CTRL_STAT</name>
              <description>Waveform program control</description>
              <addressOffset>0x200</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF0F03</resetMask>
              <fields>
                <field>
                  <name>WAVEFORM_VALID</name>
                  <description>1:  The waveform memory is consistent and valid. 
0: Waveforms are no longer valid, stop operation and return outputs to default state</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PAUSE</name>
                  <description>Write 1 here to pause GPIF. 0 to resume where left off.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GPIF_STAT</name>
                  <description>GPIF is running on core clock which is 240MHz and the status is being read on peri clock which is 100MHz. This field will reflect correct value only when GPIF is one state for long time (ie ~10x peri clock cycles)
0: Waveform is not valid (Initial state or WAVEFORM_VALID is cleared)
1: &lt;unused&gt;
2: GPIF is armed (WAVEFORM_VALID is set)
3: GPIF is running (using WAVEFORM_SWITCH)
4: GPIF is done (encountered DONE_STATE)
5: GPIF is paused (PAUSE=0)
6: GPIF is switching (waiting for timeout/terminal state)
7: An error occurred</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CPU_LAMBDA</name>
                  <description>Visible to the state machine as lambda 30</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ALPHA_INIT</name>
                  <description>Initial values for alpha outputs.  These are loaded into the alpha registers when GPIF execution starts (first WAVEFORM_SWITCH) is set.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CURRENT_STATE</name>
                  <description>Current state of GPIF. Always updated.
GPIF is running on core clock which is 240MHz and the status is being read on peri clock which is 100MHz. This field will reflect correct value only when GPIF is one state for long time (ie ~10x peri clock cycles)</description>
                  <bitRange>[31:24]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_WAVEFORM_SWITCH</name>
              <description>Waveform switch control</description>
              <addressOffset>0x204</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>WAVEFORM_SWITCH</name>
                  <description>SW sets this bit after programming the switch register. HW clears it after the switch is complete.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DONE_ENABLE</name>
                  <description>1: Enable checking for DONE_STATE and generation of GPIF_DONE.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWITCH_NOW</name>
                  <description>1: Do not wait for TERMINAL_STATE, switch right away</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TIMEOUT_MODE</name>
                  <description>0: Timeout disable
1: Timeout for reaching TERMINAL_STATE.  Interrupt on timeout
2: Timeout for reaching DONE_STATE.  Interrupt on timeout
3: Timeout for reaching TERMINAL STATE.  Force switch on timeout.
4: Timeout for hanging in current state. Timer resets on each transition.</description>
                  <bitRange>[5:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TIMEOUT_REACHED</name>
                  <description>Indicates that timeout was reached since last WAVEFORM_SWITCH
GPIF is running on core clock which is 240MHz and the status is being read on peri clock which is 100MHz. This field will reflect correct value only when GPIF is one state for long time (ie ~10x peri clock cycles)</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TERMINATED</name>
                  <description>Indicates that the TERMINAL_STATE was reached since last WAVEFORM_SWITCH.
GPIF is running on core clock which is 240MHz and the status is being read on peri clock which is 100MHz. This field will reflect correct value only when GPIF is one state for long time (ie ~10x peri clock cycles)</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TERMINAL_STATE</name>
                  <description>State from which to initiate the switch. Corresponds to idle states of waveforms.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DESTINATION_STATE</name>
                  <description>State to jump to, may be the initial state of the new wavform.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DONE_STATE</name>
                  <description>Signal GPIF_DONE upon reaching this state.</description>
                  <bitRange>[31:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_WAVEFORM_SWITCH_TIMEOUT</name>
              <description>Waveform timeout register</description>
              <addressOffset>0x208</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RESET_LOAD</name>
                  <description>Timeout value</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_CRC_CALC_CONFIG</name>
              <description>CRC Calculate Configuration Register</description>
              <addressOffset>0x210</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>INIT_CRC_CTL_4MFSM</name>
                  <description>Use 'initialise_crc' beta, driven by GPIF FSM, to initialise CRC calculator
0 - CRC calculator is initialised by HW bypassing GPIF FSM
1 - CRC calculator is initialised using 'beta_use_crc' driven by GPIF FSM</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>USE_CRC_CTL_4MFSM</name>
                  <description>Use 'use_crc' beta, driven by GPIF FSM, for appending calculated crc to data packet
0 - CRC is inserted by HW bypassing GPIF FSM
1 - CRC is inserted using 'beta_use_crc' driven by GPIF FSM</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>USE_CALC_CRC_4MFSM</name>
                  <description>Use 'calculate_crc' beta, driven by GPIF FSM, for calculating CRC on data packet (CRC calculation on header/metadata is  not controlled by GPIF FSM. Its taken care by HW only).
0 - CRC is calculated on Data, by HW bypassing GPIF FSM
1 - CRC  is calculated on Data, using 'beta_calculate_crc' driven by GPIF FSM</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GPIF_BETA_DEASSERT</name>
              <description>Beta Deassert Register</description>
              <addressOffset>0x218</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>APPLY_DEASSERT</name>
                  <description>1: BETA_DEASSERT from the waveform descriptor applies to this beta. This is not honored for external betas which always behave as if apply_deassert=0
0: BETA_DEASSERT does not apply. Betas remain asserted throughout the state.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>32</dim>
              <dimIncrement>4</dimIncrement>
              <name>GPIF_FUNCTION[%s]</name>
              <description>Transition Function Registers</description>
              <addressOffset>0x220</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>FUNCTION</name>
                  <description>Truth table for transition function. Bit position X contains output when the 4 inputs constitute the value X in binary. For example bit 2 = 1 means in3=0, in2=0, in1=1 and in0=0 will evaluate true for this function.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LINK_IDLE_CFG</name>
              <description>Link Idle Config register</description>
              <addressOffset>0x2B0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFF</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>IDLE_CMD_CNT</name>
                  <description>Link is considered idle, when it receives N number of continous IDLE commands on interface and interrupt is raised. N is value programmed in the register field</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LVCMOS_CLK_OUT_CFG</name>
              <description>lvcmos clock out config register</description>
              <addressOffset>0x2C0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x30</resetValue>
              <resetMask>0x3F3</resetMask>
              <fields>
                <field>
                  <name>CLK_SRC</name>
                  <description>LVCMOS interface clock driven by FX3G2 has different sources. This register field selects the clock source. This is valid only when GPIF_CONFIG.CLK_SOURCE is set to 1.

0 - usb 480 MHz clock source
1 - HF clk (Max 150MHz)
2 - pll clock output of AFE0</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CLK_SRC_DIV_VAL</name>
                  <description>This register field is valid only when clock source is USB 480MHz clock or HF clock. Based on clock source selection, program this field, such that divided clock is less than 100MHz, but greater than MMIO clock freq divided by 5(ie 100/5=20MHz).  Duty cycle is not guaranteed to be 50 percent.

0 - Invalid 
1 - Div by 1
N - Div by N

For DDR Master mode, this field has to be programmed with even value.</description>
                  <bitRange>[9:4]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <cluster>
              <name>LEFT</name>
              <description>GPIF State Machine Left Waveform memory</description>
              <addressOffset>0x00001000</addressOffset>
              <cluster>
                <dim>256</dim>
                <dimIncrement>16</dimIncrement>
                <name>WAVEFORM[%s]</name>
                <description>GPIF  Waveform registers</description>
                <addressOffset>0x00000000</addressOffset>
                <register>
                  <name>WAVEFORM0</name>
                  <description>GPIF state definition</description>
                  <addressOffset>0x0</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFFFFFFFF</resetMask>
                  <fields>
                    <field>
                      <name>NEXT_STATE</name>
                      <description>Next state on left transition</description>
                      <bitRange>[7:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>FA</name>
                      <description>Index to select the first input for transition fuctions out of 32 choices.
It is a 6-bit value, which is split in to 2 register fields, to maintain backward compatability with FX3 wavememory fields. 5-bit value is specified here. 6th bit is specified in WAVEFORM3 register</description>
                      <bitRange>[12:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>FB</name>
                      <description>Second input index.</description>
                      <bitRange>[17:13]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>FC</name>
                      <description>Third input index.</description>
                      <bitRange>[22:18]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>FD</name>
                      <description>Fourth input index</description>
                      <bitRange>[27:23]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>F0_L</name>
                      <description>Lower four bits of index to select the first transition function from a choice of 32 functions. Truth-tables for the 32 4-bit functions are defined using the GPIF_FUNCTION registers.</description>
                      <bitRange>[31:28]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>WAVEFORM1</name>
                  <description>GPIF state definition</description>
                  <addressOffset>0x4</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFFFFFFFF</resetMask>
                  <fields>
                    <field>
                      <name>F0_U</name>
                      <description>MSB of index to select the first transition function from a choice of 32 functions. Truth-tables for the 32 4-bit functions are defined using the GPIF_FUNCTION registers.</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>F1</name>
                      <description>Index to select the second transition function from a choice of 32 functions. Truth-tables for the 32 4-bit functions are defined using the GPIF_FUNCTION registers.</description>
                      <bitRange>[5:1]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ALPHA_LEFT</name>
                      <description>Primary outputs for the left edge of the next state.</description>
                      <bitRange>[13:6]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ALPHA_RIGHT</name>
                      <description>Primary outputs for the right edge of the next state</description>
                      <bitRange>[21:14]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>BETA_L</name>
                      <description>Values for the secondary outputs [9:0] associated with this state.</description>
                      <bitRange>[31:22]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>WAVEFORM2</name>
                  <description>GPIF state definition</description>
                  <addressOffset>0x8</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFFFFFFFF</resetMask>
                  <fields>
                    <field>
                      <name>BETA_U</name>
                      <description>Values for the secondary outputs [31:10] associated with this state.</description>
                      <bitRange>[21:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REPEAT_COUNT</name>
                      <description>Number of times to stay in this state -1</description>
                      <bitRange>[29:22]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>BETA_DEASSERT</name>
                      <description>0: Keep betas asserted throughout the state
1: De-assert after asserting for exactly one clock cycle, irrespective of how many cycles the state is active.
The normal (de-assert) state of user defined betas is defined in GPIF_CTRL_BUS_DEFAULT. The normal state of internal betas is fixed by hardware. This function is applied only to betas selected in GPIF_BETA_DEASSERT.</description>
                      <bitRange>[30:30]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VALID</name>
                      <description>1: This entry is valid.
0: Entry not valid. (Not programmed or edge does not exist)</description>
                      <bitRange>[31:31]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>WAVEFORM3</name>
                  <description>GPIF state definition</description>
                  <addressOffset>0xC</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFFFFFFFF</resetMask>
                  <fields>
                    <field>
                      <name>FA_5</name>
                      <description>Msb of Lamba select</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>FB_5</name>
                      <description>Msb of Lamba select</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>FC_5</name>
                      <description>Msb of Lamba select</description>
                      <bitRange>[2:2]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>FD_5</name>
                      <description>Msb of Lamba select</description>
                      <bitRange>[3:3]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>RSVD</name>
                      <description>N/A</description>
                      <bitRange>[31:4]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
              </cluster>
            </cluster>
            <cluster>
              <name>RIGHT</name>
              <description>GPIF State Machine Right Waveform memory.</description>
              <addressOffset>0x00002000</addressOffset>
              <cluster>
                <dim>256</dim>
                <dimIncrement>16</dimIncrement>
                <name>WAVEFORM[%s]</name>
                <description>GPIF  Waveform registers</description>
                <addressOffset>0x00000000</addressOffset>
                <register>
                  <name>WAVEFORM0</name>
                  <description>GPIF state definition</description>
                  <addressOffset>0x0</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFFFFFFFF</resetMask>
                  <fields>
                    <field>
                      <name>NEXT_STATE</name>
                      <description>Next state on left transition</description>
                      <bitRange>[7:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>FA</name>
                      <description>Index to select the first input for transition fuctions out of 32 choices.
It is a 6-bit value, which is split in to 2 register fields, to maintain backward compatability with FX3 wavememory fields. 5-bit value is specified here. 6th bit is specified in WAVEFORM3 register</description>
                      <bitRange>[12:8]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>FB</name>
                      <description>Second input index.</description>
                      <bitRange>[17:13]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>FC</name>
                      <description>Third input index.</description>
                      <bitRange>[22:18]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>FD</name>
                      <description>Fourth input index</description>
                      <bitRange>[27:23]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>F0_L</name>
                      <description>Lower four bits of index to select the first transition function from a choice of 32 functions. Truth-tables for the 32 4-bit functions are defined using the GPIF_FUNCTION registers.</description>
                      <bitRange>[31:28]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>WAVEFORM1</name>
                  <description>GPIF state definition</description>
                  <addressOffset>0x4</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFFFFFFFF</resetMask>
                  <fields>
                    <field>
                      <name>F0_U</name>
                      <description>MSB of index to select the first transition function from a choice of 32 functions. Truth-tables for the 32 4-bit functions are defined using the GPIF_FUNCTION registers.</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>F1</name>
                      <description>Index to select the second transition function from a choice of 32 functions. Truth-tables for the 32 4-bit functions are defined using the GPIF_FUNCTION registers.</description>
                      <bitRange>[5:1]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ALPHA_LEFT</name>
                      <description>Primary outputs for the left edge of the next state.</description>
                      <bitRange>[13:6]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>ALPHA_RIGHT</name>
                      <description>Primary outputs for the right edge of the next state</description>
                      <bitRange>[21:14]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>BETA_L</name>
                      <description>Values for the secondary outputs [9:0] associated with this state.</description>
                      <bitRange>[31:22]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>WAVEFORM2</name>
                  <description>GPIF state definition</description>
                  <addressOffset>0x8</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFFFFFFFF</resetMask>
                  <fields>
                    <field>
                      <name>BETA_U</name>
                      <description>Values for the secondary outputs [31:10] associated with this state.</description>
                      <bitRange>[21:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>REPEAT_COUNT</name>
                      <description>Number of times to stay in this state -1</description>
                      <bitRange>[29:22]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>BETA_DEASSERT</name>
                      <description>0: Keep betas asserted throughout the state
1: De-assert after asserting for exactly one clock cycle, irrespective of how many cycles the state is active.
The normal (de-assert) state of user defined betas is defined in GPIF_CTRL_BUS_DEFAULT. The normal state of internal betas is fixed by hardware. This function is applied only to betas selected in GPIF_BETA_DEASSERT.</description>
                      <bitRange>[30:30]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>VALID</name>
                      <description>1: This entry is valid.
0: Entry not valid. (Not programmed or edge does not exist)</description>
                      <bitRange>[31:31]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
                <register>
                  <name>WAVEFORM3</name>
                  <description>GPIF state definition</description>
                  <addressOffset>0xC</addressOffset>
                  <size>32</size>
                  <access>read-write</access>
                  <resetValue>0x0</resetValue>
                  <resetMask>0xFFFFFFFF</resetMask>
                  <fields>
                    <field>
                      <name>FA_5</name>
                      <description>Msb of Lamba select</description>
                      <bitRange>[0:0]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>FB_5</name>
                      <description>Msb of Lamba select</description>
                      <bitRange>[1:1]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>FC_5</name>
                      <description>Msb of Lamba select</description>
                      <bitRange>[2:2]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>FD_5</name>
                      <description>Msb of Lamba select</description>
                      <bitRange>[3:3]</bitRange>
                      <access>read-write</access>
                    </field>
                    <field>
                      <name>RSVD</name>
                      <description>N/A</description>
                      <bitRange>[31:4]</bitRange>
                      <access>read-write</access>
                    </field>
                  </fields>
                </register>
              </cluster>
            </cluster>
          </cluster>
          <cluster>
            <dim>2</dim>
            <dimIncrement>2048</dimIncrement>
            <name>AFE[%s]</name>
            <description>Phy Configuration Registers</description>
            <addressOffset>0x00007000</addressOffset>
            <register>
              <name>DLL_DFTLPF</name>
              <description>DLL Low-Pass Filter Config Register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>EN</name>
                  <description>dll_dftlpf Enable
0 (default): DFTLPF disabled;
1: DFTLPF Enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FILT_SEL</name>
                  <description>Low-Pass Filter Charge Time Selection
0 (default): lower RC filter time constant (faster charge/discharge)</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DLL_CONFIG</name>
              <description>DLL Configuration Register</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1</resetMask>
              <fields>
                <field>
                  <name>DFT_RINGO_RST</name>
                  <description>DLL Reset used in DLL BIST
0 (default): Bit is not forcing DLL not to oscillate
1: Bit is forcing DLL to oscillate. This bit goes to 1 only during the DLL BIST. It goes to 1 when the number of stages inside the dll under exam varies.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DLL_STATUS</name>
              <description>DLL Status Register</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>FT</name>
                  <description>DLL Fine Tuning controlled by digital FSM</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DLL_M_CONFIG</name>
              <description>Master DLL Config Register</description>
              <addressOffset>0xC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1FFFF</resetMask>
              <fields>
                <field>
                  <name>EN</name>
                  <description>dll_m enable
0 (default): dll_m disabled
1: dll_m enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CLK_SEL</name>
                  <description>dll_m Input Clock Selection
0 (default):  pll_serial_clk (output pin of PLL);
1: clk_link_i (clock coming directly from link)</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>INV_CLK_MUX</name>
                  <description>dll_m Clock MUX Inversion
0 (default): input clock to dll_m is not inverted before entering delay stages
1: input clock to dll_m is inverted before entering delay stages</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DFT_EN</name>
                  <description>dll_m poriton of DLL BIST Enable
0 (default): dll_m poriton of DLL BIST disabled, i.e. dll_m is not closed in ring oscillator configuration
1: dll_m poriton of DLL BIST enabled, i.e. dll_m is closed in ring oscillator configuration</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DFT_TEST_CLK_EN</name>
                  <description>Enable for clk_serial output of dll_m; this clock is the one used by prbs_gen to generate a data stream in LVDS loopback mode
0 (default): clk_serial output tied to 0, therefore prbs_gen disabled (to be used in all working modes except LVDS loopback)
1: clk_serial output enabled, therefore prbs_gen enabled (to be used in LVDS loopback)</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DFT_BBPD_EN</name>
                  <description>Used to enable dft_bbpd_o. This output is a mean to debug dll_m locking procedure in validation in case there are problems. On output dft_bbpd_o, the output of the bang-bang phase detector used by dll_m locking FSM as well as the two inputs of bang-bang phase detector can be seen.
0 (default): DfT output disabled
1: DfT output enabled</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DFT_BBPD_SEL</name>
                  <description>Selection for dft_bbpd_o. Signal to be sent to DTB
00b (default): BBPD sampled data re sampled by the input clock of the master dll
01b: BBPD sampling clock re sampled with the input clock of the master dll
10b: BBPD output re sampled with the input clock of the master dll
11b: no signal</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SPEED_MODE</name>
                  <description>dll_m Speed Mode Selection
0 (default): High Speed (24 delay elements), to be used in LVDS SDR Fast and LVDS DDR Fast mode
1: Low Speed (48 delay elements), to be used in slow and bypass mode</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADFT_EN_LV</name>
                  <description>dll_m Connection to Analog Bus Enable
0 (default): Connection Disabled
1: Connection Enabled</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FLT_EN</name>
                  <description>Enable for lowpass filter on dll_m output voltages to dll_s
0 (default): Filter Disabled
1: Filter Enabled</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MDLL_SEL_PH</name>
                  <description>Phase delay of DLL_M, programmed by SW</description>
                  <bitRange>[14:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MDLL_OW_PH</name>
                  <description>Enables HW SEL_PH overwrite by SW MDLL_SEL_PH. Means that SW value will take precedence over any other values selected by HW outside of BIST checks:
0 (default): SEL_PH SW overwrite disabled
1: SEL_PH SW overwrite enabled</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HSPEED_MFREQ_SEL</name>
                  <description>dll_m High Speed Freq Selection, used for BIST checks
0 (default): High Speed, 625Mhz freq
1: High Speed, 298Mhz freq</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DLL_M_STATUS</name>
              <description>Master DLL Status Register</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFF</resetMask>
              <fields>
                <field>
                  <name>SEL_PH</name>
                  <description>dll_m Phase Selection controlled by digital FSM. This register field is controlled in two occasions: first, during the dll_m portion of DLL BIST to select the number of delay stages the ring oscilltator is composed by; second, for the generation of output clk_90 in slow mode.
Default: 0000b
Range of values to be used to obtain clk_90 in slow mode: 0000b-0002b</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CT</name>
                  <description>dll_m Coarse Tuning controlled by digital FSM, value will change only during dll_m locking procedure</description>
                  <bitRange>[7:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>BBPD</name>
                  <description>DLL BBPD Output, used by digital FSM to correctly lock dll_m to right frequency</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DFT_BBPD</name>
                  <description>DLL BBPD or sampled clock or sampled data to be sent to DTB; please see register field DLL_M_CONFIG.DFT_BBPD_SEL for more details on input selection.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CORRECT_PERIOD</name>
                  <description>False Lock Detection Output: dll_m Period Check for digital FSM. When the locking procedure has ended, this bit should stay at 1.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DLL_LOCK</name>
                  <description>Lock Status Indication - 1 = dll_m is locked; 0 - Not Locked</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>12</dim>
              <dimIncrement>4</dimIncrement>
              <name>DLL_S_CONFIG[%s]</name>
              <description>Slave DLL Configuration</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x30</resetValue>
              <resetMask>0x3FF</resetMask>
              <fields>
                <field>
                  <name>INV_CLK_MUXED</name>
                  <description>dll_s Clock MUX Inversion
0 (default): input clock to dll_s is not inverted before entering delay stages
1: input clock to dll_s is inverted before entering delay stages</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SDLL_DFT_EN</name>
                  <description>dll_s poriton of DLL BIST Enable
0 (default): dll_s poriton of DLL BIST disabled, i.e. dll_s is not closed in ring oscillator configuration
1: dll_s poriton of DLL BIST enabled, i.e. dll_s is closed in ring oscillator configuration</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SDLL_EN</name>
                  <description>dll_s Enable
0 (default): dll_s disabled
1: dll_s enabled</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DFT_LPF_EN</name>
                  <description>Enable of dll_s clk_dftlpf_o output to dll_dftlpf. All clk_dftlpf_o outputs of dll_s instances are connected in tristate to input clk_i of dll_dftlpf. Only one clk_dftlpf_o output at a time can be enabled.
0 (default): clk_dftlpf_o is disabled
1: clk_dftlpf_o is enabled</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SDLL_SEL_PH</name>
                  <description>Phase delay of DLL_S, programmed by SW</description>
                  <bitRange>[7:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SDLL_OW_PH</name>
                  <description>Enables HW SEL_PH overwrite by SW SDLL_SEL_PH. Means that SW value will take precedence over any other values selected by HW including values driven by BIST:
0 (default): SEL_PH SW overwrite disabled
1: SEL_PH SW overwrite enabled</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SDLL_SPEED_MODE</name>
                  <description>dll_s Speed Mode Selection
0 (default): Dummy Load disabled
1: Dummy Load features enabled</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>12</dim>
              <dimIncrement>4</dimIncrement>
              <name>DLL_S_STATUS[%s]</name>
              <description>Slave DLL Status</description>
              <addressOffset>0x50</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x3</resetValue>
              <resetMask>0x1F</resetMask>
              <fields>
                <field>
                  <name>SEL_PH</name>
                  <description>dll_s Phase Selection
These bits select the phase to be output and are controlled by the digital skew compensation FSM. Default is 0000b.</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CLK_DFT</name>
                  <description>dll_s clock used in dll_s portion of DLL BIST to check dll_s frequency</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GENERAL_LICIO_CIO</name>
              <description>LICIO_CIO Config reg (common for all pads)</description>
              <addressOffset>0x80</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FF</resetMask>
              <fields>
                <field>
                  <name>LVDS_RTERM_EN</name>
                  <description>Differential resistance enable for licio_cio in LVDS mode for each pair of differential pads. The assignment of the 10 bits register field is as follows
7:0   - LVDS Data Lanes [7:0]
8      - LVDS Ctrl Lane
9      - LVDS Frame Clock

0 (default): differential resistance disabled
1: differential resistance enabled</description>
                  <bitRange>[9:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LVCMOS_LB_EN</name>
                  <description>LVCMOS Core side loopback enable

0 (default): licio_cio are not operating in loopback mode.
1: licio_cio are operating in loopback mode. To be used only during LVCMOS loopback.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>27</dim>
              <dimIncrement>4</dimIncrement>
              <name>LICIO_CIO[%s]</name>
              <description>LICIO_CIO Config reg (per pad)</description>
              <addressOffset>0x84</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>LVCMOS_RX_EN</name>
                  <description>LVCMOS receiver enable</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LVCMOS_TX_EN</name>
                  <description>LVCMOS output enable. Important: a licio_cio cannot be enabled as RX and TX at the same time.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GENERAL_LICIO_LI</name>
              <description>LICIO_LI Config reg (common for all pads)</description>
              <addressOffset>0x100</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>LVDS_LB_EN</name>
                  <description>LVDS Core side loopback enable

0 (default): licio_li are not operating in loopback mode.
1: licio_li are operating in loopback mode. To be used only during LVDS loopback.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LVDS_CONFIG</name>
                  <description>LVDS receiver configuration setting
00: Both PMOS and NMOS on
01: PMOS on
10: NMOS on
11: Both PMOS and NMOS on</description>
                  <bitRange>[2:1]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>10</dim>
              <dimIncrement>4</dimIncrement>
              <name>LICIO_LI[%s]</name>
              <description>LICIO_LI Config reg (per pad)</description>
              <addressOffset>0x104</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x381</resetMask>
              <fields>
                <field>
                  <name>LVDS_RX_EN</name>
                  <description>LVDS receiver enable</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ATST</name>
                  <description>Analog test control bits</description>
                  <bitRange>[9:7]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LICIO_VSSIO_IREF</name>
              <description>LICIO_VSSIO_IREF Config reg</description>
              <addressOffset>0x130</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xF</resetMask>
              <fields>
                <field>
                  <name>EN</name>
                  <description>Iref Enable</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IN_SEL</name>
                  <description>Input iref select: 0=iref_in_10u, 1=iref_in_250n, 2=internal, 3=amuxbus_b</description>
                  <bitRange>[2:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ATST_EN</name>
                  <description>Analog test enable</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LICIO_LI_OUT_STATUS</name>
              <description>LICO_LI pad Rx output status</description>
              <addressOffset>0x134</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FF</resetMask>
              <fields>
                <field>
                  <name>LVDS_DATA</name>
                  <description>captures Rx output value of LVDS data pad circuit</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LVDS_CTRL</name>
                  <description>captures Rx output value of LVDS control pad circuit</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LVDS_CLK</name>
                  <description>captures Rx output value of LVDS clk pad circuit</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PLL_CONFIG</name>
              <description>PLL Configuration register</description>
              <addressOffset>0x138</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFBFFF</resetMask>
              <fields>
                <field>
                  <name>PLL_CP_CUR_TRIM</name>
                  <description>trim option of analog charge pump (scan mode - can be '0' or '1' - not High Z)</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_BYPASS</name>
                  <description>Enable of PLL bypass.

0 (default): PLL is not bypassed
1: PLL is bypassed. This bit is to be set high in all RX LVCMOS modes and in LVDS bypass mode.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_PFD_DELAY</name>
                  <description>changes the reset delay of the PFD. up/down pulses width of PFD will be changed by this bit</description>
                  <bitRange>[4:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_LD_DELAY</name>
                  <description>changes the lock delay of the lock detector, the lock pulse can be delay/early by this bit</description>
                  <bitRange>[6:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_EN</name>
                  <description>Enable of PLL.

0 (default): PLL disabled.
1: PLL enabled. PLL has to be enabled in all LVDS modes where PLL is not bypassed.</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_REG_VCO_BYPASS</name>
                  <description>periphery ldo bypass (scan mode - can be '0' or '1' - not High Z)

0 (default): Periphery LDO is not bypassed
1: Periphery LDO is not bypassed</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_REF_SEL</name>
                  <description>Mux selection bit for input reference:
0(default): clock from LVDS pad
1: clock from LVCMOS pad
2: clock_hf (clk_link)
3: clock_hf1 (clk_eco)</description>
                  <bitRange>[10:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_SUPPLY_EN</name>
                  <description>Enable of PLL Internal Power Supply (scan mode - must be '1')

0 (default): PLL Internal Power Supply is off
1: PLL Internal Power Supply is on. This bit needs to be set to 1 whenever the PLL is enabled.</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>N_IN_DIV</name>
                  <description>Input Clock Divider: N_IN_DIV[1:0]
N_IN_DIV[2:0]    Clock Frequency Divided
    00                1
    01                2
    10                4
    11                8</description>
                  <bitRange>[13:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>N_SERIAL_DIV</name>
                  <description>Output Serial Clock Divider: N_SERIAL_DIV[1:0]    
N_SERIAL_DIV[1:0]    Clock Frequency Divided
              00                    1
              01                    2
              10                    4
              11                    8</description>
                  <bitRange>[16:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>N_FRAME_DIV</name>
                  <description>Output Frame Clock Divider: N_FRAME_DIV[0]    
N_FRAME_DIV[0]    Clock Frequency Divided
                     0            4
                     1            8</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>N_FB_DIV</name>
                  <description>Feedback Clock Divider: N_FB_DIV[3:0]    
N_FB_DIV[3:0]    Clock Frequency Divided
        0000            1
        0001            1
        0010            2
        0011            3
        0100            4
        0101            5
        0110            6
        0111            7
        1000            8
        1001            -
        1010            10
        1011            -
        1100            12
        1101            14
        1110            16
        1111            32</description>
                  <bitRange>[21:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_ATST_SEL</name>
                  <description>testmode decoded pins</description>
                  <bitRange>[25:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_RUN_AWAY_DIS</name>
                  <description>Run Away Operation Enable

0 (default): run away operation enebled
1: run away operation disabled</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_RUN_AWAY_TRIM</name>
                  <description>changes the lock delay of the lock detector, the lock pulse can be delay/early by this bit</description>
                  <bitRange>[28:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_RUN_AWAY_DEL</name>
                  <description>change the lock delay of the lock detector, the lock pulse can be delay/early by this bit</description>
                  <bitRange>[30:29]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PLL_CONFIG_2</name>
              <description>PLL Configuration register2</description>
              <addressOffset>0x13C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x640000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>PLL_REG_CORE_TRIM</name>
                  <description>Spare bits</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_CAL_UP_DN</name>
                  <description>Calibrate the up down current of the charge pump mismatch, for schematic simulations. Program it to 0 only.</description>
                  <bitRange>[6:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_RA_UP_TR</name>
                  <description>define run away upper level</description>
                  <bitRange>[8:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_VCO_GAIN</name>
                  <description>Kvco trim change (scan mode - can be '0' or '1' - not High Z)</description>
                  <bitRange>[12:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_FB_SEL</name>
                  <description>Selects feedback clock for PLL

0 (default): VCO clock as PLL feedback clock (preferred option whrn PLL_MD=0)
1: VCO clock as PLL feedback clock
2: Serial clock as PLL feedback clock (to be used when PLL_MD=1)
3: External feedback clock as PLL feedback clock</description>
                  <bitRange>[14:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_MD</name>
                  <description>PLL Matching delay

0 (default): PLL Input Clock to Output Clock Delay is not matched to bypass delay. This setting must be used for all cases in which (input clock frequency)*(feedback divider setting)/(input divider setting) &gt; 350MHz
1: PLL Input Clock to Output Clock Delay is matched to PLL Bypass Delay (roughly 700ps)</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_CTRL_LOCK_DELAY</name>
                  <description>PLL Lock  delay (in ref/frame clock cycles)</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_CTRL_LOCK_LOSS_DELAY</name>
                  <description>PLL Lock Lost delay (in ref/frame clock cycles)</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_CTRL_EN_OVRDE</name>
                  <description>PLL Enable Overide

0 (default): Overide disable
1: Enables override with the Overide Lock Value</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_CTRL_OVRDE_LOCK_VAL</name>
                  <description>PLL Lock Overidevalue

0 (default): PLL not locked
1: PLL Locked</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_CTRL_SOURCE_LOCK</name>
                  <description>PLL Lock Source

0 (default): PLL Lock Filter (glitches are filtered)
1: PLL Lock (glitches not filtered)</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PLL_STATUS</name>
              <description>PLL Status Register</description>
              <addressOffset>0x140</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>PLL_DFT</name>
                  <description>logic dft output</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PLL_LOCK</name>
                  <description>pll lock signal (scan mode - forced to '0'). This register field doesn't go to 1 when the PLL is in bypass mode.

0: PLL is not locked.
1: PLL is locked.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PLL_RUN_AWAY_STICKY</name>
                  <description>run away occur at the system (will be reset only when pll is disable)</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>REG_1P25</name>
              <description>REG1P25 Config reg</description>
              <addressOffset>0x144</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFF</resetMask>
              <fields>
                <field>
                  <name>IREF_DLL_SEL</name>
                  <description>Selection Bits to tune DLL reference current.
Nominal Values:
0: 10.0uA
1: 10.6uA
2: 11.2uA
3: 11.9uA
4: 7.5uA
5: 8.1uA
6: 8.8uA
7: 9.4uA</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLE</name>
                  <description>Enable of LDO from 3.3V to 1.2V
0 (default): LDO disabled
1: LDO enabled</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>USE_REG</name>
                  <description>Bits to deterimne the use of regulator or switch from vccd to vout_1p25
0: Bypass regulator and connect vccd to vout_1p25
1: Use regulator to generate vout_1p25</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADFT_CTRL</name>
                  <description>Selection of analog MUX connectivity to adft[1:0].

0000b: no connection
0101b: 30uA test current on adft[1], vout_1p25 on adft[0]
1010b: enable voltage level on adft[1], regulator feedback voltage on adft[0]

All other combinations are not valid.</description>
                  <bitRange>[8:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADFT_EN</name>
                  <description>Enable of analog MUX for DfT
0 (default): AMUX disabled
1: AMUX enabled</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BURN_IN_EN</name>
                  <description>Enable of DLL Burn-in for 1.2V regulated domain
0 (default): DLL Burn-In disabled
1: DLL Burn-in enabled</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TRIM_VREG_1P25</name>
                  <description>Selection of feedback resistor for LDO output voltage
If DLL Burn-in Disabled

0000b (default): 1.21V
0001b: 1.2V
0010b: 1.19V
0011b: 1.18V
0100b: 1.17V
0101b: 1.16V
0110b: 1.15V
0111b: 1.14V
1000b: 1.29V
1001b: 1.28V
1010b: 1.27V
1011b: 1.26V
1100b: 1.25V
1101b: 1.24V
1110b: 1.23V
1111b: 1.22V

if DLL Burn-In Enabled
0000b (default): 1.45V</description>
                  <bitRange>[14:11]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>10</dim>
              <dimIncrement>4</dimIncrement>
              <name>RX[%s]</name>
              <description>LVDS RX Configuration Registers</description>
              <addressOffset>0x148</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1</resetValue>
              <resetMask>0x7F</resetMask>
              <fields>
                <field>
                  <name>FIXTIME_FRAMECLK</name>
                  <description>Inversion of Channel X (can be data, control or frame) Frame Clock before it is sent to DIG PHY
This bit is used to invert the frame clock used inside Channel X rx before the frame clock itself enters the DIG PHY. This is an emergency bit to avoid setup time violations inside the first resampling stage of DIG PHY.
0: The frame clock edge used for deserialization in analog is inverted after having used it to resample the parallel data before sending it to DIG PHY
1 (default): The frame clock edge used for deserialization in analog is not inverted after having used it to resample the parallel data before sending it to DIG PHY
Timing closure is only performed with the default value. Do nto change this setting.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EN_DESER</name>
                  <description>Enable of Data Deserialization inside rx
0 (default): Deserialization disabled
1: Deserialization enabled</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>INV_CLK_FRAME</name>
                  <description>Invert Polarity of Frame Clock used to shift parallel data out of rx deserializer
0 (default): rising edge of frame clock that enters rx shifts out parallel data out of rx deserializer
1: falling edge of frame clock that enters rx shifts out parallel data out of rx deserializer</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>INV_CLK_SER</name>
                  <description>Invert Polarity of Serial Clock that enters rx
0 (default): serial clock is not phase shifted. This setting is used in LVDS SDR Fast, LVDS DDR Fast and LVDS Slow mode.
1: serial clock is shifted by 180 degrees. This setting is used in LVDS Bypass Mode.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>INV_DATA_SER</name>
                  <description>Polarity Inversion of Serial Data. This is an emergency bit that should always stay at 0
0 (default): incoming serial data is not inverted
1: incoming serial data is inverted</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CLK_MUX_SEL</name>
                  <description>These bits are used to decide which serial clock and frame clock are to be buffered around the circuit.

Frame Clock MUX (Frame Clock Channel)
00: LVDS DDR/LVDS SDR Fast
01: LVDS Slow/LVDS Bypass 
10-11: Not Allowed

Serial Clock MUX (Data Channel 3)
00: LVDS DDR/SDR Fast
01: LVDS Slow
10: LVDS Bypass 
11: Not Allowed</description>
                  <bitRange>[6:5]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GENERAL_RX</name>
              <description>General RX Configuration Register</description>
              <addressOffset>0x170</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xF</resetMask>
              <fields>
                <field>
                  <name>DR_MODE</name>
                  <description>MUX Selection Signal for 8 bits output
0 (default): Double Data Rate
1: Single Data Rate</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BER_RSTN</name>
                  <description>BER reset.

0 (default): BER reset
1: BER not in reset</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DLL_BYPASS_EN</name>
                  <description>Bit that selects between dll_s output and licio_li as source for input data to rx

0 (default): Data is taken from corresponding dll_s; 
1: Data is coming from licio_li (LVDS pad)</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LSB_FIRST_MODE</name>
                  <description>Enables LSB first support on LVDS RX . Not supported. Hence always program this register field to 0 only

0 (default) : MSB first
1: LSB first</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GENERAL_RX_LVCMOS</name>
              <description>General LVCMOS RX Configuration Register</description>
              <addressOffset>0x174</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3E</resetMask>
              <fields>
                <field>
                  <name>CLK_MODE</name>
                  <description>Input Clock Inversion.
0 (default): Rising and Falling Edges of input clock to RX LVCMOS are not inverted. To be used in DDR.
1: Rising and Falling Clock Edges of input clock to RX LVCMOS are inverted. This value should never be used.
Timing closure is only done with the default value. Do not change this setting</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EN_DDR</name>
                  <description>DDR Sampling Enable.
0 (default): DDR Sampler is off. To be used in SDR.
1: DDR Sampler is on. To be used in DDR.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CLK_BYPASS</name>
                  <description>Bit used to bypass input data directly to DIG PHY

0: Input data to RX LVCMOS is sampled inside RX LVCMOS;
1: Input data to RX_LVCMOS is passed to DIG PHY without being sampled (feature used during wakeup)</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX_SEL</name>
                  <description>Selection bit to decide which clock to buffer in LVCMOS receiver mode.

0: Clock shifted 90 degree  from dll_M - to be used in LVCMOS DDR; 
1: Clock from licio_cio (LVCMOS pad) - to be used in LVCMOS SDR

Inorder to save clock tree power of this path, set this bit field to 1 in case of LVDS mode</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_CLK_EN</name>
                  <description>Selection bit for selecting serial clock coming from PLL. This bit should always stay at 0.

0 (default): Serial clock coming from PLL d to rx_lvcmos_dq_1_0 not enabled
1: Serial clock coming from PLL d to rx_lvcmos_dq_1_0 enabled</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>26</dim>
              <dimIncrement>4</dimIncrement>
              <name>RX_LVCMOS[%s]</name>
              <description>LVCMOS RX Configuration Registers</description>
              <addressOffset>0x178</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1</resetMask>
              <fields>
                <field>
                  <name>EN_LVCMOS</name>
                  <description>RX LVCMOS Enable.
0 (default): RX LVCMOS is off, i.e. No data sampling occurs. If this bit is 0, also DDR samplers inside RX LVCMOS are off
1: SDR Sampler is on. This bit must go high in all LVCMOS receiver modes.

Note: to enable DDR sampling in RX LVCMOS, both en_lvcmos and en_ddr are to be set to 1.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PRBS_GEN</name>
              <description>State counter limit register</description>
              <addressOffset>0x204</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1FF</resetMask>
              <fields>
                <field>
                  <name>EN</name>
                  <description>PRBS_GEN Enable Signal

0 (default): prbs_gen disabled
1: prbs_gen enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SEED</name>
                  <description>Input Seed for PRBS Generation.

00000 (default): Fixed Output Sequence (9C in SDR, C9 in DDR).
Any other value: PRBS-5 as Output Sequence.</description>
                  <bitRange>[5:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DDR_EN</name>
                  <description>DDR Bit Stream Generation Enable.

0(default): DDR generation disabled. To be used in case of LVDS SDR Loopback.
1: DDR generation enabled. To be used in case of LVDS DDR Loopback.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MULT_ERR_EN</name>
                  <description>0 (default): Stop on 1st error
1:Multiple errors allowed and they will be counted</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CLK_SRC</name>
                  <description>PRBS_GEN Clock Source

0 (default): CLK_HF
1: CLK480Mhz div 4

This field is not used at all. Loopback works on clk_hf only.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PHY_GENERAL_CONFIG</name>
              <description>Phy Configuration register</description>
              <addressOffset>0x208</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x14140200</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DESKEW_ALGORITHM</name>
                  <description>Chosen deskew algorithm:

0(default): bypass
1: slow
2: SDR fast
3: DDR fast</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLE_SCANON</name>
                  <description>Vddd related enable signal</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLE_V1P25_VCCD</name>
                  <description>Enable indicating v1p25 is powered</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLE_V1P1_VCCD</name>
                  <description>Enable indicating v1p1 is powered</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLE_VDDIO</name>
                  <description>Enable related to VDDIO</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LVCMOS_TX_CLKSEL</name>
                  <description>Selects the TX clock used for LVCMOS. This register field is no more used. To define source clock to be used to drive out lvcmos interface clock from LVDS, use register field GPIF.LVCMOS_CLK_OUT_CFG.

0(default): LVCMOS pad
1: PLL output
2: clock_hf
3: clock_hf1</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BERCLK_SKEW_MARGIN</name>
                  <description>BER CLK Skew Margin in relation to SER CLK  (used for Monitoring)</description>
                  <bitRange>[9:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MONITOR_FREQ</name>
                  <description>How many times will the Monitoring checks be done during normal operation, for every 100us interval:

0(default): run once every 100us
1: run 2 times every 100us
2: run 4 times every 100us
3: run 8 times every 100us
4: run 16 times every 100us
5: run 32 times every 100us
6: run 64 times every 100us
7: run 128 times every 100us</description>
                  <bitRange>[12:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MONITOR_TIME</name>
                  <description>How long 1 Monitoring run will take:

0(default): check 1 frame
1: check 10 frames
2: check 100 frames
3: check 1000 frames
4: check 5000 frames
5: check 10000 frames
6: check 50000 frames
7: check 100000 frames</description>
                  <bitRange>[15:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MONITOR_NON_STOP</name>
                  <description>Enables non-stop monitoring:
0(default): Non-stop monitoring off
1: Non-stop monitoring ON</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DESKEW_ERR_THRESH1</name>
                  <description>Deskew Prioritary error threshold, to be used by default</description>
                  <bitRange>[23:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DESKEW_ERR_THRESH2</name>
                  <description>Deskew Relaxed error threshold, to be used if default one is too tight and fails Pass/Fail sanity check</description>
                  <bitRange>[30:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BIST_RLXD_MARGIN_SEL</name>
                  <description>Enables relaxed interval margins for BIST checks:
0(default): Regular interval margins
1: Relaxed interval margins</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PHY_GENERAL_STATUS_1</name>
              <description>Phy Status register (Loopback Status Lanes)</description>
              <addressOffset>0x20C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>PRBS_CHECKER_STATE_D0</name>
                  <description>Status of the PRBS Checker for Data0 Lane

0: not activated
1: link start-up
2: locked to a detected sequence
3: sequence once found, now lost, trying to lock-up again</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PRBS_CHECKER_STATE_D1</name>
                  <description>Status of the PRBS Checker for Data1 Lane</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PRBS_CHECKER_STATE_D2</name>
                  <description>Status of the PRBS Checker for Data2 Lane</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PRBS_CHECKER_STATE_D3</name>
                  <description>Status of the PRBS Checker for Data3 Lane</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PRBS_CHECKER_STATE_D4</name>
                  <description>Status of the PRBS Checker for Data4 Lane</description>
                  <bitRange>[9:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PRBS_CHECKER_STATE_D5</name>
                  <description>Status of the PRBS Checker for Data5 Lane</description>
                  <bitRange>[11:10]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PRBS_CHECKER_STATE_D6</name>
                  <description>Status of the PRBS Checker for Data6 Lane</description>
                  <bitRange>[13:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PRBS_CHECKER_STATE_D7</name>
                  <description>Status of the PRBS Checker for Data7 Lane</description>
                  <bitRange>[15:14]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PRBS_CHECKER_STATE_CTRL</name>
                  <description>Status of the PRBS Checker for Control Lane</description>
                  <bitRange>[17:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PRBS_RUN_STATUS</name>
                  <description>Overall Status of the PRBS Checker
0: Checker failed (read PRBS Status reg for Error count)
1: Checker passed</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PHY_GENERAL_STATUS_2</name>
              <description>Phy Status register</description>
              <addressOffset>0x210</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFDFF</resetMask>
              <fields>
                <field>
                  <name>LOOPBACK_STOPPED</name>
                  <description>Set when loopback is stopped either because of an error or SW stop</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MONITOR_RUNNING</name>
                  <description>Set when monitoring is started</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MONITOR_COMPLETED</name>
                  <description>Set when monitoring is completed</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DESKEW_RUNNING</name>
                  <description>Set when deskew is started</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DESKEW_COMPLETED</name>
                  <description>Set when deskew is completed</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MONITOR_ADJUST_FAIL</name>
                  <description>Set when Monitor cannot adjust phase selection anymore and Deskew needs to be rerun</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>OK_DLL_VCCD</name>
                  <description>Set when power supply is stable</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>OK_V1P1_VCCD</name>
                  <description>Set when power supply is stable</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>OK_V1P25_VCCD</name>
                  <description>Set when power supply is stable</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PLL_LOCK_ACQUIRED</name>
                  <description>Set when PLL is locked</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PLL_LOCK_LOST</name>
                  <description>Set when PLL is unlocked</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MDLL_LOCK_ACQUIRED</name>
                  <description>Set when MDLL is locked</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MDLL_LOCK_LOST</name>
                  <description>Set when MDLL is unlocked</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>BIST_MDLL_DONE</name>
                  <description>Set when BIST check is done for MDLL</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>BIST_SDLL_DONE</name>
                  <description>Set when BIST check is done for all SDLL's</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PHY_INTR</name>
              <description>Phy Interrupt Register</description>
              <addressOffset>0x214</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>LOOPBACK_STOPPED</name>
                  <description>Set when loopback is stopped either because of an error or SW stop</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MONITOR_RUNNING</name>
                  <description>Set when monitoring is started</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MONITOR_COMPLETED</name>
                  <description>Set when monitoring is completed</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DESKEW_RUNNING</name>
                  <description>Set when deskew is started</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DESKEW_COMPLETED</name>
                  <description>Set when deskew is completed</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MONITOR_ADJUST_FAIL</name>
                  <description>Set when Monitor cannot adjust phase selection anymore and Deskew needs to be rerun</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OK_DLL_VCCD</name>
                  <description>Set when power supply is stable</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OK_V1P1_VCCD</name>
                  <description>Set when power supply is stable</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OK_V1P25_VCCD</name>
                  <description>Set when power supply is stable</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GPIO_INTR</name>
                  <description>GPIO interrupt</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_LOCK_ACQUIRED</name>
                  <description>Set when PLL is locked</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_LOCK_LOST</name>
                  <description>Set when PLL is unlocked</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MDLL_LOCK_ACQUIRED</name>
                  <description>Set when MDLL is locked</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MDLL_LOCK_LOST</name>
                  <description>Set when MDLL is unlocked</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BIST_MDLL_DONE</name>
                  <description>Set when BIST check is done for MDLL</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BIST_SDLL_DONE</name>
                  <description>Set when BIST check is done for all SDLL's</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SAR_DONE</name>
                  <description>Marks Completion of the ADC SAR1-4 conversion at the end of 8 cycles of clk_sar when SAR_EN is '1'</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADC_CMP_OUT_POS_EDGE</name>
                  <description>Indicates that ADC output went high</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADC_CMP_OUT_FALL_EDGE</name>
                  <description>Indicates that ADC output went low</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PHY_INTR_MASK</name>
              <description>Phy Interrupt Mask Register</description>
              <addressOffset>0x218</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>LOOPBACK_STOPPED</name>
                  <description>Set when loopback is stopped either because of an error or SW stop</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MONITOR_RUNNING</name>
                  <description>Set when monitoring is started</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MONITOR_COMPLETED</name>
                  <description>Set when monitoring is completed</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DESKEW_RUNNING</name>
                  <description>Set when deskew is started</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DESKEW_COMPLETED</name>
                  <description>Set when deskew is completed</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MONITOR_ADJUST_FAIL</name>
                  <description>Set when Monitor cannot adjust phase selection anymore and Deskew needs to be rerun</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OK_DLL_VCCD</name>
                  <description>Set when power supply is stable</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OK_V1P1_VCCD</name>
                  <description>Set when power supply is stable</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OK_V1P25_VCCD</name>
                  <description>Set when power supply is stable</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GPIO_INTR</name>
                  <description>GPIO interrupt</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_LOCK_ACQUIRED</name>
                  <description>Set when PLL is locked</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_LOCK_LOST</name>
                  <description>Set when PLL is unlocked</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MDLL_LOCK_ACQUIRED</name>
                  <description>Set when MDLL is locked</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MDLL_LOCK_LOST</name>
                  <description>Set when MDLL is unlocked</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BIST_MDLL_DONE</name>
                  <description>Set when BIST check is done for MDLL</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BIST_SDLL_DONE</name>
                  <description>Set when BIST check is done for all SDLL's</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SAR_DONE</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADC_CMP_OUT_POS_EDGE</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADC_CMP_OUT_FALL_EDGE</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PHY_INTR_MASKED</name>
              <description>Phy Interrupt Masked Register</description>
              <addressOffset>0x21C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>LOOPBACK_STOPPED</name>
                  <description>Set when loopback is stopped either because of an error or SW stop</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MONITOR_RUNNING</name>
                  <description>Set when monitoring is started</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MONITOR_COMPLETED</name>
                  <description>Set when monitoring is completed</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DESKEW_RUNNING</name>
                  <description>Set when deskew is started</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DESKEW_COMPLETED</name>
                  <description>Set when deskew is completed</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MONITOR_ADJUST_FAIL</name>
                  <description>Set when Monitor cannot adjust phase selection anymore and Deskew needs to be rerun</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>OK_DLL_VCCD</name>
                  <description>Set when power supply is stable</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>OK_V1P1_VCCD</name>
                  <description>Set when power supply is stable</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>OK_V1P25_VCCD</name>
                  <description>Set when power supply is stable</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GPIO_INTR</name>
                  <description>GPIO interrupt</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PLL_LOCK_ACQUIRED</name>
                  <description>Set when PLL is locked</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PLL_LOCK_LOST</name>
                  <description>Set when PLL is unlocked</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MDLL_LOCK_ACQUIRED</name>
                  <description>Set when MDLL is locked</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MDLL_LOCK_LOST</name>
                  <description>Set when MDLL is unlocked</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>BIST_MDLL_DONE</name>
                  <description>Set when BIST check is done for MDLL</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>BIST_SDLL_DONE</name>
                  <description>Set when BIST check is done for all SDLL's</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SAR_DONE</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ADC_CMP_OUT_POS_EDGE</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ADC_CMP_OUT_FALL_EDGE</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PHY_INTR_SET</name>
              <description>Phy Interrupt Set Register</description>
              <addressOffset>0x220</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>LOOPBACK_STOPPED</name>
                  <description>Set when loopback is stopped either because of an error or SW stop</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MONITOR_RUNNING</name>
                  <description>Set when monitoring is started</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MONITOR_COMPLETED</name>
                  <description>Set when monitoring is completed</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DESKEW_RUNNING</name>
                  <description>Set when deskew is started</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DESKEW_COMPLETED</name>
                  <description>Set when deskew is completed</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MONITOR_ADJUST_FAIL</name>
                  <description>Set when Monitor cannot adjust phase selection anymore and Deskew needs to be rerun</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OK_DLL_VCCD</name>
                  <description>Set when power supply is stable</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OK_V1P1_VCCD</name>
                  <description>Set when power supply is stable</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OK_V1P25_VCCD</name>
                  <description>Set when power supply is stable</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GPIO_INTR</name>
                  <description>GPIO interrupt</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_LOCK_ACQUIRED</name>
                  <description>Set when PLL is locked</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PLL_LOCK_LOST</name>
                  <description>Set when PLL is unlocked</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MDLL_LOCK_ACQUIRED</name>
                  <description>Set when MDLL is locked</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MDLL_LOCK_LOST</name>
                  <description>Set when MDLL is unlocked</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BIST_MDLL_DONE</name>
                  <description>Set when BIST check is done for MDLL</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BIST_SDLL_DONE</name>
                  <description>Set when BIST check is done for all SDLL's</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SAR_DONE</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADC_CMP_OUT_POS_EDGE</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADC_CMP_OUT_FALL_EDGE</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PHY_TRAIN_CONFIG</name>
              <description>Phy Training Mode Config register</description>
              <addressOffset>0x224</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xC8A6</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TRAIN_EN</name>
                  <description>1 - starts a new training sequence
0 - training complete</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TRAIN_SEQ</name>
                  <description>Training Sequence. Recommonded to use one of below values only.
8'hB3, 8'h4C, 8'hCA, 8'h35, 8'hBA, 8'h45, 8'h9C, 8'h63, 8'h39, 8'hC6</description>
                  <bitRange>[8:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TRAIN_CYCLES_NO</name>
                  <description>Number of cycles to check data on for each DLL_S sel_ph value</description>
                  <bitRange>[15:9]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PHY_ADC_CONFIG</name>
              <description>ADC config register</description>
              <addressOffset>0x228</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x408000</resetValue>
              <resetMask>0x3FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DAC_CNTRL</name>
                  <description>8-bit DAC Input. This register should be used if FW wants to control the ADC directly bypassing the SAR logic</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MID_VAL</name>
                  <description>ADC starting mid value</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDO_TRIM</name>
                  <description>LDO trim : typ 1.15V, 1 percent step, 0.5 percent trim accuracy</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDO_EN</name>
                  <description>Enable LDO</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ISO_N</name>
                  <description>Output isolation control.  Active Low
0: All digital outputs are forced low</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PD_LV</name>
                  <description>Block enable input
1 - All analog and DC paths cut off, outputs forced to known value
0 - Normal functionality</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DFT_MUXSEL</name>
                  <description>DFT control signal, active high
1 - DAC output is placed on dft_out</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>VSEL</name>
                  <description>Comparator voltage select:
000 - ana_in1 voltage
001 - ana_in2 voltage
010 - vbg voltage
011 - NPN voltage for temperature sensing, 100~111 for a&lt;0:3&gt;</description>
                  <bitRange>[26:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>VREF_DAC_SEL</name>
                  <description>VREF DAC select:
00 - ldo output voltage
01 - vddio voltage
10 - vccd voltage
11 - N.A ( not connected)</description>
                  <bitRange>[28:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SAR_EN</name>
                  <description>Setting this bit will enable the HW SAR logic.
Once the SAR_EN is one, Hardware will update the  SAR_OUT register after 8 cycles of clk_sar and clear this register.</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PHY_DDFT_MUX_SEL</name>
              <description>Digital Mux Select Register</description>
              <addressOffset>0x22C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xBFBFFFFF</resetMask>
              <fields>
                <field>
                  <name>DDFT0_MUX_SEL</name>
                  <description>Following 1bit signals can be selected on the DDFT bus position 0
000000b (default): Analog ADC Output
000001b: PLL_LOCK
000010b: DLL_M_LOCK
000011b: BIST_M_DONE
000100b: BIST_M_FAIL
000101b: BIST_S_DONE (bitwise AND on bist_s_done[11:0]  vector)
000110b: BIST_S_FAIL (bitwise AND on bist_s_fail[11:0]  vector)
000111b: BIST_DONE (M &amp; S)
001000b: DESKEW_EN
001001b: DESKEW_ON
001010b: DESKEW_DONE
001011b: MONITOR_ON
001100b: MONITOR_DONE
001101b: LOOPBACK_ON
001110b: LOOPBACK_OK (--&gt; Continues)
001111b: MONITOR_FAIL
010000b: DATA CHN0 DFT
010001b: DATA CHN1 DFT
010010b: DATA CHN2 DFT
010011b: DATA CHN3 DFT
010100b: DATA CHN4 DFT
010101b: DATA CHN5 DFT
010110b: DATA CHN6 DFT
010111b: DATA CHN7 DFT
011000b: CTRL DFT
011001b: FRAME CLK DFT
011010b: BER CLK DFT
011011b: SER CLK DFT
011100b: DLLM CLK DFT
011101b: DLLM BBPD DFT
011110b: PLL DFT
100000b: DATA_ALIGN_LEFT[0]
100001b: DATA_ALIGN_LEFT[1]
100010b: DATA_ALIGN_LEFT[2]
100011b: DATA_ALIGN_LEFT[3]
100100b: DATA_ALIGN_LEFT[4]
100101b: DATA_ALIGN_LEFT[5]
100110b: DATA_ALIGN_LEFT[6]
100111b: DATA_ALIGN_LEFT[7]
101000b: CTRL_ALIGN_LEFT
110000b: DATA_ALIGN_RIGHT[0]
110001b: DATA_ALIGN_RIGHT[1]
110010b: DATA_ALIGN_RIGHT[2]
110011b: DATA_ALIGN_RIGHT[3]
110100b: DATA_ALIGN_RIGHT[4]
110101b: DATA_ALIGN_RIGHT[5]
110110b: DATA_ALIGN_RIGHT[6] (-&gt; continues below)
110111b: DATA_ALIGN_RIGHT[7]
111000b: CTRL_ALIGN_RIGHT</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DDFT0_LVCMOSOUT_SEL</name>
                  <description>Enables LVCMOS pad output for DDFT bus pos 0:
0 = LVCMOS data output on LVCMOS pad (default)
1 = DDFT[0] output on appropriate LVCMOS pad</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DDFT0_LINK_SEL</name>
                  <description>Selects between LINK0 and LINK1 signals for DDFT bus pos 0:
0 = LINK0 (default)
1 = LINK1</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DDFT1_MUX_SEL</name>
                  <description>Following 1bit signals can be selected on the DDFT bus position 1
List of signals is same, as mentioned in bitfield [5:0]</description>
                  <bitRange>[13:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DDFT1_LVCMOSOUT_SEL</name>
                  <description>Enables LVCMOS pad output for DDFT bus pos 1:
0 = LVCMOS data output on LVCMOS pad (default)
1 = DDFT[1] output on appropriate LVCMOS pad</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DDFT1_LINK_SEL</name>
                  <description>Selects between LINK0 and LINK1 signals for DDFT bus pos 1:
0 = LINK0 (default)
1 = LINK1</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GPIO0_MUX_SEL</name>
                  <description>Following 1bit signals can be selected on the GPIO_DDFT bus pos 0:
List of signals is same, as mentioned in bitfield [5:0]</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GPIO0_LINK_SEL</name>
                  <description>Selects between LINK0 and LINK1 signals for GPIO bus pos 0:
0 = LINK0 (default)
1 = LINK1</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GPIO1_MUX_SEL</name>
                  <description>Following 1bit signals can be selected on the GPIO_DDFT bus pos 1:
List of signals is same, as mentioned in bitfield [5:0]</description>
                  <bitRange>[29:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GPIO1_LINK_SEL</name>
                  <description>Selects between LINK0 and LINK1 signals for GPIO bus pos 1:
0 = LINK0 (default)
1 = LINK1</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LICIO_VCCD_V1P1</name>
              <description>LICIO_VCCD_V1P1 Config reg</description>
              <addressOffset>0x230</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x9</resetMask>
              <fields>
                <field>
                  <name>EN</name>
                  <description>V1P1Enable</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ATST_EN</name>
                  <description>Analog test enable</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>26</dim>
              <dimIncrement>4</dimIncrement>
              <name>PHY_GPIO[%s]</name>
              <description>GPIO Config register</description>
              <addressOffset>0x234</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1</resetValue>
              <resetMask>0x8000000F</resetMask>
              <fields>
                <field>
                  <name>OUT_VALUE</name>
                  <description>Output value used for output drive (if OUTPUT_EN=1)
0: Driven LOW
1: Driven HIGH</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IN_VALUE</name>
                  <description>Present input measurement
0: LOW
1: HIGH</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>OUTPUT_EN</name>
                  <description>0: Output stage is disabled
1: Output stage is enabled, value of OUT_VALUE appears on PAD</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>INPUT_EN</name>
                  <description>0: Input stage is disabled
1: Input stage is enabled, value is readable in IN_VALUE</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GPIO_ENABLE</name>
                  <description>Enable GPIO logic for this pin.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PHY_GPIO_INTR_CFG</name>
              <description>GPIO Interrupt Config register</description>
              <addressOffset>0x304</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x71F</resetMask>
              <fields>
                <field>
                  <name>GPIO_INTR_PIN_SEL</name>
                  <description>Selects one of the 26 GPIO pins to have interrupt capability</description>
                  <bitRange>[4:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>INTRMODE</name>
                  <description>N/A</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PHY_GENERAL_CONFIG_2</name>
              <description>Phy Configuration Register2</description>
              <addressOffset>0x30C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CNT_10US24_VAL</name>
                  <description>Used in locking procedure of DLL. Also used in DLL BIST wait timing.
 
In LVDS mode it must be configured depending on FRAME_CLK frequency (same as deskew algorithm) in order to allow the counter to wait 10.24us.
In LVCMOS mode it must be configured depending on SERIAL_CLK frequency (same as deskew algorithm) in order to allow the counter to wait 10.24us.
 
Should have as close value as possible to 10.24us/T(frameclk) for lvds mode and as close as possible to 10.24us/T(serialclk) for lvcmos mode.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MONITOR_ERR_THRESH</name>
                  <description>Monitor Error Threshold (Number of errors in one run over which the DLL delay will be adjusted)

Absolute value. Should be sized accordingly to the number of frames analyzed (btis 15:13/MONITOR_TIME in PHY_GENRERAL_CONFIG reg)</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PRBS_STATUS</name>
              <description>Loopback error rate register</description>
              <addressOffset>0x310</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>BER_COUNTER</name>
                  <description>Error counter for PRBS Loopback.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>10</dim>
              <dimIncrement>4</dimIncrement>
              <name>LVDS_STATUS_MONITOR[%s]</name>
              <description>LVDS Pin status monitor</description>
              <addressOffset>0x314</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>LVDS_PAD_VALUE</name>
                  <description>Present input measurement
0: LOW
1: HIGH</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LVDS_PAD_RDEN</name>
                  <description>0: Input stage is disabled
1: Input stage is enabled, value is readable in IN_VALUE</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PHY_ADC_STATUS</name>
              <description>ADC status register</description>
              <addressOffset>0x340</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF01</resetMask>
              <fields>
                <field>
                  <name>CMP_OUT</name>
                  <description>ADC Comparator Output</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SAR_OUT</name>
                  <description>ADC output resistance value
Stored 8-bit ADC value after the ID Pin voltage is sampled.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>FRM_CLK_GLITCH_FILTER</name>
              <description>Frame clock glitch filter configuration register</description>
              <addressOffset>0x344</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x50F</resetValue>
              <resetMask>0x1FFFF</resetMask>
              <fields>
                <field>
                  <name>CLKGATE_DURATION</name>
                  <description>Duration is in terms of PERI cycles.
This duration kicks in from the time frame clock phase is changed by deskew algo. And clock output of frame clock DLL will be gated for this whole duration. 
Don't change default value.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHASE_CHNG_EFFECT_TIME</name>
                  <description>Duration is in terms of PERI cycles.
This timeoff  kicks in from the time frame clock phase is changed by deskew algo. Once this time expires, new phase selected by deskew algo will be applied to frame clock slave DLL.
Don't change default value.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BYPASS_GLITCH_FILTER</name>
                  <description>Controls whether to use frame clock glitch filter logic or not.
0 - Use frame clock glitch filter
1 - Bypass frame clock glitch filter</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LICIO_CIO_CTRL_DS</name>
              <description>LICIO_CIO control pad DS/SR register</description>
              <addressOffset>0x400</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x31F</resetMask>
              <fields>
                <field>
                  <name>DS</name>
                  <description>licio_cio impedance control select.

Program this field with 'b11111 only, as timing is closed for this value only.</description>
                  <bitRange>[4:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SR</name>
                  <description>licio_cio output slew rate select</description>
                  <bitRange>[9:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>17</dim>
              <dimIncrement>4</dimIncrement>
              <name>LICIO_CIO_DATA_DS[%s]</name>
              <description>LICIO_CIO Data/Clk pad DS/SR register</description>
              <addressOffset>0x404</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x31F</resetMask>
              <fields>
                <field>
                  <name>DS</name>
                  <description>licio_cio impedance control select

Program this field with 'b11111 only, as timing is closed for this value only.</description>
                  <bitRange>[4:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SR</name>
                  <description>licio_cio output slew rate select</description>
                  <bitRange>[9:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DLY_CELL_LOAD</name>
              <description>Delay cell Load control register</description>
              <addressOffset>0x4FC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>LOAD</name>
                  <description>Controls the load seen by Delay cell output. Normally this register field will be set to match with the load of the lvcmos io pads on board.
0: 8pf
1: 12pf
2,3: 15pf</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SAR_CLK_FREQ_CFG</name>
              <description>SAR clock frequency configuration</description>
              <addressOffset>0x500</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>CLK_DIV</name>
                  <description>Divided version of MMIO clock is used as SAR clock
0: div-by-1
1: div-by-2
2: div-by-3
3: div-by-4</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>STUCK_AT_CNTRS</name>
              <description>Stuck-at fault counters</description>
              <addressOffset>0x504</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CNTR0</name>
                  <description>Stuck-at counter 0</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CNTR1</name>
                  <description>Stuck-at counter 1</description>
                  <bitRange>[7:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CNTR2</name>
                  <description>Stuck-at counter 2</description>
                  <bitRange>[11:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CNTR3</name>
                  <description>Stuck-at counter 3</description>
                  <bitRange>[15:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CNTR4</name>
                  <description>Stuck-at counter 4</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CNTR5</name>
                  <description>Stuck-at counter 5</description>
                  <bitRange>[23:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CNTR6</name>
                  <description>Stuck-at counter 6</description>
                  <bitRange>[27:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CNTR7</name>
                  <description>Stuck-at counter 7</description>
                  <bitRange>[31:28]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>STUCK_CNTR_RST_CTL</name>
              <description>Stuck-at fault counters Reset control register</description>
              <addressOffset>0x508</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>CNTR_RST</name>
                  <description>This register field is used to reset stuck-at-counters. 
1 : reset stuck-at-counters
0 : de-assert reset to stuck-at-counters</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>STUCK_CNTR_SIG_SEL_0</name>
              <description>Stuck at fault counter signal select</description>
              <addressOffset>0x510</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>SIG_SEL_OF_CNTR_0</name>
                  <description>Signal which need to be monitored for Stuck-at-fault, by STUCK_AT_CNTRS.CNTR 0.

0 - 31 : lvcmos_dq_o[0], [1], [2]...............[31]
32 - 51 : lvcmos_ctrl_o[0], [1],.............. [19]
52 - 67 : lvcmos_dq_sdr_o[0], [1]..............[15]
68 - 77 : lvcmos_ctrl_sdr[0], [1] ...................[9]
78 - 85 : d_ctrl_o[0], [1], ........[7]
86 - 93 : d_sub_data_chn0_o[0], [1], ........[7]
94 - 101 : d_sub_data_chn0_o[0], [1], ........[7]
102 - 109 : d_sub_data_chn0_o[0], [1], ........[7]
110 - 117  : d_sub_data_chn0_o[0], [1], ........[7]
118 - 125  : d_sub_data_chn0_o[0], [1], ........[7]
126 - 133  : d_sub_data_chn0_o[0], [1], ........[7]
134 - 141  : d_sub_data_chn0_o[0], [1], ........[7]
142 - 149  : d_sub_data_chn0_o[0], [1], ........[7]
150 - 157 : clk_frame_o[0], [1], ........ [7]
158 : 1'b0
159 : clk_lvcmos_o
160 : lvcmos_clk_frame_o
161 : d_sub_clk_frame_o
162 : ctrl_ber_o
163 : frame_clk_ber_o
164 : data_chn0_ber_o
165 : data_chn1_ber_o
166 : data_chn2_ber_o
167 : data_chn3_ber_o
168 : data_chn4_ber_o
169 : data_chn5_ber_o
170 : data_chn6_ber_o
171 : data_chn7_ber_o</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SIG_SEL_OF_CNTR_1</name>
                  <description>Signal which need to be monitored for Stuck-at-fault, by STUCK_AT_CNTRS.CNTR 1.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SIG_SEL_OF_CNTR_2</name>
                  <description>Signal which need to be monitored for Stuck-at-fault, by STUCK_AT_CNTRS.CNTR 2.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SIG_SEL_OF_CNTR_3</name>
                  <description>Signal which need to be monitored for Stuck-at-fault, by STUCK_AT_CNTRS.CNTR 3.</description>
                  <bitRange>[31:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>STUCK_CNTR_SIG_SEL_1</name>
              <description>Stuck at fault counter signal select</description>
              <addressOffset>0x514</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>SIG_SEL_OF_CNTR_4</name>
                  <description>Signal which need to be monitored for Stuck-at-fault, by STUCK_AT_CNTRS.CNTR 0.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SIG_SEL_OF_CNTR_5</name>
                  <description>Signal which need to be monitored for Stuck-at-fault, by STUCK_AT_CNTRS.CNTR 1.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SIG_SEL_OF_CNTR_6</name>
                  <description>Signal which need to be monitored for Stuck-at-fault, by STUCK_AT_CNTRS.CNTR 2.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SIG_SEL_OF_CNTR_7</name>
                  <description>Signal which need to be monitored for Stuck-at-fault, by STUCK_AT_CNTRS.CNTR 3.</description>
                  <bitRange>[31:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>7</dim>
              <dimIncrement>4</dimIncrement>
              <name>CTL_PIN_SDLL_CFG[%s]</name>
              <description>Control pin slave dll monitor config</description>
              <addressOffset>0x520</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1F</resetMask>
              <fields>
                <field>
                  <name>CTL_PIN_SEL</name>
                  <description>Selects which Salve DLL's dft clock has to be routed to the contril pin.
7:0 - Data Lanes [7:0]
8    - Ctrl
9    - Frame Clock
10  - Ber Clock
11  - Ser Clock</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EN_SDLL_CLK_MON</name>
                  <description>Enables routing on Slave DLL's dft clock to lvcmos sideband control pin, selected by register field CTL_IN_SEL.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LVDS_BER_STATUS</name>
              <description>LVDS rx_data_channel instance ber status</description>
              <addressOffset>0x540</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1FF</resetMask>
              <fields>
                <field>
                  <name>LVDS_DATA_BER</name>
                  <description>ber_o output of rx_data_chn_0 to rx_data_chn_7</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LVDS_CTRL_BER</name>
                  <description>ber_o output of rx_ctrl</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
          <cluster>
            <dim>2</dim>
            <dimIncrement>65536</dimIncrement>
            <name>ADAPTER_DMA[%s]</name>
            <description>LVDS Adapter Registers
0x1_0000 is for Adapter-0 and 0x2_0000 is for Adapter-1</description>
            <addressOffset>0x00010000</addressOffset>
            <cluster>
              <dim>16</dim>
              <dimIncrement>128</dimIncrement>
              <name>SCK[%s]</name>
              <description>Socket Registers</description>
              <addressOffset>0x00008000</addressOffset>
              <register>
                <name>SCK_DSCR</name>
                <description>Descriptor Chain Pointer</description>
                <addressOffset>0x0</addressOffset>
                <size>32</size>
                <access>read-write</access>
                <resetValue>0x0</resetValue>
                <resetMask>0xFFFFFFFF</resetMask>
                <fields>
                  <field>
                    <name>DSCR_NUMBER</name>
                    <description>Descriptor number of currently active descriptor.  A value of 0xFFFF designates no (more) active descriptors available.  When activating a socket CPU shall write number of first descriptor in here. Only modify this field when go_suspend=1 or go_enable=0</description>
                    <bitRange>[15:0]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>DSCR_COUNT</name>
                    <description>Number of descriptors still left to process.  This value is unrelated to actual number of descriptors in the list.  It is used only to generate an interrupt to the CPU when the value goes low or zero (or both).  When this value reaches 0 it will wrap around to 255.  The socket will not suspend or be otherwise affected unless the descriptor chains ends with 0xFFFF descriptor number.</description>
                    <bitRange>[23:16]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>DSCR_LOW</name>
                    <description>The low watermark for dscr_count.  When dscr_count is equal or less than dscr_low the status bit dscr_is_low is set and an interrupt can be generated (depending on int mask).</description>
                    <bitRange>[31:24]</bitRange>
                    <access>read-write</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>SCK_SIZE</name>
                <description>Transfer Size Register</description>
                <addressOffset>0x4</addressOffset>
                <size>32</size>
                <access>read-write</access>
                <resetValue>0x0</resetValue>
                <resetMask>0xFFFFFFFF</resetMask>
                <fields>
                  <field>
                    <name>TRANS_SIZE</name>
                    <description>The number of bytes or buffers (depends on unit bit in SCK_STATUS) that are part of this transfer.  A value of 0 signals an infinite/undetermined transaction size.
Valid data bytes remaining in the last buffer beyond the transfer size will be read by socket and passed on to the core. FW must ensure that no additional bytes beyond the transfer size are present in the last buffer.                                                                          Note: For non-zero TRANS_SIZE in ingress sockets, if the number of bytes that are part of the transfer exceed the TRANS_SIZE, the socket will wrap up the buffer on EOP regardless of whether the buffer is full or not.</description>
                    <bitRange>[31:0]</bitRange>
                    <access>read-write</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>SCK_COUNT</name>
                <description>Transfer Count Register</description>
                <addressOffset>0x8</addressOffset>
                <size>32</size>
                <access>read-write</access>
                <resetValue>0x0</resetValue>
                <resetMask>0xFFFFFFFF</resetMask>
                <fields>
                  <field>
                    <name>TRANS_COUNT</name>
                    <description>The number of bytes or buffers (depends on unit bit in SCK_STATUS) that have been transferred through this socket so far.  If trans_size is &gt;0 and trans_count&gt;=trans_size the  'trans_done' bits in SCK_STATUS is both set.  If SCK_STATUS.susp_trans=1 the socket is also suspended and the 'suspend' bit set. This count is updated only when a descriptor is completed and the socket proceeds to the next one.
Exception: When socket suspends with PARTIAL_BUF=1, this value has been (incorrectly) incremented by 1 (UNIT=1) or DSCR_SIZE.BYTE_COUNT (UNIT=0).  Firmware must correct this before resuming the socket.</description>
                    <bitRange>[31:0]</bitRange>
                    <access>read-write</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>SCK_STATUS</name>
                <description>Socket Status Register</description>
                <addressOffset>0xC</addressOffset>
                <size>32</size>
                <access>read-write</access>
                <resetValue>0x4E00000</resetValue>
                <resetMask>0xFFFF8FFF</resetMask>
                <fields>
                  <field>
                    <name>AVL_COUNT</name>
                    <description>Number of available (free for ingress, occupied for egress) descriptors beyond the current one.  This number is incremented by the adapter whenever an event is received on this socket and decremented whenever it activates a new descriptor. This value is used to create a signal to the IP Cores that indicates at least one buffer is available beyond the current one (sck_more_buf_avl).</description>
                    <bitRange>[4:0]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>AVL_MIN</name>
                    <description>Minimum number of available buffers required by the adapter before activating a new one.  This can be used to guarantee a minimum number of buffers available with old data to implement rollback.  If AVL_ENABLE, the socket will remain in STALL state until AVL_COUNT&gt;AVL_MIN.        NOTE: Because of issue captured in CDT_005539-348, the only valid values for AVL_MIN are 1,2,4 and 8.</description>
                    <bitRange>[9:5]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>AVL_ENABLE</name>
                    <description>Enables the functioning of AVL_COUNT and AVL_MIN. When 0, it will disable both stalling on AVL_MIN and generation of the sck_more_buf_avl signal described above.</description>
                    <bitRange>[10:10]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>SCK_ZLP_ALWAYS</name>
                    <description>When enabled, an EOT with len==0 will use the next descriptor and generate a ZLP.  When disabled and EOT with len==0 wraps the current descriptor with no ZLP (the new behavior)</description>
                    <bitRange>[11:11]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>STATE</name>
                    <description>Internal operating state of the socket.  This field is used for debugging and to safely modify active sockets (see go_suspend).</description>
                    <bitRange>[17:15]</bitRange>
                    <access>read-only</access>
                    <enumeratedValues>
                      <enumeratedValue>
                        <name>DESCR</name>
                        <description>Descriptor state. This is the default initial state indicating the descriptor registers are NOT valid in the Adapter. The Adapter will start loading the descriptor from memory if the socket becomes enabled and not suspended. Suspend has no effect on any other state.</description>
                        <value>0</value>
                      </enumeratedValue>
                      <enumeratedValue>
                        <name>STALL</name>
                        <description>Stall state. Socket is stalled waiting for data to be loaded into the Fetch Queue or waiting for an event.</description>
                        <value>1</value>
                      </enumeratedValue>
                      <enumeratedValue>
                        <name>ACTIVE</name>
                        <description>Active state. Socket is available for core data transfers.</description>
                        <value>2</value>
                      </enumeratedValue>
                      <enumeratedValue>
                        <name>EVENT</name>
                        <description>Event state. Core transfer is done. Descriptor is being written back to memory and an event is being generated if enabled.</description>
                        <value>3</value>
                      </enumeratedValue>
                      <enumeratedValue>
                        <name>CHECK1</name>
                        <description>Check states. An active socket gets here based on the core's EOP request to check the Transfer size and determine whether the buffer should be wrapped up. Depending on result, socket will either go back to Active state or move to the Event state.</description>
                        <value>4</value>
                      </enumeratedValue>
                      <enumeratedValue>
                        <name>SUSPENDED</name>
                        <description>Socket is suspended</description>
                        <value>5</value>
                      </enumeratedValue>
                      <enumeratedValue>
                        <name>CHECK2</name>
                        <description>Check states. An active socket gets here based on the core's EOP request to check the Transfer size and determine whether the buffer should be wrapped up. Depending on result, socket will either go back to Active state or move to the Event state.</description>
                        <value>6</value>
                      </enumeratedValue>
                      <enumeratedValue>
                        <name>WAITING</name>
                        <description>Waiting for confirmation that event was sent.</description>
                        <value>7</value>
                      </enumeratedValue>
                    </enumeratedValues>
                  </field>
                  <field>
                    <name>ZLP_RCVD</name>
                    <description>Indicates the socket received a ZLP</description>
                    <bitRange>[18:18]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>SUSPENDED</name>
                    <description>Indicates the socket is currently in suspend state.  In suspend mode there is no active descriptor; any previously active descriptor has been wrapped up, copied back to memory and SCK_DSCR.dscr_number has been updated using DSCR_CHAIN as needed.  If the next descriptor is known (SCK_DSCR.dscr_number!=0xFFFF), this descriptor will be loaded after the socket resumes from suspend state.
A socket can only be resumed by changing go_suspend from 1 to 0.  If the socket is suspended while go_suspend=0, it must first be set and then again cleared.</description>
                    <bitRange>[19:19]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>ENABLED</name>
                    <description>Indicates the socket is currently enabled when asserted.  After go_enable is changed, it may take some time for enabled to make the same change.  This value can be polled to determine this fact.</description>
                    <bitRange>[20:20]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>TRUNCATE</name>
                    <description>Enable (1) or disable (0) truncating of BYTE_COUNT when TRANS_COUNT+BYTE_COUNT&gt;=TRANS_SIZE.  When enabled, ensures that an ingress transfer never contains more bytes then allowed.  This function is needed to implement burst-based prototocols that can only transmit full bursts of more than 1 byte.</description>
                    <bitRange>[21:21]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>EN_PROD_EVENTS</name>
                    <description>Enable (1) or disable (0) sending of produce events from any descriptor in this socket.  If 0, events will be suppressed, and the descriptor will not be copied back into memory when completed.</description>
                    <bitRange>[22:22]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>EN_CONS_EVENTS</name>
                    <description>Enable (1) or disable (0) sending of consume events from any descriptor in this socket.  If 0, events will be suppressed, and the descriptor will not be copied back into memory when completed.</description>
                    <bitRange>[23:23]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>SUSP_PARTIAL</name>
                    <description>When set, the socket will suspend before activating a descriptor with BYTE_COUNT&lt;BUFFER_SIZE.
This is relevant for egress sockets only.</description>
                    <bitRange>[24:24]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>SUSP_LAST</name>
                    <description>When set, the socket will suspend before activating a descriptor with TRANS_COUNT+BUFFER_SIZE&gt;=TRANS_SIZE.  This is relevant for both ingress and egress sockets. As captured in CDT_005539-345, due to a bug, when socket suspends on SUS_LAST, the SCK_COUNT value reflected is TRANS_COUNT+BUFFER_SIZE even though the actual bytes transferred by the socket is TRANS_COUNT only.</description>
                    <bitRange>[25:25]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>SUSP_TRANS</name>
                    <description>When set, the socket will suspend when trans_count &gt;= trans_size.  This equation is checked (and hence the socket will suspend) only at the boundary of buffers and packets (ie. buffer wrapup or EOP assertion).</description>
                    <bitRange>[26:26]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>SUSP_EOP</name>
                    <description>When set, the socket will suspend after wrapping up the first buffer with dscr.eop=1.  Note that this function will work the same for both ingress and egress sockets.</description>
                    <bitRange>[27:27]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>WRAPUP</name>
                    <description>Setting this bit will forcibly wrap-up a socket, whether it is out of data or not.  This option is intended mainly for ingress sockets, but works also for egress sockets.  Any remaining data in fetch buffers is ignored, in write buffers is flushed.  Transaction and buffer counts are updated normally, and suspend behavior also happens normally (depending on various other settings in this register).G45</description>
                    <bitRange>[28:28]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>UNIT</name>
                    <description>Indicates whether descriptors (1) or bytes (0) are counted by trans_count and trans_size.  Descriptors are counting regardless of whether they contain any data or have eop set.</description>
                    <bitRange>[29:29]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>GO_SUSPEND</name>
                    <description>Directs a socket to go into suspend mode when the current descriptor completes.  The main use of this bit is to safely append descriptors to an active socket without actually suspending it (in most cases). The process is outlined in more detail in the architecture spec, and looks as follows:
1: GO_SUSPEND=1
2: modify the chain in memory
3: check if active descriptor is 0xFFFF or last in chain
4: if so, make corrections as neccessary (complicated)
5: clear any pending suspend interrupts (SCK_INTR[9:5])
6: GO_SUSPEND=0
Note that the socket resumes only when SCK_INTR[9:5]=0 and GO_SUSPEND=0.</description>
                    <bitRange>[30:30]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>GO_ENABLE</name>
                    <description>Indicates whether socket is enabled.  When go_enable is cleared while socket is active, ongoing transfers are aborted after an unspecified amount of time.  No update occurs from the descriptor registers back into memory.  When go_enable is changed from 0 to 1, the socket will reload the active descriptor from memory regardless of the contents of DSCR_ registers. The socket will not wait for an EVENT to become active if the descriptor is available and ready for transfer (has space or data). 
The 'enabled' bit indicates whether the socket is actually enabled or not.  This field lags go_enable by an short but unspecificied of time.</description>
                    <bitRange>[31:31]</bitRange>
                    <access>read-write</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>SCK_INTR</name>
                <description>Socket Interrupt Request Register</description>
                <addressOffset>0x10</addressOffset>
                <size>32</size>
                <access>read-write</access>
                <resetValue>0x0</resetValue>
                <resetMask>0x7FF</resetMask>
                <fields>
                  <field>
                    <name>PRODUCE_EVENT</name>
                    <description>Indicates that a produce event has been transmitted since last cleared.</description>
                    <bitRange>[0:0]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>CONSUME_EVENT</name>
                    <description>Indicates that a consume event has been transmitted since last cleared.</description>
                    <bitRange>[1:1]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>DSCR_IS_LOW</name>
                    <description>Indicates that dscr_count has fallen below its watermark dscr_low.  If dscr_count wraps around to 255 dscr_is_low will remain asserted until cleared by s/w</description>
                    <bitRange>[2:2]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>DSCR_NOT_AVL</name>
                    <description>Indicates the no descriptor is available.  Not available means that the current descriptor number is 0xFFFF.  Note that this bit will remain asserted until cleared by s/w, regardless of whether a new descriptor number is loaded.</description>
                    <bitRange>[3:3]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>STALL</name>
                    <description>Indicates the socket has stalled, waiting for an event signaling its descriptor has become available. Note that this bit will remain asserted until cleared by s/w, regardless of whether the socket resumes.</description>
                    <bitRange>[4:4]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>SUSPEND</name>
                    <description>Indicates the socket has gone into suspend mode.  This may be caused by any hardware initiated condition (e.g. DSCR_NOT_AVL, any of the SUSP_*) or by setting GO_SUSPEND=1.  Note that this bit will remain asserted until cleared by s/w, regardless of whether the suspend condition is resolved.  
Note that the socket resumes only when SCK_INTR[9:5]=0 and GO_SUSPEND=0.</description>
                    <bitRange>[5:5]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>ERROR</name>
                    <description>Indicates the socket is suspended because of an error condition (internal to the adapter) - if error=1 then suspend=1 as well.  Possible error causes are:
- dscr_size.buffer_error bit already set in the descriptor.
- dscr_size.byte_count &gt; dscr_size.buffer_size 
- core writes into an inactive socket.
- core did not consume all the data in the buffer.
Note that the socket resumes only when SCK_INTR[9:5]=0 and GO_SUSPEND=0.</description>
                    <bitRange>[6:6]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>TRANS_DONE</name>
                    <description>Indicates that TRANS_COUNT has reached the limit TRANS_SIZE.  This flag is only set when SUSP_TRANS=1.  Note that because TRANS_COUNT is updated only at the granularity of entire buffers, it is possible that TRANS_COUNT exceeds TRANS_SIZE before the socket suspends.  Software must detect and deal with these situations.  When asserting EOP to the adapter on ingress, the trans_count is not updated unless the socket actually suspends (see SUSP_TRANS).
Note that the socket resumes only when SCK_INTR[9:5]=0 and GO_SUSPEND=0.</description>
                    <bitRange>[7:7]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>PARTIAL_BUF</name>
                    <description>Indicates that the (egress) socket was suspended because of SUSP_PARTIAL condition.  Note that the socket resumes only when SCK_INTR[9:5]=0 and GO_SUSPEND=0.</description>
                    <bitRange>[8:8]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>LAST_BUF</name>
                    <description>Indicates that the socket was suspended because of SUSP_LAST condition.  Note that the socket resumes only when SCK_INTR[9:5]=0 and GO_SUSPEND=0.</description>
                    <bitRange>[9:9]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>EVENT_RCVD</name>
                    <description>Indicates that an event has been received. (For a consuming socket this means a produce event has been received. For a producing socket this means a consume event has been received.)</description>
                    <bitRange>[10:10]</bitRange>
                    <access>read-write</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>SCK_INTR_MASK</name>
                <description>Socket Interrupt Mask Register</description>
                <addressOffset>0x14</addressOffset>
                <size>32</size>
                <access>read-write</access>
                <resetValue>0x0</resetValue>
                <resetMask>0x7FF</resetMask>
                <fields>
                  <field>
                    <name>PRODUCE_EVENT</name>
                    <description>1: Report interrupt to CPU</description>
                    <bitRange>[0:0]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>CONSUME_EVENT</name>
                    <description>1: Report interrupt to CPU</description>
                    <bitRange>[1:1]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>DSCR_IS_LOW</name>
                    <description>1: Report interrupt to CPU</description>
                    <bitRange>[2:2]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>DSCR_NOT_AVL</name>
                    <description>1: Report interrupt to CPU</description>
                    <bitRange>[3:3]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>STALL</name>
                    <description>1: Report interrupt to CPU</description>
                    <bitRange>[4:4]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>SUSPEND</name>
                    <description>1: Report interrupt to CPU</description>
                    <bitRange>[5:5]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>ERROR</name>
                    <description>1: Report interrupt to CPU</description>
                    <bitRange>[6:6]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>TRANS_DONE</name>
                    <description>1: Report interrupt to CPU</description>
                    <bitRange>[7:7]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>PARTIAL_BUF</name>
                    <description>1: Report interrupt to CPU</description>
                    <bitRange>[8:8]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>LAST_BUF</name>
                    <description>1: Report interrupt to CPU</description>
                    <bitRange>[9:9]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>EVENT_RCVD</name>
                    <description>1: Report interrupt to CPU</description>
                    <bitRange>[10:10]</bitRange>
                    <access>read-write</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>DSCR_BUFFER</name>
                <description>Descriptor buffer base address register</description>
                <addressOffset>0x20</addressOffset>
                <size>32</size>
                <access>read-write</access>
                <resetValue>0x0</resetValue>
                <resetMask>0xFFFFFFFF</resetMask>
                <fields>
                  <field>
                    <name>BUFFER_ADDR</name>
                    <description>The base address of the buffer where data is written.  This address is not necessarily word-aligned to allow for header/trailer/length modification.</description>
                    <bitRange>[30:0]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>MARKER</name>
                    <description>A marker that is provided by s/w and can be observed by the IP.  It's meaning is defined by the IP that uses it.  This bit has no effect on the other DMA mechanisms.</description>
                    <bitRange>[31:31]</bitRange>
                    <access>read-write</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>DSCR_SYNC</name>
                <description>Descriptor synchronization pointers register</description>
                <addressOffset>0x24</addressOffset>
                <size>32</size>
                <access>read-write</access>
                <resetValue>0x0</resetValue>
                <resetMask>0xFFFFFFFF</resetMask>
                <fields>
                  <field>
                    <name>CONS_SCK</name>
                    <description>The socket number of the consuming socket to which the produce event shall be sent.
If cons_ip and cons_sck matches the socket's IP and socket number then the matching socket becomes consuming socket.</description>
                    <bitRange>[7:0]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>CONS_IP</name>
                    <description>The IP number of the consuming socket to which the produce event shall be sent.  Use 0x3F to designate ARM CPU (so software) as consumer; the event will be lost in this case and an interrupt should also be generated to observe this condition.</description>
                    <bitRange>[13:8]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>EN_CONS_EVENT</name>
                    <description>Enable sending of a consume events from this descriptor only.  Events are sent only if SCK_STATUS.en_consume_ev=1.  When events are disabled, the adapter also does not update the descriptor in memory to clear its occupied bit.</description>
                    <bitRange>[14:14]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>EN_CONS_INT</name>
                    <description>Enable generation of a consume event interrupt for this descriptor only.  This interrupt will only be seen by the CPU if SCK_STATUS.int_mask has this interrupt enabled as well.  Note that this flag influences the logging of the interrupt in SCK_STATUS; it has no effect on the reporting of the interrupt to the CPU like SCK_STATUS.int_mask does.</description>
                    <bitRange>[15:15]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>PROD_SCK</name>
                    <description>The socket number of the producing socket to which the consume event shall be sent. If prod_ip and prod_sck matches the socket's IP and socket number then the matching socket becomes consuming socket.</description>
                    <bitRange>[23:16]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>PROD_IP</name>
                    <description>The IP number of the producing socket to which the consume event shall be sent. Use 0x3F to designate ARM CPU (so software) as producer; the event will be lost in this case and an interrupt should also be generated to observe this condition.</description>
                    <bitRange>[29:24]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>EN_PROD_EVENT</name>
                    <description>Enable sending of a produce events from this descriptor only.  Events are sent only if SCK_STATUS.en_produce_ev=1.  If 0, events will be suppressed, and the descriptor will not be copied back into memory when completed.</description>
                    <bitRange>[30:30]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>EN_PROD_INT</name>
                    <description>Enable generation of a produce event interrupt for this descriptor only. This interrupt will only be seen by the CPU if SCK_STATUS. int_mask has this interrupt enabled as well.  Note that this flag influences the logging of the interrupt in SCK_STATUS; it has no effect on the reporting of the interrupt to the CPU like SCK_STATUS.int_mask does.</description>
                    <bitRange>[31:31]</bitRange>
                    <access>read-write</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>DSCR_CHAIN</name>
                <description>Descriptor Chain Pointers Register</description>
                <addressOffset>0x28</addressOffset>
                <size>32</size>
                <access>read-write</access>
                <resetValue>0x0</resetValue>
                <resetMask>0xFFFFFFFF</resetMask>
                <fields>
                  <field>
                    <name>RD_NEXT_DSCR</name>
                    <description>Descriptor number of the next task for consumer. A value of 0xFFFF signals end of this list.</description>
                    <bitRange>[15:0]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>WR_NEXT_DSCR</name>
                    <description>Descriptor number of the next task for producer. A value of 0xFFFF signals end of this list.</description>
                    <bitRange>[31:16]</bitRange>
                    <access>read-write</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>DSCR_SIZE</name>
                <description>Descriptor Size Register</description>
                <addressOffset>0x2C</addressOffset>
                <size>32</size>
                <access>read-write</access>
                <resetValue>0x0</resetValue>
                <resetMask>0xFFFFFFFF</resetMask>
                <fields>
                  <field>
                    <name>BYTE_COUNT_MSB</name>
                    <description>When this bit is 1 and BYTE_COUNT is '0', it indicates that byte count is 64KB</description>
                    <bitRange>[0:0]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>EOP</name>
                    <description>A marker indicating this descriptor refers to the last buffer of a packet or transfer. Packets/transfers may span more than one buffer.  The producing IP provides this marker by providing the EOP signal to its DMA adapter.  The consuming IP observes this marker by inspecting its EOP return signal from its own DMA adapter. For more information see section on packets, buffers and transfers in DMA chapter.</description>
                    <bitRange>[1:1]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>BUFFER_ERROR</name>
                    <description>Indicates the buffer data is valid (0) or in error (1).</description>
                    <bitRange>[2:2]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>BUFFER_OCCUPIED</name>
                    <description>Indicates the buffer is in use (1) or empty (0).  A consumer will interpret this as:
0: Buffer is empty, wait until filled.
1: Buffer has data that can be consumed
A produce will interpret this as:
0: Buffer is ready to be filled
1: Buffer is occupied, wait until empty</description>
                    <bitRange>[3:3]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>BUFFER_SIZE</name>
                    <description>The size of the buffer in multiples of 16 bytes. (When BUFFSIZE_64KB_EN is '1', this indicates the size of the buffer in multiples of 32 bytes.)</description>
                    <bitRange>[15:4]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>BYTE_COUNT</name>
                    <description>The number of data bytes present in the buffer.  An occupied buffer is not always full, in particular when variable length packets are transferred.</description>
                    <bitRange>[31:16]</bitRange>
                    <access>read-write</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>EVENT</name>
                <description>Event Communication Register</description>
                <addressOffset>0x7C</addressOffset>
                <size>32</size>
                <access>write-only</access>
                <resetValue>0x0</resetValue>
                <resetMask>0x1FFFF</resetMask>
                <fields>
                  <field>
                    <name>ACTIVE_DSCR</name>
                    <description>The active descriptor number for which the event is sent.</description>
                    <bitRange>[15:0]</bitRange>
                    <access>write-only</access>
                  </field>
                  <field>
                    <name>EVENT_TYPE</name>
                    <description>Type of event
0: Consume event descriptor is marked empty - BUFFER_OCCUPIED=0)
1: Produce event descriptor is marked full = BUFFER_OCCUPIED=1)</description>
                    <bitRange>[16:16]</bitRange>
                    <access>write-only</access>
                  </field>
                </fields>
              </register>
            </cluster>
            <cluster>
              <name>SCK_GBL</name>
              <description>General DMA Registers</description>
              <addressOffset>0x0000FF00</addressOffset>
              <register>
                <name>SCK_INTR</name>
                <description>Socket Interrupt Request Register</description>
                <addressOffset>0x0</addressOffset>
                <size>32</size>
                <access>read-only</access>
                <resetValue>0x0</resetValue>
                <resetMask>0xFFFFFFFF</resetMask>
                <fields>
                  <field>
                    <name>SCKINTR</name>
                    <description>Socket &lt;x&gt; asserts interrupt when bit &lt;x&gt; is set in this vector.  Multiple bits may be set to 1 simultaneously.
This register is only as wide as the number of socket in the adapter; 256 is just the maximum width.  All other bits always return 0.</description>
                    <bitRange>[31:0]</bitRange>
                    <access>read-only</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>ADAPTER_CTRL</name>
                <description>Adapter Control Register</description>
                <addressOffset>0xF0</addressOffset>
                <size>32</size>
                <access>read-write</access>
                <resetValue>0xE000000</resetValue>
                <resetMask>0x3F33F4F1</resetMask>
                <fields>
                  <field>
                    <name>ADAPTER_EN</name>
                    <description>0: Adapter is disabled, Resets the adapter logic, this reset is an async reset.
1: Adapter is enabled.</description>
                    <bitRange>[0:0]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>ADAP_DATA_WR_PRIO</name>
                    <description>When this bit is set for only one adapter, priority is given during arbitration for data writes. When this bit is set or unset in both adapters, roundrobin arbitration happens between two data writes.</description>
                    <bitRange>[4:4]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>ADAP_DATA_RD_PRIO</name>
                    <description>When this bit is set for only one adapter, priority is given during arbitration for data reads. When this bit is set or unset in both adapters, roundrobin arbitration happens between two data reads.</description>
                    <bitRange>[5:5]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>ADAP_DESC_WR_PRIO_N</name>
                    <description>When this bit is '0' for only one adapter, priority is given during arbitration for descriptor writes over data writes. When this bit is set or unset in both adapters, roundrobin arbitration happens between two descriptor writes. By default, descriptor writes are given high priority over data writes.</description>
                    <bitRange>[6:6]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>ADAP_DESC_RD_PRIO_N</name>
                    <description>When this bit is '0' for only one adapter, priority is given during arbitration for descriptor reads over data reads. When this bit is set or unset in both adapters, roundrobin arbitration happens between two descriptor reads. By default, descriptor reads are given high priority over data reads.</description>
                    <bitRange>[7:7]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>SUSP_PARTIAL_NO_EVT_N</name>
                    <description>When low, ensures that no consume event is generated when SUSP_PARTIAL is enabled and BYTE_COUNT&lt;BUFFER_SIZE.</description>
                    <bitRange>[10:10]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>FQ_DEPTH_CTRL</name>
                    <description>Number of entries in the socket fetch Queue (FQ). Default is a value of '0', which means entire FQ_DEPTH defined by parameter is used. Because of FSM timing, the FQ depth must be atleast 5.</description>
                    <bitRange>[17:12]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>DEBUG_CAPTURE</name>
                    <description>When set, the internal debug signals will be captured in the Ingress Adapater RQ. This setting can be used for both Ingress and Egress adapters but not all debug signals being captured will be valid.</description>
                    <bitRange>[20:20]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>EN_UNALIGNED_READ_N</name>
                    <description>When low, the adapter will support reads from Unaligned Buffer Start Address. When set high, the dut will revert to A0 RTL and not support Unaligned Buffer Reads.</description>
                    <bitRange>[21:21]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>TR_OUT_DELAY</name>
                    <description>Number of cycles it takes to send out a trigger after a descriptor writeback condition is met. The default and minimum value for this register is 0x14 (20 Cycles). The max value that can be programmed is 0x3F</description>
                    <bitRange>[29:24]</bitRange>
                    <access>read-write</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>ADAPTER_DEBUG</name>
                <description>Adapter Debug Observation Register</description>
                <addressOffset>0xF4</addressOffset>
                <size>32</size>
                <access>read-only</access>
                <resetValue>0x0</resetValue>
                <resetMask>0xFFFFFFFF</resetMask>
                <fields>
                  <field>
                    <name>TS_COUNT</name>
                    <description>Internal adapter state for debug observation</description>
                    <bitRange>[3:0]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>TS_STATE</name>
                    <description>Internal adapter state for debug observation</description>
                    <bitRange>[6:4]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>TS_ID</name>
                    <description>Internal adapter state for debug observation</description>
                    <bitRange>[12:7]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>SS_COUNT</name>
                    <description>Internal adapter state for debug observation</description>
                    <bitRange>[21:13]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>SS_STATE</name>
                    <description>Internal adapter state for debug observation</description>
                    <bitRange>[22:22]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>SS_ID</name>
                    <description>Internal adapter state for debug observation</description>
                    <bitRange>[28:23]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>TS_ABORT</name>
                    <description>Internal adapter state for debug observation</description>
                    <bitRange>[29:29]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>BS_STATE</name>
                    <description>Internal adapter state for debug observation</description>
                    <bitRange>[31:30]</bitRange>
                    <access>read-only</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>ADAPTER_CONF</name>
                <description>Adapter Configuration Register</description>
                <addressOffset>0xF8</addressOffset>
                <size>32</size>
                <access>read-write</access>
                <resetValue>0x10000000</resetValue>
                <resetMask>0xFFFFFFFF</resetMask>
                <fields>
                  <field>
                    <name>SOCKET_ACTIVE_THRSHLD</name>
                    <description>Number of entries in a socket fetch queue (FQ) that must be present before sck_active asserts.  Default value is 0, which means the entire FQ must fill up before sck_active asserts.
NOTE: The default value for this field is the entire FQ_DEPTH which are different for Egress/Ingress.</description>
                    <bitRange>[5:0]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>STREAM_COUNT</name>
                    <description>Number of burst requests to issue without examining the FQ depth (because IP Core can guarantee immediate consumption).</description>
                    <bitRange>[14:6]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>STREAMING_MODE</name>
                    <description>0: Do not make fetch requests unless fetch queue has space to hold response (default).
1: Assume IP Core will drain all data as it comes in.  Place fetch requests on bus as fast as possible (DO NOT USE UNLESS YOU KNOW WHAT YOU ARE DOING).</description>
                    <bitRange>[15:15]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>TS_CYCLES</name>
                    <description>Minimum cycles between prefetch requests to the bus.  The adapter will wait for this number of cycles in between prefetch burst requests when activating a descriptor on a socket.  If TS_CYCLES=0, the requests will be sent back-to-back (assuming queues are not full).</description>
                    <bitRange>[19:16]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>ES_CYCLES</name>
                    <description>Minimum cycles between fetch requests to the bus under normal operation.  The adapter will wait for this number of cycles in between burst requests when refilling a fetch queue for a desriptor  If ES_CYCLES=0, the requests may be sent back-to-back (assuming queues are not full).</description>
                    <bitRange>[23:20]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>GBL_CYCLES</name>
                    <description>Minimum cycles between any fetch requests to the bus.  The adapter will wait for this number of cycles in between any fetch or prefetch burst requests when activating a descriptor on a socket.  If GBL_CYCLES=0, the requests may be sent back-to-back (assuming queues are not full).</description>
                    <bitRange>[27:24]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>MMIO_LOW_PRIORITY</name>
                    <description>Sets priority between MMIO and Core requests:
0: fair arbitration. MMIO is guaranteed to win the next cycle if there was a collision with the core request in the first cycle.
1: low priority. MMIO will never win if the core has a request.</description>
                    <bitRange>[28:28]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>SWITCH_HIGH_PRIORITY</name>
                    <description>Socket swicth higher priority than interconnect</description>
                    <bitRange>[29:29]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>TS_ABORT_EN</name>
                    <description>Allow TS to be aborted</description>
                    <bitRange>[30:30]</bitRange>
                    <access>read-write</access>
                  </field>
                  <field>
                    <name>DESCR_PF_EN_N</name>
                    <description>When low, enables new descriptor pre-fetch logic for improved latency</description>
                    <bitRange>[31:31]</bitRange>
                    <access>read-write</access>
                  </field>
                </fields>
              </register>
              <register>
                <name>ADAPTER_STATUS</name>
                <description>Adapter Global Status Fields</description>
                <addressOffset>0xFC</addressOffset>
                <size>32</size>
                <access>read-only</access>
                <resetValue>0x0</resetValue>
                <resetMask>0x7FFFFFF</resetMask>
                <fields>
                  <field>
                    <name>TTL_SOCKETS</name>
                    <description>Total number of sockets in this adapter.  This number is different for each instance of the adapter and varies with the core IP needs.</description>
                    <bitRange>[7:0]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>IG_ONLY</name>
                    <description>First socket number that is ingress only.
0..IG_ONLY-1:   Sockets capable of both in and egress
IG_ONLY..TTL_SOCKETS-1:  Ingress sockets only</description>
                    <bitRange>[15:8]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>FQ_SIZE</name>
                    <description>Number of words in a socket fetch queue (FQ).  The total buffer space in the adapter is EG_SOCKETS*FQ_SIZE words of size WORD_SIZE.</description>
                    <bitRange>[24:16]</bitRange>
                    <access>read-only</access>
                  </field>
                  <field>
                    <name>WORD_SIZE</name>
                    <description>Internal word size of the prefetch queue (FQ); not the same as bus width of AHB bus or thread interface to the IP.
0: 32b
1: 64b
2: 128b
3: 256b</description>
                    <bitRange>[26:25]</bitRange>
                    <access>read-only</access>
                  </field>
                </fields>
              </register>
            </cluster>
          </cluster>
        </cluster>
      </registers>
    </peripheral>
  </peripherals>
</device>